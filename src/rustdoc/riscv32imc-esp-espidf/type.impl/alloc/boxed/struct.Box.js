(function() {var type_impls = {
"rsiot":[["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Box%3CT%3E\" class=\"impl\"><a href=\"#impl-Box%3CT%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T&gt; Box&lt;T&gt;</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.new\" class=\"method\"><span class=\"since rightside\" title=\"Stable since Rust version 1.0.0\">1.0.0</span><h4 class=\"code-header\">pub fn <a class=\"fn\">new</a>(x: T) -&gt; Box&lt;T&gt;</h4></section></summary><div class=\"docblock\"><p>Allocates memory on the heap and then places <code>x</code> into it.</p>\n<p>This doesnâ€™t actually allocate if <code>T</code> is zero-sized.</p>\n<h5 id=\"examples\"><a class=\"doc-anchor\" href=\"#examples\">Â§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>five = Box::new(<span class=\"number\">5</span>);</code></pre></div>\n</div><div class=\"docblock scraped-example-list\"><span></span><h5 id=\"scraped-examples\"><a href=\"#scraped-examples\">Examples found in repository</a><a class=\"scrape-help\" href=\"scrape-examples-help.html\">?</a></h5><div class=\"scraped-example \" data-locs=\"[[[44,44],&quot;src/cmp_external_fn_process/cmp_external_fn_process.rs.html#55&quot;,&quot;line 55&quot;]]\"><div class=\"scraped-example-title\">examples/cmp_external_fn_process/cmp_external_fn_process.rs (<a href=\"src/cmp_external_fn_process/cmp_external_fn_process.rs.html#55\">line 55</a>)</div><div class=\"code-wrapper\"><div class=\"example-wrap\"><div data-nosnippet><pre class=\"src-line-numbers\"><span>11</span>\n<span>12</span>\n<span>13</span>\n<span>14</span>\n<span>15</span>\n<span>16</span>\n<span>17</span>\n<span>18</span>\n<span>19</span>\n<span>20</span>\n<span>21</span>\n<span>22</span>\n<span>23</span>\n<span>24</span>\n<span>25</span>\n<span>26</span>\n<span>27</span>\n<span>28</span>\n<span>29</span>\n<span>30</span>\n<span>31</span>\n<span>32</span>\n<span>33</span>\n<span>34</span>\n<span>35</span>\n<span>36</span>\n<span>37</span>\n<span>38</span>\n<span>39</span>\n<span>40</span>\n<span>41</span>\n<span>42</span>\n<span>43</span>\n<span>44</span>\n<span>45</span>\n<span>46</span>\n<span>47</span>\n<span>48</span>\n<span>49</span>\n<span>50</span>\n<span>51</span>\n<span>52</span>\n<span>53</span>\n<span>54</span>\n<span>55</span>\n<span>56</span>\n<span>57</span>\n<span>58</span>\n<span>59</span>\n<span>60</span>\n<span>61</span>\n<span>62</span>\n<span>63</span>\n<span>64</span>\n<span>65</span>\n<span>66</span>\n<span>67</span>\n<span>68</span>\n<span>69</span>\n<span>70</span>\n<span>71</span>\n<span>72</span>\n</pre></div><pre class=\"rust\"><code><button class=\"expand\">&varr;</button><span class=\"kw\">async fn </span>main() {\n    <span class=\"kw\">use </span>std::time::Duration;\n\n    <span class=\"attr\">#[cfg(not(feature = <span class=\"string\">\"single-thread\"</span>))]\n    </span><span class=\"kw\">use </span>futures::future::BoxFuture;\n    <span class=\"attr\">#[cfg(feature = <span class=\"string\">\"single-thread\"</span>)]\n    </span><span class=\"kw\">use </span>futures::future::LocalBoxFuture;\n    <span class=\"kw\">use </span>tokio::{task::LocalSet, time::sleep};\n    <span class=\"kw\">use </span>tracing::{info, level_filters::LevelFilter};\n\n    <span class=\"kw\">use </span>rsiot::{\n        components::cmp_external_fn_process,\n        executor::{CmpInOut, CmpResult, ComponentExecutor, ComponentExecutorConfig},\n        message::{example_message::<span class=\"kw-2\">*</span>, <span class=\"kw-2\">*</span>},\n    };\n\n    <span class=\"kw\">async fn </span>fn_process&lt;TMsg&gt;(_input: CmpInOut&lt;TMsg&gt;) -&gt; CmpResult {\n        <span class=\"kw\">loop </span>{\n            <span class=\"macro\">info!</span>(<span class=\"string\">\"External fn process\"</span>);\n            sleep(Duration::from_secs(<span class=\"number\">2</span>)).<span class=\"kw\">await</span>;\n        }\n    }\n\n    <span class=\"attr\">#[cfg(feature = <span class=\"string\">\"single-thread\"</span>)]\n    </span><span class=\"kw\">fn </span>fn_process_wrapper&lt;TMsg&gt;(input: CmpInOut&lt;TMsg&gt;) -&gt; LocalBoxFuture&lt;<span class=\"lifetime\">'static</span>, CmpResult&gt;\n    <span class=\"kw\">where\n        </span>TMsg: MsgDataBound + <span class=\"lifetime\">'static</span>,\n    {\n        Box::pin(<span class=\"kw\">async </span>{ fn_process(input).<span class=\"kw\">await </span>})\n    }\n\n    <span class=\"attr\">#[cfg(not(feature = <span class=\"string\">\"single-thread\"</span>))]\n    </span><span class=\"kw\">fn </span>fn_process_wrapper&lt;TMsg&gt;(input: CmpInOut&lt;TMsg&gt;) -&gt; BoxFuture&lt;<span class=\"lifetime\">'static</span>, CmpResult&gt;\n    <span class=\"kw\">where\n        </span>TMsg: MsgDataBound + <span class=\"lifetime\">'static</span>,\n    {\n        Box::pin(<span class=\"kw\">async </span>{ fn_process(input).<span class=\"kw\">await </span>})\n    }\n\n    tracing_subscriber::fmt()\n        .with_max_level(LevelFilter::DEBUG)\n        .init();\n\n    <span class=\"kw\">let </span>config_external_process = cmp_external_fn_process::Config {\n        fn_process: <span class=\"highlight focus\">Box::new</span>(fn_process_wrapper),\n    };\n\n    <span class=\"kw\">let </span>executor_config = ComponentExecutorConfig {\n        buffer_size: <span class=\"number\">100</span>,\n        executor_name: <span class=\"string\">\"cmp_external_fn_process_single_thread\"</span>.into(),\n        fn_auth: |msg, <span class=\"kw\">_</span>| <span class=\"prelude-val\">Some</span>(msg),\n    };\n\n    <span class=\"kw\">let </span>task_set = LocalSet::new();\n    task_set.spawn_local(<span class=\"kw\">async move </span>{\n        ComponentExecutor::&lt;Custom&gt;::new(executor_config)\n            .add_cmp(cmp_external_fn_process::Cmp::new(config_external_process))\n            .wait_result()\n            .<span class=\"kw\">await\n    </span>});\n    task_set.<span class=\"kw\">await</span>;\n}</code></pre></div></div></div><details class=\"toggle more-examples-toggle\"><summary class=\"hideme\"><span>More examples</span></summary><div class=\"hide-more\">Hide additional examples</div><div class=\"more-scraped-examples\"><div class=\"toggle-line\"><div class=\"toggle-line-inner\"></div></div><div class=\"scraped-example \" data-locs=\"[[[26,42],&quot;src/cmp_derive/cmp_derive.rs.html#39-55&quot;,&quot;lines 39-55&quot;]]\"><div class=\"scraped-example-title\">examples/cmp_derive/cmp_derive.rs (<a href=\"src/cmp_derive/cmp_derive.rs.html#39-55\">lines 39-55</a>)</div><div class=\"code-wrapper\"><div class=\"example-wrap\"><div data-nosnippet><pre class=\"src-line-numbers\"><span>13</span>\n<span>14</span>\n<span>15</span>\n<span>16</span>\n<span>17</span>\n<span>18</span>\n<span>19</span>\n<span>20</span>\n<span>21</span>\n<span>22</span>\n<span>23</span>\n<span>24</span>\n<span>25</span>\n<span>26</span>\n<span>27</span>\n<span>28</span>\n<span>29</span>\n<span>30</span>\n<span>31</span>\n<span>32</span>\n<span>33</span>\n<span>34</span>\n<span>35</span>\n<span>36</span>\n<span>37</span>\n<span>38</span>\n<span>39</span>\n<span>40</span>\n<span>41</span>\n<span>42</span>\n<span>43</span>\n<span>44</span>\n<span>45</span>\n<span>46</span>\n<span>47</span>\n<span>48</span>\n<span>49</span>\n<span>50</span>\n<span>51</span>\n<span>52</span>\n<span>53</span>\n<span>54</span>\n<span>55</span>\n<span>56</span>\n<span>57</span>\n<span>58</span>\n<span>59</span>\n<span>60</span>\n<span>61</span>\n<span>62</span>\n<span>63</span>\n<span>64</span>\n<span>65</span>\n<span>66</span>\n<span>67</span>\n<span>68</span>\n<span>69</span>\n<span>70</span>\n<span>71</span>\n<span>72</span>\n<span>73</span>\n<span>74</span>\n<span>75</span>\n<span>76</span>\n<span>77</span>\n<span>78</span>\n<span>79</span>\n<span>80</span>\n<span>81</span>\n<span>82</span>\n<span>83</span>\n<span>84</span>\n<span>85</span>\n<span>86</span>\n<span>87</span>\n<span>88</span>\n<span>89</span>\n<span>90</span>\n<span>91</span>\n<span>92</span>\n<span>93</span>\n<span>94</span>\n<span>95</span>\n<span>96</span>\n<span>97</span>\n<span>98</span>\n<span>99</span>\n<span>100</span>\n<span>101</span>\n<span>102</span>\n<span>103</span>\n<span>104</span>\n<span>105</span>\n<span>106</span>\n<span>107</span>\n<span>108</span>\n<span>109</span>\n<span>110</span>\n<span>111</span>\n<span>112</span>\n<span>113</span>\n<span>114</span>\n<span>115</span>\n<span>116</span>\n<span>117</span>\n</pre></div><pre class=\"rust\"><code><button class=\"expand\">&varr;</button><span class=\"kw\">fn </span>main() -&gt; anyhow::Result&lt;()&gt; {\n    <span class=\"kw\">use </span>std::time::Duration;\n\n    <span class=\"kw\">use </span>tokio::runtime;\n    <span class=\"attr\">#[cfg(feature = <span class=\"string\">\"single-thread\"</span>)]\n    </span><span class=\"kw\">use </span>tokio::task::LocalSet;\n    <span class=\"kw\">use </span>tracing::Level;\n\n    <span class=\"kw\">use </span>rsiot::{\n        components::{\n            cmp_derive::{<span class=\"self\">self</span>, DeriveItem},\n            cmp_inject_periodic, cmp_logger,\n        },\n        executor::{ComponentExecutor, ComponentExecutorConfig},\n        message::{example_message::<span class=\"kw-2\">*</span>, <span class=\"kw-2\">*</span>},\n    };\n\n    tracing_subscriber::fmt().init();\n\n    <span class=\"attr\">#[derive(Clone, Default, PartialEq)]\n    </span><span class=\"kw\">struct </span>ValueInstantString {\n        <span class=\"kw\">pub </span>f64: <span class=\"prelude-ty\">Option</span>&lt;f64&gt;,\n        <span class=\"kw\">pub </span>bool: <span class=\"prelude-ty\">Option</span>&lt;bool&gt;,\n    }\n\n    <span class=\"kw\">let </span>derive_config = cmp_derive::Config {\n        derive_items: <span class=\"macro\">vec!</span>[<span class=\"highlight focus\">Box::new</span>(DeriveItem {\n            store: ValueInstantString::default(),\n            fn_input: |msg, store| <span class=\"kw\">match </span><span class=\"kw-2\">&amp;</span>msg.data {\n                MsgData::Custom(data) =&gt; <span class=\"kw\">match </span>data {\n                    Custom::ValueInstantF64(content) =&gt; store.f64 = <span class=\"prelude-val\">Some</span>(<span class=\"kw-2\">*</span>content),\n                    Custom::ValueInstantBool(content) =&gt; store.bool = <span class=\"prelude-val\">Some</span>(<span class=\"kw-2\">*</span>content),\n                    <span class=\"kw\">_ </span>=&gt; (),\n                },\n                MsgData::System(<span class=\"kw\">_</span>) =&gt; (),\n            },\n            fn_output: |store| {\n                <span class=\"kw\">let </span>msg_content =\n                    <span class=\"macro\">format!</span>(<span class=\"string\">\"New Message: bool: {}, f64: {}\"</span>, store.bool<span class=\"question-mark\">?</span>, store.f64<span class=\"question-mark\">?</span>);\n                <span class=\"kw\">let </span>msg = Message::new(MsgData::Custom(Custom::ValueInstantString(msg_content)));\n                <span class=\"prelude-val\">Some</span>(<span class=\"macro\">vec!</span>[msg])\n            },\n        })],\n    };\n\n    <span class=\"kw\">let </span>logger_config = cmp_logger::Config {\n        level: Level::INFO,\n        header: <span class=\"string\">\"\"</span>.into(),\n    };\n\n    <span class=\"kw\">let </span><span class=\"kw-2\">mut </span>counter = <span class=\"number\">0.0</span>;\n    <span class=\"kw\">let </span>inject_periodic_config = cmp_inject_periodic::Config {\n        period: Duration::from_secs(<span class=\"number\">2</span>),\n        fn_periodic: <span class=\"kw\">move </span>|| {\n            <span class=\"kw\">let </span>msg1 = Message::new_custom(Custom::ValueInstantF64(counter));\n            <span class=\"kw\">let </span>msg2 = Message::new_custom(Custom::ValueInstantBool(<span class=\"bool-val\">true</span>));\n            counter += <span class=\"number\">1.0</span>;\n            <span class=\"macro\">vec!</span>[msg1, msg2]\n        },\n    };\n\n    <span class=\"kw\">let </span>executor_config = ComponentExecutorConfig {\n        buffer_size: <span class=\"number\">100</span>,\n        executor_name: <span class=\"string\">\"example_single_thread\"</span>.into(),\n        fn_auth: |msg, <span class=\"kw\">_</span>| <span class=\"prelude-val\">Some</span>(msg),\n    };\n\n    <span class=\"attr\">#[cfg(not(feature = <span class=\"string\">\"single-thread\"</span>))]\n    </span>runtime::Builder::new_multi_thread()\n        .enable_all()\n        .build()<span class=\"question-mark\">?\n        </span>.block_on(<span class=\"kw\">async move </span>{\n            ComponentExecutor::new(executor_config)\n                .add_cmp(cmp_derive::Cmp::new(derive_config))\n                .add_cmp(cmp_logger::Cmp::new(logger_config))\n                .add_cmp(cmp_inject_periodic::Cmp::new(inject_periodic_config))\n                .wait_result()\n                .<span class=\"kw\">await</span><span class=\"question-mark\">?</span>;\n            <span class=\"prelude-val\">Ok</span>(()) <span class=\"kw\">as </span>anyhow::Result&lt;()&gt;\n        })<span class=\"question-mark\">?</span>;\n\n    <span class=\"attr\">#[cfg(feature = <span class=\"string\">\"single-thread\"</span>)]\n    </span>runtime::Builder::new_current_thread()\n        .enable_all()\n        .build()<span class=\"question-mark\">?\n        </span>.block_on(<span class=\"kw\">async move </span>{\n            <span class=\"kw\">let </span>local_set = LocalSet::new();\n\n            local_set.spawn_local(<span class=\"kw\">async move </span>{\n                ComponentExecutor::new(executor_config)\n                    .add_cmp(cmp_derive::Cmp::new(derive_config))\n                    .add_cmp(cmp_logger::Cmp::new(logger_config))\n                    .add_cmp(cmp_inject_periodic::Cmp::new(inject_periodic_config))\n                    .wait_result()\n                    .<span class=\"kw\">await</span><span class=\"question-mark\">?</span>;\n                <span class=\"prelude-val\">Ok</span>(()) <span class=\"kw\">as </span>anyhow::Result&lt;()&gt;\n            });\n\n            local_set.<span class=\"kw\">await</span>;\n\n            <span class=\"prelude-val\">Ok</span>(()) <span class=\"kw\">as </span>anyhow::Result&lt;()&gt;\n        })<span class=\"question-mark\">?</span>;\n\n    <span class=\"prelude-val\">Ok</span>(())\n}</code></pre></div></div></div></div></details></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.new_uninit\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">new_uninit</a>() -&gt; Box&lt;MaybeUninit&lt;T&gt;&gt;</h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>new_uninit</code>)</span></div></span></summary><div class=\"docblock\"><p>Constructs a new box with uninitialized contents.</p>\n<h5 id=\"examples-1\"><a class=\"doc-anchor\" href=\"#examples-1\">Â§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(new_uninit)]\n\n</span><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>five = Box::&lt;u32&gt;::new_uninit();\n\n<span class=\"kw\">let </span>five = <span class=\"kw\">unsafe </span>{\n    <span class=\"comment\">// Deferred initialization:\n    </span>five.as_mut_ptr().write(<span class=\"number\">5</span>);\n\n    five.assume_init()\n};\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"kw-2\">*</span>five, <span class=\"number\">5</span>)</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.new_zeroed\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">new_zeroed</a>() -&gt; Box&lt;MaybeUninit&lt;T&gt;&gt;</h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>new_uninit</code>)</span></div></span></summary><div class=\"docblock\"><p>Constructs a new <code>Box</code> with uninitialized contents, with the memory\nbeing filled with <code>0</code> bytes.</p>\n<p>See <a href=\"mem::MaybeUninit::zeroed\"><code>MaybeUninit::zeroed</code></a> for examples of correct and incorrect usage\nof this method.</p>\n<h5 id=\"examples-2\"><a class=\"doc-anchor\" href=\"#examples-2\">Â§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(new_uninit)]\n\n</span><span class=\"kw\">let </span>zero = Box::&lt;u32&gt;::new_zeroed();\n<span class=\"kw\">let </span>zero = <span class=\"kw\">unsafe </span>{ zero.assume_init() };\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"kw-2\">*</span>zero, <span class=\"number\">0</span>)</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.pin\" class=\"method\"><span class=\"since rightside\" title=\"Stable since Rust version 1.33.0\">1.33.0</span><h4 class=\"code-header\">pub fn <a class=\"fn\">pin</a>(x: T) -&gt; Pin&lt;Box&lt;T&gt;&gt;</h4></section></summary><div class=\"docblock\"><p>Constructs a new <code>Pin&lt;Box&lt;T&gt;&gt;</code>. If <code>T</code> does not implement [<code>Unpin</code>], then\n<code>x</code> will be pinned in memory and unable to be moved.</p>\n<p>Constructing and pinning of the <code>Box</code> can also be done in two steps: <code>Box::pin(x)</code>\ndoes the same as <code>[Box::into_pin]([Box::new](x))</code>. Consider using\n<a href=\"Box::into_pin\"><code>into_pin</code></a> if you already have a <code>Box&lt;T&gt;</code>, or if you want to\nconstruct a (pinned) <code>Box</code> in a different way than with [<code>Box::new</code>].</p>\n</div><div class=\"docblock scraped-example-list\"><span></span><h5 id=\"scraped-examples-1\"><a href=\"#scraped-examples-1\">Examples found in repository</a><a class=\"scrape-help\" href=\"scrape-examples-help.html\">?</a></h5><div class=\"scraped-example expanded\" data-locs=\"[[[4,4],&quot;src/cmp_external_fn_process/cmp_external_fn_process.rs.html#39&quot;,&quot;line 39&quot;]]\"><div class=\"scraped-example-title\">examples/cmp_external_fn_process/cmp_external_fn_process.rs (<a href=\"src/cmp_external_fn_process/cmp_external_fn_process.rs.html#39\">line 39</a>)</div><div class=\"code-wrapper\"><div class=\"example-wrap\"><div data-nosnippet><pre class=\"src-line-numbers\"><span>35</span>\n<span>36</span>\n<span>37</span>\n<span>38</span>\n<span>39</span>\n<span>40</span>\n</pre></div><pre class=\"rust\"><code>    <span class=\"kw\">fn </span>fn_process_wrapper&lt;TMsg&gt;(input: CmpInOut&lt;TMsg&gt;) -&gt; LocalBoxFuture&lt;<span class=\"lifetime\">'static</span>, CmpResult&gt;\n    <span class=\"kw\">where\n        </span>TMsg: MsgDataBound + <span class=\"lifetime\">'static</span>,\n    {\n        <span class=\"highlight focus\">Box::pin</span>(<span class=\"kw\">async </span>{ fn_process(input).<span class=\"kw\">await </span>})\n    }</code></pre></div></div></div><details class=\"toggle more-examples-toggle\"><summary class=\"hideme\"><span>More examples</span></summary><div class=\"hide-more\">Hide additional examples</div><div class=\"more-scraped-examples\"><div class=\"toggle-line\"><div class=\"toggle-line-inner\"></div></div><div class=\"scraped-example expanded\" data-locs=\"[[[0,5],&quot;src/executor_single_thread/example_component1.rs.html#19-24&quot;,&quot;lines 19-24&quot;]]\"><div class=\"scraped-example-title\">examples/executor/executor-single-thread/example_component1.rs (<a href=\"src/executor_single_thread/example_component1.rs.html#19-24\">lines 19-24</a>)</div><div class=\"code-wrapper\"><div class=\"example-wrap\"><div data-nosnippet><pre class=\"src-line-numbers\"><span>19</span>\n<span>20</span>\n<span>21</span>\n<span>22</span>\n<span>23</span>\n<span>24</span>\n</pre></div><pre class=\"rust\"><code>    <span class=\"kw\">async fn </span>process(<span class=\"kw-2\">&amp;</span><span class=\"self\">self</span>, _config: Config, _input: CmpInOut&lt;TMsg&gt;) -&gt; <span class=\"prelude-ty\">Result</span>&lt;(), ComponentError&gt; <span class=\"highlight focus\">{\n        <span class=\"kw\">loop </span>{\n            <span class=\"macro\">info!</span>(<span class=\"string\">\"Component 1\"</span>);\n            sleep(Duration::from_secs(<span class=\"number\">2</span>)).<span class=\"kw\">await</span>;\n        }\n    }</span></code></pre></div></div></div><div class=\"scraped-example expanded\" data-locs=\"[[[0,5],&quot;src/executor_single_thread/example_component2.rs.html#19-24&quot;,&quot;lines 19-24&quot;]]\"><div class=\"scraped-example-title\">examples/executor/executor-single-thread/example_component2.rs (<a href=\"src/executor_single_thread/example_component2.rs.html#19-24\">lines 19-24</a>)</div><div class=\"code-wrapper\"><div class=\"example-wrap\"><div data-nosnippet><pre class=\"src-line-numbers\"><span>19</span>\n<span>20</span>\n<span>21</span>\n<span>22</span>\n<span>23</span>\n<span>24</span>\n</pre></div><pre class=\"rust\"><code>    <span class=\"kw\">async fn </span>process(<span class=\"kw-2\">&amp;</span><span class=\"self\">self</span>, _config: Config, _input: CmpInOut&lt;TMsg&gt;) -&gt; <span class=\"prelude-ty\">Result</span>&lt;(), ComponentError&gt; <span class=\"highlight focus\">{\n        <span class=\"kw\">loop </span>{\n            <span class=\"macro\">info!</span>(<span class=\"string\">\"Component 2\"</span>);\n            sleep(Duration::from_secs(<span class=\"number\">2</span>)).<span class=\"kw\">await</span>;\n        }\n    }</span></code></pre></div></div></div></div></details></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.try_new\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">try_new</a>(x: T) -&gt; Result&lt;Box&lt;T&gt;, AllocError&gt;</h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>allocator_api</code>)</span></div></span></summary><div class=\"docblock\"><p>Allocates memory on the heap then places <code>x</code> into it,\nreturning an error if the allocation fails</p>\n<p>This doesnâ€™t actually allocate if <code>T</code> is zero-sized.</p>\n<h5 id=\"examples-3\"><a class=\"doc-anchor\" href=\"#examples-3\">Â§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(allocator_api)]\n\n</span><span class=\"kw\">let </span>five = Box::try_new(<span class=\"number\">5</span>)<span class=\"question-mark\">?</span>;</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.try_new_uninit\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">try_new_uninit</a>() -&gt; Result&lt;Box&lt;MaybeUninit&lt;T&gt;&gt;, AllocError&gt;</h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>allocator_api</code>)</span></div></span></summary><div class=\"docblock\"><p>Constructs a new box with uninitialized contents on the heap,\nreturning an error if the allocation fails</p>\n<h5 id=\"examples-4\"><a class=\"doc-anchor\" href=\"#examples-4\">Â§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(allocator_api, new_uninit)]\n\n</span><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>five = Box::&lt;u32&gt;::try_new_uninit()<span class=\"question-mark\">?</span>;\n\n<span class=\"kw\">let </span>five = <span class=\"kw\">unsafe </span>{\n    <span class=\"comment\">// Deferred initialization:\n    </span>five.as_mut_ptr().write(<span class=\"number\">5</span>);\n\n    five.assume_init()\n};\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"kw-2\">*</span>five, <span class=\"number\">5</span>);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.try_new_zeroed\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">try_new_zeroed</a>() -&gt; Result&lt;Box&lt;MaybeUninit&lt;T&gt;&gt;, AllocError&gt;</h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>allocator_api</code>)</span></div></span></summary><div class=\"docblock\"><p>Constructs a new <code>Box</code> with uninitialized contents, with the memory\nbeing filled with <code>0</code> bytes on the heap</p>\n<p>See <a href=\"mem::MaybeUninit::zeroed\"><code>MaybeUninit::zeroed</code></a> for examples of correct and incorrect usage\nof this method.</p>\n<h5 id=\"examples-5\"><a class=\"doc-anchor\" href=\"#examples-5\">Â§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(allocator_api, new_uninit)]\n\n</span><span class=\"kw\">let </span>zero = Box::&lt;u32&gt;::try_new_zeroed()<span class=\"question-mark\">?</span>;\n<span class=\"kw\">let </span>zero = <span class=\"kw\">unsafe </span>{ zero.assume_init() };\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"kw-2\">*</span>zero, <span class=\"number\">0</span>);</code></pre></div>\n</div></details></div></details>",0,"rsiot::components::cmp_external_fn_process::FnProcess"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Box%3CT,+A%3E\" class=\"impl\"><a href=\"#impl-Box%3CT,+A%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T, A&gt; Box&lt;T, A&gt;<div class=\"where\">where\n    A: Allocator,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.new_in\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">new_in</a>(x: T, alloc: A) -&gt; Box&lt;T, A&gt;<div class=\"where\">where\n    A: Allocator,</div></h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>allocator_api</code>)</span></div></span></summary><div class=\"docblock\"><p>Allocates memory in the given allocator then places <code>x</code> into it.</p>\n<p>This doesnâ€™t actually allocate if <code>T</code> is zero-sized.</p>\n<h5 id=\"examples\"><a class=\"doc-anchor\" href=\"#examples\">Â§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(allocator_api)]\n\n</span><span class=\"kw\">use </span>std::alloc::System;\n\n<span class=\"kw\">let </span>five = Box::new_in(<span class=\"number\">5</span>, System);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.try_new_in\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">try_new_in</a>(x: T, alloc: A) -&gt; Result&lt;Box&lt;T, A&gt;, AllocError&gt;<div class=\"where\">where\n    A: Allocator,</div></h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>allocator_api</code>)</span></div></span></summary><div class=\"docblock\"><p>Allocates memory in the given allocator then places <code>x</code> into it,\nreturning an error if the allocation fails</p>\n<p>This doesnâ€™t actually allocate if <code>T</code> is zero-sized.</p>\n<h5 id=\"examples-1\"><a class=\"doc-anchor\" href=\"#examples-1\">Â§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(allocator_api)]\n\n</span><span class=\"kw\">use </span>std::alloc::System;\n\n<span class=\"kw\">let </span>five = Box::try_new_in(<span class=\"number\">5</span>, System)<span class=\"question-mark\">?</span>;</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.new_uninit_in\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">new_uninit_in</a>(alloc: A) -&gt; Box&lt;MaybeUninit&lt;T&gt;, A&gt;<div class=\"where\">where\n    A: Allocator,</div></h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>allocator_api</code>)</span></div></span></summary><div class=\"docblock\"><p>Constructs a new box with uninitialized contents in the provided allocator.</p>\n<h5 id=\"examples-2\"><a class=\"doc-anchor\" href=\"#examples-2\">Â§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(allocator_api, new_uninit)]\n\n</span><span class=\"kw\">use </span>std::alloc::System;\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>five = Box::&lt;u32, <span class=\"kw\">_</span>&gt;::new_uninit_in(System);\n\n<span class=\"kw\">let </span>five = <span class=\"kw\">unsafe </span>{\n    <span class=\"comment\">// Deferred initialization:\n    </span>five.as_mut_ptr().write(<span class=\"number\">5</span>);\n\n    five.assume_init()\n};\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"kw-2\">*</span>five, <span class=\"number\">5</span>)</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.try_new_uninit_in\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">try_new_uninit_in</a>(alloc: A) -&gt; Result&lt;Box&lt;MaybeUninit&lt;T&gt;, A&gt;, AllocError&gt;<div class=\"where\">where\n    A: Allocator,</div></h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>allocator_api</code>)</span></div></span></summary><div class=\"docblock\"><p>Constructs a new box with uninitialized contents in the provided allocator,\nreturning an error if the allocation fails</p>\n<h5 id=\"examples-3\"><a class=\"doc-anchor\" href=\"#examples-3\">Â§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(allocator_api, new_uninit)]\n\n</span><span class=\"kw\">use </span>std::alloc::System;\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>five = Box::&lt;u32, <span class=\"kw\">_</span>&gt;::try_new_uninit_in(System)<span class=\"question-mark\">?</span>;\n\n<span class=\"kw\">let </span>five = <span class=\"kw\">unsafe </span>{\n    <span class=\"comment\">// Deferred initialization:\n    </span>five.as_mut_ptr().write(<span class=\"number\">5</span>);\n\n    five.assume_init()\n};\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"kw-2\">*</span>five, <span class=\"number\">5</span>);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.new_zeroed_in\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">new_zeroed_in</a>(alloc: A) -&gt; Box&lt;MaybeUninit&lt;T&gt;, A&gt;<div class=\"where\">where\n    A: Allocator,</div></h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>allocator_api</code>)</span></div></span></summary><div class=\"docblock\"><p>Constructs a new <code>Box</code> with uninitialized contents, with the memory\nbeing filled with <code>0</code> bytes in the provided allocator.</p>\n<p>See <a href=\"mem::MaybeUninit::zeroed\"><code>MaybeUninit::zeroed</code></a> for examples of correct and incorrect usage\nof this method.</p>\n<h5 id=\"examples-4\"><a class=\"doc-anchor\" href=\"#examples-4\">Â§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(allocator_api, new_uninit)]\n\n</span><span class=\"kw\">use </span>std::alloc::System;\n\n<span class=\"kw\">let </span>zero = Box::&lt;u32, <span class=\"kw\">_</span>&gt;::new_zeroed_in(System);\n<span class=\"kw\">let </span>zero = <span class=\"kw\">unsafe </span>{ zero.assume_init() };\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"kw-2\">*</span>zero, <span class=\"number\">0</span>)</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.try_new_zeroed_in\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">try_new_zeroed_in</a>(alloc: A) -&gt; Result&lt;Box&lt;MaybeUninit&lt;T&gt;, A&gt;, AllocError&gt;<div class=\"where\">where\n    A: Allocator,</div></h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>allocator_api</code>)</span></div></span></summary><div class=\"docblock\"><p>Constructs a new <code>Box</code> with uninitialized contents, with the memory\nbeing filled with <code>0</code> bytes in the provided allocator,\nreturning an error if the allocation fails,</p>\n<p>See <a href=\"mem::MaybeUninit::zeroed\"><code>MaybeUninit::zeroed</code></a> for examples of correct and incorrect usage\nof this method.</p>\n<h5 id=\"examples-5\"><a class=\"doc-anchor\" href=\"#examples-5\">Â§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(allocator_api, new_uninit)]\n\n</span><span class=\"kw\">use </span>std::alloc::System;\n\n<span class=\"kw\">let </span>zero = Box::&lt;u32, <span class=\"kw\">_</span>&gt;::try_new_zeroed_in(System)<span class=\"question-mark\">?</span>;\n<span class=\"kw\">let </span>zero = <span class=\"kw\">unsafe </span>{ zero.assume_init() };\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"kw-2\">*</span>zero, <span class=\"number\">0</span>);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.pin_in\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">pin_in</a>(x: T, alloc: A) -&gt; Pin&lt;Box&lt;T, A&gt;&gt;<div class=\"where\">where\n    A: 'static + Allocator,</div></h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>allocator_api</code>)</span></div></span></summary><div class=\"docblock\"><p>Constructs a new <code>Pin&lt;Box&lt;T, A&gt;&gt;</code>. If <code>T</code> does not implement [<code>Unpin</code>], then\n<code>x</code> will be pinned in memory and unable to be moved.</p>\n<p>Constructing and pinning of the <code>Box</code> can also be done in two steps: <code>Box::pin_in(x, alloc)</code>\ndoes the same as <code>[Box::into_pin]([Box::new_in](x, alloc))</code>. Consider using\n<a href=\"Box::into_pin\"><code>into_pin</code></a> if you already have a <code>Box&lt;T, A&gt;</code>, or if you want to\nconstruct a (pinned) <code>Box</code> in a different way than with [<code>Box::new_in</code>].</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.into_boxed_slice\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">into_boxed_slice</a>(boxed: Box&lt;T, A&gt;) -&gt; Box&lt;[T], A&gt;</h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>box_into_boxed_slice</code>)</span></div></span></summary><div class=\"docblock\"><p>Converts a <code>Box&lt;T&gt;</code> into a <code>Box&lt;[T]&gt;</code></p>\n<p>This conversion does not allocate on the heap and happens in place.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.into_inner\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">into_inner</a>(boxed: Box&lt;T, A&gt;) -&gt; T</h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>box_into_inner</code>)</span></div></span></summary><div class=\"docblock\"><p>Consumes the <code>Box</code>, returning the wrapped value.</p>\n<h5 id=\"examples-6\"><a class=\"doc-anchor\" href=\"#examples-6\">Â§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(box_into_inner)]\n\n</span><span class=\"kw\">let </span>c = Box::new(<span class=\"number\">5</span>);\n\n<span class=\"macro\">assert_eq!</span>(Box::into_inner(c), <span class=\"number\">5</span>);</code></pre></div>\n</div></details></div></details>",0,"rsiot::components::cmp_external_fn_process::FnProcess"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Box%3CT%3E\" class=\"impl\"><a href=\"#impl-Box%3CT%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T&gt; Box&lt;T&gt;<div class=\"where\">where\n    T: ?Sized,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.from_raw\" class=\"method\"><span class=\"since rightside\" title=\"Stable since Rust version 1.4.0\">1.4.0</span><h4 class=\"code-header\">pub unsafe fn <a class=\"fn\">from_raw</a>(raw: *mut T) -&gt; Box&lt;T&gt;</h4></section></summary><div class=\"docblock\"><p>Constructs a box from a raw pointer.</p>\n<p>After calling this function, the raw pointer is owned by the\nresulting <code>Box</code>. Specifically, the <code>Box</code> destructor will call\nthe destructor of <code>T</code> and free the allocated memory. For this\nto be safe, the memory must have been allocated in accordance\nwith the <a href=\"self#memory-layout\">memory layout</a> used by <code>Box</code> .</p>\n<h5 id=\"safety\"><a class=\"doc-anchor\" href=\"#safety\">Â§</a>Safety</h5>\n<p>This function is unsafe because improper use may lead to\nmemory problems. For example, a double-free may occur if the\nfunction is called twice on the same raw pointer.</p>\n<p>The safety conditions are described in the <a href=\"self#memory-layout\">memory layout</a> section.</p>\n<h5 id=\"examples\"><a class=\"doc-anchor\" href=\"#examples\">Â§</a>Examples</h5>\n<p>Recreate a <code>Box</code> which was previously converted to a raw pointer\nusing [<code>Box::into_raw</code>]:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>x = Box::new(<span class=\"number\">5</span>);\n<span class=\"kw\">let </span>ptr = Box::into_raw(x);\n<span class=\"kw\">let </span>x = <span class=\"kw\">unsafe </span>{ Box::from_raw(ptr) };</code></pre></div>\n<p>Manually create a <code>Box</code> from scratch by using the global allocator:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::alloc::{alloc, Layout};\n\n<span class=\"kw\">unsafe </span>{\n    <span class=\"kw\">let </span>ptr = alloc(Layout::new::&lt;i32&gt;()) <span class=\"kw\">as </span><span class=\"kw-2\">*mut </span>i32;\n    <span class=\"comment\">// In general .write is required to avoid attempting to destruct\n    // the (uninitialized) previous contents of `ptr`, though for this\n    // simple example `*ptr = 5` would have worked as well.\n    </span>ptr.write(<span class=\"number\">5</span>);\n    <span class=\"kw\">let </span>x = Box::from_raw(ptr);\n}</code></pre></div>\n</div></details></div></details>",0,"rsiot::components::cmp_external_fn_process::FnProcess"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Box%3CT,+A%3E\" class=\"impl\"><a href=\"#impl-Box%3CT,+A%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T, A&gt; Box&lt;T, A&gt;<div class=\"where\">where\n    A: Allocator,\n    T: ?Sized,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.from_raw_in\" class=\"method\"><span class=\"since rightside\" title=\"const unstable\">const: <a href=\"https://github.com/rust-lang/rust/issues/92521\" title=\"Tracking issue for const_box\">unstable</a></span><h4 class=\"code-header\">pub unsafe fn <a class=\"fn\">from_raw_in</a>(raw: *mut T, alloc: A) -&gt; Box&lt;T, A&gt;</h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>allocator_api</code>)</span></div></span></summary><div class=\"docblock\"><p>Constructs a box from a raw pointer in the given allocator.</p>\n<p>After calling this function, the raw pointer is owned by the\nresulting <code>Box</code>. Specifically, the <code>Box</code> destructor will call\nthe destructor of <code>T</code> and free the allocated memory. For this\nto be safe, the memory must have been allocated in accordance\nwith the <a href=\"self#memory-layout\">memory layout</a> used by <code>Box</code> .</p>\n<h5 id=\"safety\"><a class=\"doc-anchor\" href=\"#safety\">Â§</a>Safety</h5>\n<p>This function is unsafe because improper use may lead to\nmemory problems. For example, a double-free may occur if the\nfunction is called twice on the same raw pointer.</p>\n<h5 id=\"examples\"><a class=\"doc-anchor\" href=\"#examples\">Â§</a>Examples</h5>\n<p>Recreate a <code>Box</code> which was previously converted to a raw pointer\nusing [<code>Box::into_raw_with_allocator</code>]:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(allocator_api)]\n\n</span><span class=\"kw\">use </span>std::alloc::System;\n\n<span class=\"kw\">let </span>x = Box::new_in(<span class=\"number\">5</span>, System);\n<span class=\"kw\">let </span>(ptr, alloc) = Box::into_raw_with_allocator(x);\n<span class=\"kw\">let </span>x = <span class=\"kw\">unsafe </span>{ Box::from_raw_in(ptr, alloc) };</code></pre></div>\n<p>Manually create a <code>Box</code> from scratch by using the system allocator:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(allocator_api, slice_ptr_get)]\n\n</span><span class=\"kw\">use </span>std::alloc::{Allocator, Layout, System};\n\n<span class=\"kw\">unsafe </span>{\n    <span class=\"kw\">let </span>ptr = System.allocate(Layout::new::&lt;i32&gt;())<span class=\"question-mark\">?</span>.as_mut_ptr() <span class=\"kw\">as </span><span class=\"kw-2\">*mut </span>i32;\n    <span class=\"comment\">// In general .write is required to avoid attempting to destruct\n    // the (uninitialized) previous contents of `ptr`, though for this\n    // simple example `*ptr = 5` would have worked as well.\n    </span>ptr.write(<span class=\"number\">5</span>);\n    <span class=\"kw\">let </span>x = Box::from_raw_in(ptr, System);\n}</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.into_raw\" class=\"method\"><span class=\"since rightside\" title=\"Stable since Rust version 1.4.0\">1.4.0</span><h4 class=\"code-header\">pub fn <a class=\"fn\">into_raw</a>(b: Box&lt;T, A&gt;) -&gt; *mut T</h4></section></summary><div class=\"docblock\"><p>Consumes the <code>Box</code>, returning a wrapped raw pointer.</p>\n<p>The pointer will be properly aligned and non-null.</p>\n<p>After calling this function, the caller is responsible for the\nmemory previously managed by the <code>Box</code>. In particular, the\ncaller should properly destroy <code>T</code> and release the memory, taking\ninto account the <a href=\"self#memory-layout\">memory layout</a> used by <code>Box</code>. The easiest way to\ndo this is to convert the raw pointer back into a <code>Box</code> with the\n[<code>Box::from_raw</code>] function, allowing the <code>Box</code> destructor to perform\nthe cleanup.</p>\n<p>Note: this is an associated function, which means that you have\nto call it as <code>Box::into_raw(b)</code> instead of <code>b.into_raw()</code>. This\nis so that there is no conflict with a method on the inner type.</p>\n<h5 id=\"examples-1\"><a class=\"doc-anchor\" href=\"#examples-1\">Â§</a>Examples</h5>\n<p>Converting the raw pointer back into a <code>Box</code> with [<code>Box::from_raw</code>]\nfor automatic cleanup:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>x = Box::new(String::from(<span class=\"string\">\"Hello\"</span>));\n<span class=\"kw\">let </span>ptr = Box::into_raw(x);\n<span class=\"kw\">let </span>x = <span class=\"kw\">unsafe </span>{ Box::from_raw(ptr) };</code></pre></div>\n<p>Manual cleanup by explicitly running the destructor and deallocating\nthe memory:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::alloc::{dealloc, Layout};\n<span class=\"kw\">use </span>std::ptr;\n\n<span class=\"kw\">let </span>x = Box::new(String::from(<span class=\"string\">\"Hello\"</span>));\n<span class=\"kw\">let </span>ptr = Box::into_raw(x);\n<span class=\"kw\">unsafe </span>{\n    ptr::drop_in_place(ptr);\n    dealloc(ptr <span class=\"kw\">as </span><span class=\"kw-2\">*mut </span>u8, Layout::new::&lt;String&gt;());\n}</code></pre></div>\n<p>Note: This is equivalent to the following:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>x = Box::new(String::from(<span class=\"string\">\"Hello\"</span>));\n<span class=\"kw\">let </span>ptr = Box::into_raw(x);\n<span class=\"kw\">unsafe </span>{\n    drop(Box::from_raw(ptr));\n}</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.into_raw_with_allocator\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">into_raw_with_allocator</a>(b: Box&lt;T, A&gt;) -&gt; (*mut T, A)</h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>allocator_api</code>)</span></div></span></summary><div class=\"docblock\"><p>Consumes the <code>Box</code>, returning a wrapped raw pointer and the allocator.</p>\n<p>The pointer will be properly aligned and non-null.</p>\n<p>After calling this function, the caller is responsible for the\nmemory previously managed by the <code>Box</code>. In particular, the\ncaller should properly destroy <code>T</code> and release the memory, taking\ninto account the <a href=\"self#memory-layout\">memory layout</a> used by <code>Box</code>. The easiest way to\ndo this is to convert the raw pointer back into a <code>Box</code> with the\n[<code>Box::from_raw_in</code>] function, allowing the <code>Box</code> destructor to perform\nthe cleanup.</p>\n<p>Note: this is an associated function, which means that you have\nto call it as <code>Box::into_raw_with_allocator(b)</code> instead of <code>b.into_raw_with_allocator()</code>. This\nis so that there is no conflict with a method on the inner type.</p>\n<h5 id=\"examples-2\"><a class=\"doc-anchor\" href=\"#examples-2\">Â§</a>Examples</h5>\n<p>Converting the raw pointer back into a <code>Box</code> with [<code>Box::from_raw_in</code>]\nfor automatic cleanup:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(allocator_api)]\n\n</span><span class=\"kw\">use </span>std::alloc::System;\n\n<span class=\"kw\">let </span>x = Box::new_in(String::from(<span class=\"string\">\"Hello\"</span>), System);\n<span class=\"kw\">let </span>(ptr, alloc) = Box::into_raw_with_allocator(x);\n<span class=\"kw\">let </span>x = <span class=\"kw\">unsafe </span>{ Box::from_raw_in(ptr, alloc) };</code></pre></div>\n<p>Manual cleanup by explicitly running the destructor and deallocating\nthe memory:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(allocator_api)]\n\n</span><span class=\"kw\">use </span>std::alloc::{Allocator, Layout, System};\n<span class=\"kw\">use </span>std::ptr::{<span class=\"self\">self</span>, NonNull};\n\n<span class=\"kw\">let </span>x = Box::new_in(String::from(<span class=\"string\">\"Hello\"</span>), System);\n<span class=\"kw\">let </span>(ptr, alloc) = Box::into_raw_with_allocator(x);\n<span class=\"kw\">unsafe </span>{\n    ptr::drop_in_place(ptr);\n    <span class=\"kw\">let </span>non_null = NonNull::new_unchecked(ptr);\n    alloc.deallocate(non_null.cast(), Layout::new::&lt;String&gt;());\n}</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.allocator\" class=\"method\"><span class=\"since rightside\" title=\"const unstable\">const: <a href=\"https://github.com/rust-lang/rust/issues/92521\" title=\"Tracking issue for const_box\">unstable</a></span><h4 class=\"code-header\">pub fn <a class=\"fn\">allocator</a>(b: &amp;Box&lt;T, A&gt;) -&gt; &amp;A</h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>allocator_api</code>)</span></div></span></summary><div class=\"docblock\"><p>Returns a reference to the underlying allocator.</p>\n<p>Note: this is an associated function, which means that you have\nto call it as <code>Box::allocator(&amp;b)</code> instead of <code>b.allocator()</code>. This\nis so that there is no conflict with a method on the inner type.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.leak\" class=\"method\"><span class=\"since rightside\" title=\"Stable since Rust version 1.26.0\">1.26.0</span><h4 class=\"code-header\">pub fn <a class=\"fn\">leak</a>&lt;'a&gt;(b: Box&lt;T, A&gt;) -&gt; &amp;'a mut T<div class=\"where\">where\n    A: 'a,</div></h4></section></summary><div class=\"docblock\"><p>Consumes and leaks the <code>Box</code>, returning a mutable reference,\n<code>&amp;'a mut T</code>. Note that the type <code>T</code> must outlive the chosen lifetime\n<code>'a</code>. If the type has only static references, or none at all, then this\nmay be chosen to be <code>'static</code>.</p>\n<p>This function is mainly useful for data that lives for the remainder of\nthe programâ€™s life. Dropping the returned reference will cause a memory\nleak. If this is not acceptable, the reference should first be wrapped\nwith the [<code>Box::from_raw</code>] function producing a <code>Box</code>. This <code>Box</code> can\nthen be dropped which will properly destroy <code>T</code> and release the\nallocated memory.</p>\n<p>Note: this is an associated function, which means that you have\nto call it as <code>Box::leak(b)</code> instead of <code>b.leak()</code>. This\nis so that there is no conflict with a method on the inner type.</p>\n<h5 id=\"examples-3\"><a class=\"doc-anchor\" href=\"#examples-3\">Â§</a>Examples</h5>\n<p>Simple usage:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>x = Box::new(<span class=\"number\">41</span>);\n<span class=\"kw\">let </span>static_ref: <span class=\"kw-2\">&amp;</span><span class=\"lifetime\">'static </span><span class=\"kw-2\">mut </span>usize = Box::leak(x);\n<span class=\"kw-2\">*</span>static_ref += <span class=\"number\">1</span>;\n<span class=\"macro\">assert_eq!</span>(<span class=\"kw-2\">*</span>static_ref, <span class=\"number\">42</span>);</code></pre></div>\n<p>Unsized data:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>x = <span class=\"macro\">vec!</span>[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>].into_boxed_slice();\n<span class=\"kw\">let </span>static_ref = Box::leak(x);\nstatic_ref[<span class=\"number\">0</span>] = <span class=\"number\">4</span>;\n<span class=\"macro\">assert_eq!</span>(<span class=\"kw-2\">*</span>static_ref, [<span class=\"number\">4</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.into_pin\" class=\"method\"><span class=\"since rightside\" title=\"Stable since Rust version 1.63.0, const unstable\">1.63.0 (const: <a href=\"https://github.com/rust-lang/rust/issues/92521\" title=\"Tracking issue for const_box\">unstable</a>)</span><h4 class=\"code-header\">pub fn <a class=\"fn\">into_pin</a>(boxed: Box&lt;T, A&gt;) -&gt; Pin&lt;Box&lt;T, A&gt;&gt;<div class=\"where\">where\n    A: 'static,</div></h4></section></summary><div class=\"docblock\"><p>Converts a <code>Box&lt;T&gt;</code> into a <code>Pin&lt;Box&lt;T&gt;&gt;</code>. If <code>T</code> does not implement [<code>Unpin</code>], then\n<code>*boxed</code> will be pinned in memory and unable to be moved.</p>\n<p>This conversion does not allocate on the heap and happens in place.</p>\n<p>This is also available via [<code>From</code>].</p>\n<p>Constructing and pinning a <code>Box</code> with <code>Box::into_pin([Box::new](x))</code>\ncan also be written more concisely using <code>[Box::pin](x)</code>.\nThis <code>into_pin</code> method is useful if you already have a <code>Box&lt;T&gt;</code>, or you are\nconstructing a (pinned) <code>Box</code> in a different way than with [<code>Box::new</code>].</p>\n<h5 id=\"notes\"><a class=\"doc-anchor\" href=\"#notes\">Â§</a>Notes</h5>\n<p>Itâ€™s not recommended that crates add an impl like <code>From&lt;Box&lt;T&gt;&gt; for Pin&lt;T&gt;</code>,\nas itâ€™ll introduce an ambiguity when calling <code>Pin::from</code>.\nA demonstration of such a poor impl is shown below.</p>\n\n<div class=\"example-wrap compile_fail\"><a href=\"#\" class=\"tooltip\" title=\"This example deliberately fails to compile\">â“˜</a><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">struct </span>Foo; <span class=\"comment\">// A type defined in this crate.\n</span><span class=\"kw\">impl </span>From&lt;Box&lt;()&gt;&gt; <span class=\"kw\">for </span>Pin&lt;Foo&gt; {\n    <span class=\"kw\">fn </span>from(<span class=\"kw\">_</span>: Box&lt;()&gt;) -&gt; Pin&lt;Foo&gt; {\n        Pin::new(Foo)\n    }\n}\n\n<span class=\"kw\">let </span>foo = Box::new(());\n<span class=\"kw\">let </span>bar = Pin::from(foo);</code></pre></div>\n</div></details></div></details>",0,"rsiot::components::cmp_external_fn_process::FnProcess"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-AsFd-for-Box%3CT%3E\" class=\"impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.64.0\">1.64.0</span><a href=\"#impl-AsFd-for-Box%3CT%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T&gt; AsFd for Box&lt;T&gt;<div class=\"where\">where\n    T: AsFd,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.as_fd\" class=\"method trait-impl\"><a href=\"#method.as_fd\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">as_fd</a>(&amp;self) -&gt; BorrowedFd&lt;'_&gt;</h4></section></summary><div class='docblock'>Borrows the file descriptor. <a>Read more</a></div></details></div></details>","AsFd","rsiot::components::cmp_external_fn_process::FnProcess"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-BufRead-for-Box%3CB%3E\" class=\"impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.0.0\">1.0.0</span><a href=\"#impl-BufRead-for-Box%3CB%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;B&gt; BufRead for Box&lt;B&gt;<div class=\"where\">where\n    B: BufRead + ?Sized,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.fill_buf\" class=\"method trait-impl\"><a href=\"#method.fill_buf\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">fill_buf</a>(&amp;mut self) -&gt; Result&lt;&amp;[u8], Error&gt;</h4></section></summary><div class='docblock'>Returns the contents of the internal buffer, filling it with more data\nfrom the inner reader if it is empty. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.consume\" class=\"method trait-impl\"><a href=\"#method.consume\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">consume</a>(&amp;mut self, amt: usize)</h4></section></summary><div class='docblock'>Tells this buffer that <code>amt</code> bytes have been consumed from the buffer,\nso they should no longer be returned in calls to <code>read</code>. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.read_until\" class=\"method trait-impl\"><a href=\"#method.read_until\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">read_until</a>(&amp;mut self, byte: u8, buf: &amp;mut Vec&lt;u8&gt;) -&gt; Result&lt;usize, Error&gt;</h4></section></summary><div class='docblock'>Read all bytes into <code>buf</code> until the delimiter <code>byte</code> or EOF is reached. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.read_line\" class=\"method trait-impl\"><a href=\"#method.read_line\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">read_line</a>(&amp;mut self, buf: &amp;mut String) -&gt; Result&lt;usize, Error&gt;</h4></section></summary><div class='docblock'>Read all bytes until a newline (the <code>0xA</code> byte) is reached, and append\nthem to the provided <code>String</code> buffer. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.has_data_left\" class=\"method trait-impl\"><a href=\"#method.has_data_left\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">has_data_left</a>(&amp;mut self) -&gt; Result&lt;bool, Error&gt;</h4></section></summary><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>buf_read_has_data_left</code>)</span></div></span><div class='docblock'>Check if the underlying <code>Read</code> has any data left to be read. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.skip_until\" class=\"method trait-impl\"><a href=\"#method.skip_until\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">skip_until</a>(&amp;mut self, byte: u8) -&gt; Result&lt;usize, Error&gt;</h4></section></summary><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>bufread_skip_until</code>)</span></div></span><div class='docblock'>Skip all bytes until the delimiter <code>byte</code> or EOF is reached. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.split\" class=\"method trait-impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.0.0\">1.0.0</span><a href=\"#method.split\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">split</a>(self, byte: u8) -&gt; Split&lt;Self&gt;<div class=\"where\">where\n    Self: Sized,</div></h4></section></summary><div class='docblock'>Returns an iterator over the contents of this reader split on the byte\n<code>byte</code>. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.lines\" class=\"method trait-impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.0.0\">1.0.0</span><a href=\"#method.lines\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">lines</a>(self) -&gt; Lines&lt;Self&gt;<div class=\"where\">where\n    Self: Sized,</div></h4></section></summary><div class='docblock'>Returns an iterator over the lines of this reader. <a>Read more</a></div></details></div></details>","BufRead","rsiot::components::cmp_external_fn_process::FnProcess"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Read-for-Box%3CR%3E\" class=\"impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.0.0\">1.0.0</span><a href=\"#impl-Read-for-Box%3CR%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;R&gt; Read for Box&lt;R&gt;<div class=\"where\">where\n    R: Read + ?Sized,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.read\" class=\"method trait-impl\"><a href=\"#method.read\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">read</a>(&amp;mut self, buf: &amp;mut [u8]) -&gt; Result&lt;usize, Error&gt;</h4></section></summary><div class='docblock'>Pull some bytes from this source into the specified buffer, returning\nhow many bytes were read. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.read_buf\" class=\"method trait-impl\"><a href=\"#method.read_buf\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">read_buf</a>(&amp;mut self, cursor: BorrowedCursor&lt;'_&gt;) -&gt; Result&lt;(), Error&gt;</h4></section></summary><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>read_buf</code>)</span></div></span><div class='docblock'>Pull some bytes from this source into the specified buffer. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.read_vectored\" class=\"method trait-impl\"><a href=\"#method.read_vectored\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">read_vectored</a>(&amp;mut self, bufs: &amp;mut [IoSliceMut&lt;'_&gt;]) -&gt; Result&lt;usize, Error&gt;</h4></section></summary><div class='docblock'>Like <code>read</code>, except that it reads into a slice of buffers. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.is_read_vectored\" class=\"method trait-impl\"><a href=\"#method.is_read_vectored\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">is_read_vectored</a>(&amp;self) -&gt; bool</h4></section></summary><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>can_vector</code>)</span></div></span><div class='docblock'>Determines if this <code>Read</code>er has an efficient <code>read_vectored</code>\nimplementation. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.read_to_end\" class=\"method trait-impl\"><a href=\"#method.read_to_end\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">read_to_end</a>(&amp;mut self, buf: &amp;mut Vec&lt;u8&gt;) -&gt; Result&lt;usize, Error&gt;</h4></section></summary><div class='docblock'>Read all bytes until EOF in this source, placing them into <code>buf</code>. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.read_to_string\" class=\"method trait-impl\"><a href=\"#method.read_to_string\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">read_to_string</a>(&amp;mut self, buf: &amp;mut String) -&gt; Result&lt;usize, Error&gt;</h4></section></summary><div class='docblock'>Read all bytes until EOF in this source, appending them to <code>buf</code>. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.read_exact\" class=\"method trait-impl\"><a href=\"#method.read_exact\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">read_exact</a>(&amp;mut self, buf: &amp;mut [u8]) -&gt; Result&lt;(), Error&gt;</h4></section></summary><div class='docblock'>Read the exact number of bytes required to fill <code>buf</code>. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.read_buf_exact\" class=\"method trait-impl\"><a href=\"#method.read_buf_exact\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">read_buf_exact</a>(&amp;mut self, cursor: BorrowedCursor&lt;'_&gt;) -&gt; Result&lt;(), Error&gt;</h4></section></summary><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>read_buf</code>)</span></div></span><div class='docblock'>Read the exact number of bytes required to fill <code>cursor</code>. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.by_ref\" class=\"method trait-impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.0.0\">1.0.0</span><a href=\"#method.by_ref\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">by_ref</a>(&amp;mut self) -&gt; &amp;mut Self<div class=\"where\">where\n    Self: Sized,</div></h4></section></summary><div class='docblock'>Creates a â€œby referenceâ€ adaptor for this instance of <code>Read</code>. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.bytes\" class=\"method trait-impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.0.0\">1.0.0</span><a href=\"#method.bytes\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">bytes</a>(self) -&gt; Bytes&lt;Self&gt;<div class=\"where\">where\n    Self: Sized,</div></h4></section></summary><div class='docblock'>Transforms this <code>Read</code> instance to an [<code>Iterator</code>] over its bytes. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.chain\" class=\"method trait-impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.0.0\">1.0.0</span><a href=\"#method.chain\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">chain</a>&lt;R&gt;(self, next: R) -&gt; Chain&lt;Self, R&gt;<div class=\"where\">where\n    R: Read,\n    Self: Sized,</div></h4></section></summary><div class='docblock'>Creates an adapter which will chain this stream with another. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.take\" class=\"method trait-impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.0.0\">1.0.0</span><a href=\"#method.take\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">take</a>(self, limit: u64) -&gt; Take&lt;Self&gt;<div class=\"where\">where\n    Self: Sized,</div></h4></section></summary><div class='docblock'>Creates an adapter which will read at most <code>limit</code> bytes from it. <a>Read more</a></div></details></div></details>","Read","rsiot::components::cmp_external_fn_process::FnProcess"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Seek-for-Box%3CS%3E\" class=\"impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.0.0\">1.0.0</span><a href=\"#impl-Seek-for-Box%3CS%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;S&gt; Seek for Box&lt;S&gt;<div class=\"where\">where\n    S: Seek + ?Sized,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.seek\" class=\"method trait-impl\"><a href=\"#method.seek\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">seek</a>(&amp;mut self, pos: SeekFrom) -&gt; Result&lt;u64, Error&gt;</h4></section></summary><div class='docblock'>Seek to an offset, in bytes, in a stream. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.stream_position\" class=\"method trait-impl\"><a href=\"#method.stream_position\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">stream_position</a>(&amp;mut self) -&gt; Result&lt;u64, Error&gt;</h4></section></summary><div class='docblock'>Returns the current seek position from the start of the stream. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.rewind\" class=\"method trait-impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.55.0\">1.55.0</span><a href=\"#method.rewind\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">rewind</a>(&amp;mut self) -&gt; Result&lt;(), Error&gt;</h4></section></summary><div class='docblock'>Rewind to the beginning of a stream. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.stream_len\" class=\"method trait-impl\"><a href=\"#method.stream_len\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">stream_len</a>(&amp;mut self) -&gt; Result&lt;u64, Error&gt;</h4></section></summary><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>seek_stream_len</code>)</span></div></span><div class='docblock'>Returns the length of this stream (in bytes). <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.seek_relative\" class=\"method trait-impl\"><a href=\"#method.seek_relative\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">seek_relative</a>(&amp;mut self, offset: i64) -&gt; Result&lt;(), Error&gt;</h4></section></summary><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>seek_seek_relative</code>)</span></div></span><div class='docblock'>Seeks relative to the current position. <a>Read more</a></div></details></div></details>","Seek","rsiot::components::cmp_external_fn_process::FnProcess"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Write-for-Box%3CW%3E\" class=\"impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.0.0\">1.0.0</span><a href=\"#impl-Write-for-Box%3CW%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;W&gt; Write for Box&lt;W&gt;<div class=\"where\">where\n    W: Write + ?Sized,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.write\" class=\"method trait-impl\"><a href=\"#method.write\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">write</a>(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;usize, Error&gt;</h4></section></summary><div class='docblock'>Write a buffer into this writer, returning how many bytes were written. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.write_vectored\" class=\"method trait-impl\"><a href=\"#method.write_vectored\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">write_vectored</a>(&amp;mut self, bufs: &amp;[IoSlice&lt;'_&gt;]) -&gt; Result&lt;usize, Error&gt;</h4></section></summary><div class='docblock'>Like <a href=\"Write::write\"><code>write</code></a>, except that it writes from a slice of buffers. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.is_write_vectored\" class=\"method trait-impl\"><a href=\"#method.is_write_vectored\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">is_write_vectored</a>(&amp;self) -&gt; bool</h4></section></summary><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>can_vector</code>)</span></div></span><div class='docblock'>Determines if this <code>Write</code>r has an efficient <a href=\"Write::write_vectored\"><code>write_vectored</code></a>\nimplementation. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.flush\" class=\"method trait-impl\"><a href=\"#method.flush\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">flush</a>(&amp;mut self) -&gt; Result&lt;(), Error&gt;</h4></section></summary><div class='docblock'>Flush this output stream, ensuring that all intermediately buffered\ncontents reach their destination. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.write_all\" class=\"method trait-impl\"><a href=\"#method.write_all\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">write_all</a>(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;(), Error&gt;</h4></section></summary><div class='docblock'>Attempts to write an entire buffer into this writer. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.write_fmt\" class=\"method trait-impl\"><a href=\"#method.write_fmt\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">write_fmt</a>(&amp;mut self, fmt: Arguments&lt;'_&gt;) -&gt; Result&lt;(), Error&gt;</h4></section></summary><div class='docblock'>Writes a formatted string into this writer, returning any error\nencountered. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.write_all_vectored\" class=\"method trait-impl\"><a href=\"#method.write_all_vectored\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">write_all_vectored</a>(&amp;mut self, bufs: &amp;mut [IoSlice&lt;'_&gt;]) -&gt; Result&lt;(), Error&gt;</h4></section></summary><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>write_all_vectored</code>)</span></div></span><div class='docblock'>Attempts to write multiple buffers into this writer. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.by_ref\" class=\"method trait-impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.0.0\">1.0.0</span><a href=\"#method.by_ref\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">by_ref</a>(&amp;mut self) -&gt; &amp;mut Self<div class=\"where\">where\n    Self: Sized,</div></h4></section></summary><div class='docblock'>Creates a â€œby referenceâ€ adapter for this instance of <code>Write</code>. <a>Read more</a></div></details></div></details>","Write","rsiot::components::cmp_external_fn_process::FnProcess"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-AsRawFd-for-Box%3CT%3E\" class=\"impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.63.0\">1.63.0</span><a href=\"#impl-AsRawFd-for-Box%3CT%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T&gt; AsRawFd for Box&lt;T&gt;<div class=\"where\">where\n    T: AsRawFd,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.as_raw_fd\" class=\"method trait-impl\"><a href=\"#method.as_raw_fd\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">as_raw_fd</a>(&amp;self) -&gt; i32</h4></section></summary><div class='docblock'>Extracts the raw file descriptor. <a>Read more</a></div></details></div></details>","AsRawFd","rsiot::components::cmp_external_fn_process::FnProcess"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Hash-for-Box%3CT,+A%3E\" class=\"impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.0.0\">1.0.0</span><a href=\"#impl-Hash-for-Box%3CT,+A%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T, A&gt; Hash for Box&lt;T, A&gt;<div class=\"where\">where\n    T: Hash + ?Sized,\n    A: Allocator,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.hash\" class=\"method trait-impl\"><a href=\"#method.hash\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">hash</a>&lt;H&gt;(&amp;self, state: &amp;mut H)<div class=\"where\">where\n    H: Hasher,</div></h4></section></summary><div class='docblock'>Feeds this value into the given [<code>Hasher</code>]. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.hash_slice\" class=\"method trait-impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.3.0\">1.3.0</span><a href=\"#method.hash_slice\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">hash_slice</a>&lt;H&gt;(data: &amp;[Self], state: &amp;mut H)<div class=\"where\">where\n    H: Hasher,\n    Self: Sized,</div></h4></section></summary><div class='docblock'>Feeds a slice of this type into the given [<code>Hasher</code>]. <a>Read more</a></div></details></div></details>","Hash","rsiot::components::cmp_external_fn_process::FnProcess"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-AsMut%3CT%3E-for-Box%3CT,+A%3E\" class=\"impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.5.0\">1.5.0</span><a href=\"#impl-AsMut%3CT%3E-for-Box%3CT,+A%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T, A&gt; AsMut&lt;T&gt; for Box&lt;T, A&gt;<div class=\"where\">where\n    A: Allocator,\n    T: ?Sized,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.as_mut\" class=\"method trait-impl\"><a href=\"#method.as_mut\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">as_mut</a>(&amp;mut self) -&gt; &amp;mut T</h4></section></summary><div class='docblock'>Converts this type into a mutable reference of the (usually inferred) input type.</div></details></div></details>","AsMut<T>","rsiot::components::cmp_external_fn_process::FnProcess"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Clone-for-Box%3CT,+A%3E\" class=\"impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.0.0\">1.0.0</span><a href=\"#impl-Clone-for-Box%3CT,+A%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T, A&gt; Clone for Box&lt;T, A&gt;<div class=\"where\">where\n    T: Clone,\n    A: Allocator + Clone,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.clone\" class=\"method trait-impl\"><a href=\"#method.clone\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">clone</a>(&amp;self) -&gt; Box&lt;T, A&gt;</h4></section></summary><div class=\"docblock\"><p>Returns a new box with a <code>clone()</code> of this boxâ€™s contents.</p>\n<h5 id=\"examples\"><a class=\"doc-anchor\" href=\"#examples\">Â§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>x = Box::new(<span class=\"number\">5</span>);\n<span class=\"kw\">let </span>y = x.clone();\n\n<span class=\"comment\">// The value is the same\n</span><span class=\"macro\">assert_eq!</span>(x, y);\n\n<span class=\"comment\">// But they are unique objects\n</span><span class=\"macro\">assert_ne!</span>(<span class=\"kw-2\">&amp;*</span>x <span class=\"kw\">as </span><span class=\"kw-2\">*const </span>i32, <span class=\"kw-2\">&amp;*</span>y <span class=\"kw\">as </span><span class=\"kw-2\">*const </span>i32);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.clone_from\" class=\"method trait-impl\"><a href=\"#method.clone_from\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">clone_from</a>(&amp;mut self, source: &amp;Box&lt;T, A&gt;)</h4></section></summary><div class=\"docblock\"><p>Copies <code>source</code>â€™s contents into <code>self</code> without creating a new allocation.</p>\n<h5 id=\"examples-1\"><a class=\"doc-anchor\" href=\"#examples-1\">Â§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>x = Box::new(<span class=\"number\">5</span>);\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>y = Box::new(<span class=\"number\">10</span>);\n<span class=\"kw\">let </span>yp: <span class=\"kw-2\">*const </span>i32 = <span class=\"kw-2\">&amp;*</span>y;\n\ny.clone_from(<span class=\"kw-2\">&amp;</span>x);\n\n<span class=\"comment\">// The value is the same\n</span><span class=\"macro\">assert_eq!</span>(x, y);\n\n<span class=\"comment\">// And no allocation occurred\n</span><span class=\"macro\">assert_eq!</span>(yp, <span class=\"kw-2\">&amp;*</span>y);</code></pre></div>\n</div></details></div></details>","Clone","rsiot::components::cmp_external_fn_process::FnProcess"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-ExactSizeIterator-for-Box%3CI,+A%3E\" class=\"impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.0.0\">1.0.0</span><a href=\"#impl-ExactSizeIterator-for-Box%3CI,+A%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;I, A&gt; ExactSizeIterator for Box&lt;I, A&gt;<div class=\"where\">where\n    I: ExactSizeIterator + ?Sized,\n    A: Allocator,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.len\" class=\"method trait-impl\"><a href=\"#method.len\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">len</a>(&amp;self) -&gt; usize</h4></section></summary><div class='docblock'>Returns the exact remaining length of the iterator. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.is_empty\" class=\"method trait-impl\"><a href=\"#method.is_empty\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">is_empty</a>(&amp;self) -&gt; bool</h4></section></summary><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>exact_size_is_empty</code>)</span></div></span><div class='docblock'>Returns <code>true</code> if the iterator is empty. <a>Read more</a></div></details></div></details>","ExactSizeIterator","rsiot::components::cmp_external_fn_process::FnProcess"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-FnMut%3CArgs%3E-for-Box%3CF,+A%3E\" class=\"impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.35.0\">1.35.0</span><a href=\"#impl-FnMut%3CArgs%3E-for-Box%3CF,+A%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;Args, F, A&gt; FnMut&lt;Args&gt; for Box&lt;F, A&gt;<div class=\"where\">where\n    Args: Tuple,\n    F: FnMut&lt;Args&gt; + ?Sized,\n    A: Allocator,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.call_mut\" class=\"method trait-impl\"><a href=\"#method.call_mut\" class=\"anchor\">Â§</a><h4 class=\"code-header\">extern &quot;rust-call&quot; fn <a class=\"fn\">call_mut</a>(\n    &amp;mut self,\n    args: Args\n) -&gt; &lt;Box&lt;F, A&gt; as FnOnce&lt;Args&gt;&gt;::Output</h4></section></summary><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>fn_traits</code>)</span></div></span><div class='docblock'>Performs the call operation.</div></details></div></details>","FnMut<Args>","rsiot::components::cmp_external_fn_process::FnProcess"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Iterator-for-Box%3CI,+A%3E\" class=\"impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.0.0\">1.0.0</span><a href=\"#impl-Iterator-for-Box%3CI,+A%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;I, A&gt; Iterator for Box&lt;I, A&gt;<div class=\"where\">where\n    I: Iterator + ?Sized,\n    A: Allocator,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle\" open><summary><section id=\"associatedtype.Item\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item\" class=\"anchor\">Â§</a><h4 class=\"code-header\">type <a class=\"associatedtype\">Item</a> = &lt;I as Iterator&gt;::Item</h4></section></summary><div class='docblock'>The type of the elements being iterated over.</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.next\" class=\"method trait-impl\"><a href=\"#method.next\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">next</a>(&amp;mut self) -&gt; Option&lt;&lt;I as Iterator&gt;::Item&gt;</h4></section></summary><div class='docblock'>Advances the iterator and returns the next value. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.size_hint\" class=\"method trait-impl\"><a href=\"#method.size_hint\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">size_hint</a>(&amp;self) -&gt; (usize, Option&lt;usize&gt;)</h4></section></summary><div class='docblock'>Returns the bounds on the remaining length of the iterator. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.nth\" class=\"method trait-impl\"><a href=\"#method.nth\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">nth</a>(&amp;mut self, n: usize) -&gt; Option&lt;&lt;I as Iterator&gt;::Item&gt;</h4></section></summary><div class='docblock'>Returns the <code>n</code>th element of the iterator. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.last\" class=\"method trait-impl\"><a href=\"#method.last\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">last</a>(self) -&gt; Option&lt;&lt;I as Iterator&gt;::Item&gt;</h4></section></summary><div class='docblock'>Consumes the iterator, returning the last element. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.next_chunk\" class=\"method trait-impl\"><a href=\"#method.next_chunk\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">next_chunk</a>&lt;const N: usize&gt;(\n    &amp;mut self\n) -&gt; Result&lt;[Self::Item; N], IntoIter&lt;Self::Item, N&gt;&gt;<div class=\"where\">where\n    Self: Sized,</div></h4></section></summary><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>iter_next_chunk</code>)</span></div></span><div class='docblock'>Advances the iterator and returns an array containing the next <code>N</code> values. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.count\" class=\"method trait-impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.0.0\">1.0.0</span><a href=\"#method.count\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">count</a>(self) -&gt; usize<div class=\"where\">where\n    Self: Sized,</div></h4></section></summary><div class='docblock'>Consumes the iterator, counting the number of iterations and returning it. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.advance_by\" class=\"method trait-impl\"><a href=\"#method.advance_by\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">advance_by</a>(&amp;mut self, n: usize) -&gt; Result&lt;(), NonZero&lt;usize&gt;&gt;</h4></section></summary><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>iter_advance_by</code>)</span></div></span><div class='docblock'>Advances the iterator by <code>n</code> elements. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.step_by\" class=\"method trait-impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.28.0\">1.28.0</span><a href=\"#method.step_by\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">step_by</a>(self, step: usize) -&gt; StepBy&lt;Self&gt;<div class=\"where\">where\n    Self: Sized,</div></h4></section></summary><div class='docblock'>Creates an iterator starting at the same point, but stepping by\nthe given amount at each iteration. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.chain\" class=\"method trait-impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.0.0\">1.0.0</span><a href=\"#method.chain\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">chain</a>&lt;U&gt;(self, other: U) -&gt; Chain&lt;Self, &lt;U as IntoIterator&gt;::IntoIter&gt;<div class=\"where\">where\n    Self: Sized,\n    U: IntoIterator&lt;Item = Self::Item&gt;,</div></h4></section></summary><div class='docblock'>Takes two iterators and creates a new iterator over both in sequence. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.zip\" class=\"method trait-impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.0.0\">1.0.0</span><a href=\"#method.zip\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">zip</a>&lt;U&gt;(self, other: U) -&gt; Zip&lt;Self, &lt;U as IntoIterator&gt;::IntoIter&gt;<div class=\"where\">where\n    Self: Sized,\n    U: IntoIterator,</div></h4></section></summary><div class='docblock'>â€˜Zips upâ€™ two iterators into a single iterator of pairs. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.intersperse_with\" class=\"method trait-impl\"><a href=\"#method.intersperse_with\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">intersperse_with</a>&lt;G&gt;(self, separator: G) -&gt; IntersperseWith&lt;Self, G&gt;<div class=\"where\">where\n    Self: Sized,\n    G: FnMut() -&gt; Self::Item,</div></h4></section></summary><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>iter_intersperse</code>)</span></div></span><div class='docblock'>Creates a new iterator which places an item generated by <code>separator</code>\nbetween adjacent items of the original iterator. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.map\" class=\"method trait-impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.0.0\">1.0.0</span><a href=\"#method.map\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">map</a>&lt;B, F&gt;(self, f: F) -&gt; Map&lt;Self, F&gt;<div class=\"where\">where\n    Self: Sized,\n    F: FnMut(Self::Item) -&gt; B,</div></h4></section></summary><div class='docblock'>Takes a closure and creates an iterator which calls that closure on each\nelement. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.for_each\" class=\"method trait-impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.21.0\">1.21.0</span><a href=\"#method.for_each\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">for_each</a>&lt;F&gt;(self, f: F)<div class=\"where\">where\n    Self: Sized,\n    F: FnMut(Self::Item),</div></h4></section></summary><div class='docblock'>Calls a closure on each element of an iterator. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.filter\" class=\"method trait-impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.0.0\">1.0.0</span><a href=\"#method.filter\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">filter</a>&lt;P&gt;(self, predicate: P) -&gt; Filter&lt;Self, P&gt;<div class=\"where\">where\n    Self: Sized,\n    P: FnMut(&amp;Self::Item) -&gt; bool,</div></h4></section></summary><div class='docblock'>Creates an iterator which uses a closure to determine if an element\nshould be yielded. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.filter_map\" class=\"method trait-impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.0.0\">1.0.0</span><a href=\"#method.filter_map\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">filter_map</a>&lt;B, F&gt;(self, f: F) -&gt; FilterMap&lt;Self, F&gt;<div class=\"where\">where\n    Self: Sized,\n    F: FnMut(Self::Item) -&gt; Option&lt;B&gt;,</div></h4></section></summary><div class='docblock'>Creates an iterator that both filters and maps. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.enumerate\" class=\"method trait-impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.0.0\">1.0.0</span><a href=\"#method.enumerate\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">enumerate</a>(self) -&gt; Enumerate&lt;Self&gt;<div class=\"where\">where\n    Self: Sized,</div></h4></section></summary><div class='docblock'>Creates an iterator which gives the current iteration count as well as\nthe next value. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.peekable\" class=\"method trait-impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.0.0\">1.0.0</span><a href=\"#method.peekable\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">peekable</a>(self) -&gt; Peekable&lt;Self&gt;<div class=\"where\">where\n    Self: Sized,</div></h4></section></summary><div class='docblock'>Creates an iterator which can use the <a href=\"Peekable::peek\"><code>peek</code></a> and <a href=\"Peekable::peek_mut\"><code>peek_mut</code></a> methods\nto look at the next element of the iterator without consuming it. See\ntheir documentation for more information. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.skip_while\" class=\"method trait-impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.0.0\">1.0.0</span><a href=\"#method.skip_while\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">skip_while</a>&lt;P&gt;(self, predicate: P) -&gt; SkipWhile&lt;Self, P&gt;<div class=\"where\">where\n    Self: Sized,\n    P: FnMut(&amp;Self::Item) -&gt; bool,</div></h4></section></summary><div class='docblock'>Creates an iterator that <a href=\"Iterator::skip\"><code>skip</code></a>s elements based on a predicate. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.take_while\" class=\"method trait-impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.0.0\">1.0.0</span><a href=\"#method.take_while\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">take_while</a>&lt;P&gt;(self, predicate: P) -&gt; TakeWhile&lt;Self, P&gt;<div class=\"where\">where\n    Self: Sized,\n    P: FnMut(&amp;Self::Item) -&gt; bool,</div></h4></section></summary><div class='docblock'>Creates an iterator that yields elements based on a predicate. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.map_while\" class=\"method trait-impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.57.0\">1.57.0</span><a href=\"#method.map_while\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">map_while</a>&lt;B, P&gt;(self, predicate: P) -&gt; MapWhile&lt;Self, P&gt;<div class=\"where\">where\n    Self: Sized,\n    P: FnMut(Self::Item) -&gt; Option&lt;B&gt;,</div></h4></section></summary><div class='docblock'>Creates an iterator that both yields elements based on a predicate and maps. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.skip\" class=\"method trait-impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.0.0\">1.0.0</span><a href=\"#method.skip\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">skip</a>(self, n: usize) -&gt; Skip&lt;Self&gt;<div class=\"where\">where\n    Self: Sized,</div></h4></section></summary><div class='docblock'>Creates an iterator that skips the first <code>n</code> elements. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.take\" class=\"method trait-impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.0.0\">1.0.0</span><a href=\"#method.take\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">take</a>(self, n: usize) -&gt; Take&lt;Self&gt;<div class=\"where\">where\n    Self: Sized,</div></h4></section></summary><div class='docblock'>Creates an iterator that yields the first <code>n</code> elements, or fewer\nif the underlying iterator ends sooner. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.scan\" class=\"method trait-impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.0.0\">1.0.0</span><a href=\"#method.scan\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">scan</a>&lt;St, B, F&gt;(self, initial_state: St, f: F) -&gt; Scan&lt;Self, St, F&gt;<div class=\"where\">where\n    Self: Sized,\n    F: FnMut(&amp;mut St, Self::Item) -&gt; Option&lt;B&gt;,</div></h4></section></summary><div class='docblock'>An iterator adapter which, like <a href=\"Iterator::fold\"><code>fold</code></a>, holds internal state, but\nunlike <a href=\"Iterator::fold\"><code>fold</code></a>, produces a new iterator. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.flat_map\" class=\"method trait-impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.0.0\">1.0.0</span><a href=\"#method.flat_map\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">flat_map</a>&lt;U, F&gt;(self, f: F) -&gt; FlatMap&lt;Self, U, F&gt;<div class=\"where\">where\n    Self: Sized,\n    U: IntoIterator,\n    F: FnMut(Self::Item) -&gt; U,</div></h4></section></summary><div class='docblock'>Creates an iterator that works like map, but flattens nested structure. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.map_windows\" class=\"method trait-impl\"><a href=\"#method.map_windows\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">map_windows</a>&lt;F, R, const N: usize&gt;(self, f: F) -&gt; MapWindows&lt;Self, F, N&gt;<div class=\"where\">where\n    Self: Sized,\n    F: FnMut(&amp;[Self::Item; N]) -&gt; R,</div></h4></section></summary><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>iter_map_windows</code>)</span></div></span><div class='docblock'>Calls the given function <code>f</code> for each contiguous window of size <code>N</code> over\n<code>self</code> and returns an iterator over the outputs of <code>f</code>. Like <a href=\"slice::windows\"><code>slice::windows()</code></a>,\nthe windows during mapping overlap as well. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.fuse\" class=\"method trait-impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.0.0\">1.0.0</span><a href=\"#method.fuse\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">fuse</a>(self) -&gt; Fuse&lt;Self&gt;<div class=\"where\">where\n    Self: Sized,</div></h4></section></summary><div class='docblock'>Creates an iterator which ends after the first [<code>None</code>]. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.inspect\" class=\"method trait-impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.0.0\">1.0.0</span><a href=\"#method.inspect\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">inspect</a>&lt;F&gt;(self, f: F) -&gt; Inspect&lt;Self, F&gt;<div class=\"where\">where\n    Self: Sized,\n    F: FnMut(&amp;Self::Item),</div></h4></section></summary><div class='docblock'>Does something with each element of an iterator, passing the value on. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.by_ref\" class=\"method trait-impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.0.0\">1.0.0</span><a href=\"#method.by_ref\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">by_ref</a>(&amp;mut self) -&gt; &amp;mut Self<div class=\"where\">where\n    Self: Sized,</div></h4></section></summary><div class='docblock'>Borrows an iterator, rather than consuming it. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.collect\" class=\"method trait-impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.0.0\">1.0.0</span><a href=\"#method.collect\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">collect</a>&lt;B&gt;(self) -&gt; B<div class=\"where\">where\n    B: FromIterator&lt;Self::Item&gt;,\n    Self: Sized,</div></h4></section></summary><div class='docblock'>Transforms an iterator into a collection. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.collect_into\" class=\"method trait-impl\"><a href=\"#method.collect_into\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">collect_into</a>&lt;E&gt;(self, collection: &amp;mut E) -&gt; &amp;mut E<div class=\"where\">where\n    E: Extend&lt;Self::Item&gt;,\n    Self: Sized,</div></h4></section></summary><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>iter_collect_into</code>)</span></div></span><div class='docblock'>Collects all the items from an iterator into a collection. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.partition\" class=\"method trait-impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.0.0\">1.0.0</span><a href=\"#method.partition\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">partition</a>&lt;B, F&gt;(self, f: F) -&gt; (B, B)<div class=\"where\">where\n    Self: Sized,\n    B: Default + Extend&lt;Self::Item&gt;,\n    F: FnMut(&amp;Self::Item) -&gt; bool,</div></h4></section></summary><div class='docblock'>Consumes an iterator, creating two collections from it. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.is_partitioned\" class=\"method trait-impl\"><a href=\"#method.is_partitioned\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">is_partitioned</a>&lt;P&gt;(self, predicate: P) -&gt; bool<div class=\"where\">where\n    Self: Sized,\n    P: FnMut(Self::Item) -&gt; bool,</div></h4></section></summary><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>iter_is_partitioned</code>)</span></div></span><div class='docblock'>Checks if the elements of this iterator are partitioned according to the given predicate,\nsuch that all those that return <code>true</code> precede all those that return <code>false</code>. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.try_fold\" class=\"method trait-impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.27.0\">1.27.0</span><a href=\"#method.try_fold\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">try_fold</a>&lt;B, F, R&gt;(&amp;mut self, init: B, f: F) -&gt; R<div class=\"where\">where\n    Self: Sized,\n    F: FnMut(B, Self::Item) -&gt; R,\n    R: Try&lt;Output = B&gt;,</div></h4></section></summary><div class='docblock'>An iterator method that applies a function as long as it returns\nsuccessfully, producing a single, final value. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.try_for_each\" class=\"method trait-impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.27.0\">1.27.0</span><a href=\"#method.try_for_each\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">try_for_each</a>&lt;F, R&gt;(&amp;mut self, f: F) -&gt; R<div class=\"where\">where\n    Self: Sized,\n    F: FnMut(Self::Item) -&gt; R,\n    R: Try&lt;Output = ()&gt;,</div></h4></section></summary><div class='docblock'>An iterator method that applies a fallible function to each item in the\niterator, stopping at the first error and returning that error. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.fold\" class=\"method trait-impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.0.0\">1.0.0</span><a href=\"#method.fold\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">fold</a>&lt;B, F&gt;(self, init: B, f: F) -&gt; B<div class=\"where\">where\n    Self: Sized,\n    F: FnMut(B, Self::Item) -&gt; B,</div></h4></section></summary><div class='docblock'>Folds every element into an accumulator by applying an operation,\nreturning the final result. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.reduce\" class=\"method trait-impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.51.0\">1.51.0</span><a href=\"#method.reduce\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">reduce</a>&lt;F&gt;(self, f: F) -&gt; Option&lt;Self::Item&gt;<div class=\"where\">where\n    Self: Sized,\n    F: FnMut(Self::Item, Self::Item) -&gt; Self::Item,</div></h4></section></summary><div class='docblock'>Reduces the elements to a single one, by repeatedly applying a reducing\noperation. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.try_reduce\" class=\"method trait-impl\"><a href=\"#method.try_reduce\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">try_reduce</a>&lt;F, R&gt;(\n    &amp;mut self,\n    f: F\n) -&gt; &lt;&lt;R as Try&gt;::Residual as Residual&lt;Option&lt;&lt;R as Try&gt;::Output&gt;&gt;&gt;::TryType<div class=\"where\">where\n    Self: Sized,\n    F: FnMut(Self::Item, Self::Item) -&gt; R,\n    R: Try&lt;Output = Self::Item&gt;,\n    &lt;R as Try&gt;::Residual: Residual&lt;Option&lt;Self::Item&gt;&gt;,</div></h4></section></summary><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>iterator_try_reduce</code>)</span></div></span><div class='docblock'>Reduces the elements to a single one by repeatedly applying a reducing operation. If the\nclosure returns a failure, the failure is propagated back to the caller immediately. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.all\" class=\"method trait-impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.0.0\">1.0.0</span><a href=\"#method.all\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">all</a>&lt;F&gt;(&amp;mut self, f: F) -&gt; bool<div class=\"where\">where\n    Self: Sized,\n    F: FnMut(Self::Item) -&gt; bool,</div></h4></section></summary><div class='docblock'>Tests if every element of the iterator matches a predicate. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.any\" class=\"method trait-impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.0.0\">1.0.0</span><a href=\"#method.any\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">any</a>&lt;F&gt;(&amp;mut self, f: F) -&gt; bool<div class=\"where\">where\n    Self: Sized,\n    F: FnMut(Self::Item) -&gt; bool,</div></h4></section></summary><div class='docblock'>Tests if any element of the iterator matches a predicate. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.find\" class=\"method trait-impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.0.0\">1.0.0</span><a href=\"#method.find\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">find</a>&lt;P&gt;(&amp;mut self, predicate: P) -&gt; Option&lt;Self::Item&gt;<div class=\"where\">where\n    Self: Sized,\n    P: FnMut(&amp;Self::Item) -&gt; bool,</div></h4></section></summary><div class='docblock'>Searches for an element of an iterator that satisfies a predicate. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.find_map\" class=\"method trait-impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.30.0\">1.30.0</span><a href=\"#method.find_map\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">find_map</a>&lt;B, F&gt;(&amp;mut self, f: F) -&gt; Option&lt;B&gt;<div class=\"where\">where\n    Self: Sized,\n    F: FnMut(Self::Item) -&gt; Option&lt;B&gt;,</div></h4></section></summary><div class='docblock'>Applies function to the elements of iterator and returns\nthe first non-none result. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.try_find\" class=\"method trait-impl\"><a href=\"#method.try_find\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">try_find</a>&lt;F, R&gt;(\n    &amp;mut self,\n    f: F\n) -&gt; &lt;&lt;R as Try&gt;::Residual as Residual&lt;Option&lt;Self::Item&gt;&gt;&gt;::TryType<div class=\"where\">where\n    Self: Sized,\n    F: FnMut(&amp;Self::Item) -&gt; R,\n    R: Try&lt;Output = bool&gt;,\n    &lt;R as Try&gt;::Residual: Residual&lt;Option&lt;Self::Item&gt;&gt;,</div></h4></section></summary><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>try_find</code>)</span></div></span><div class='docblock'>Applies function to the elements of iterator and returns\nthe first true result or the first error. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.position\" class=\"method trait-impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.0.0\">1.0.0</span><a href=\"#method.position\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">position</a>&lt;P&gt;(&amp;mut self, predicate: P) -&gt; Option&lt;usize&gt;<div class=\"where\">where\n    Self: Sized,\n    P: FnMut(Self::Item) -&gt; bool,</div></h4></section></summary><div class='docblock'>Searches for an element in an iterator, returning its index. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.max_by_key\" class=\"method trait-impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.6.0\">1.6.0</span><a href=\"#method.max_by_key\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">max_by_key</a>&lt;B, F&gt;(self, f: F) -&gt; Option&lt;Self::Item&gt;<div class=\"where\">where\n    B: Ord,\n    Self: Sized,\n    F: FnMut(&amp;Self::Item) -&gt; B,</div></h4></section></summary><div class='docblock'>Returns the element that gives the maximum value from the\nspecified function. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.max_by\" class=\"method trait-impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.15.0\">1.15.0</span><a href=\"#method.max_by\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">max_by</a>&lt;F&gt;(self, compare: F) -&gt; Option&lt;Self::Item&gt;<div class=\"where\">where\n    Self: Sized,\n    F: FnMut(&amp;Self::Item, &amp;Self::Item) -&gt; Ordering,</div></h4></section></summary><div class='docblock'>Returns the element that gives the maximum value with respect to the\nspecified comparison function. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.min_by_key\" class=\"method trait-impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.6.0\">1.6.0</span><a href=\"#method.min_by_key\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">min_by_key</a>&lt;B, F&gt;(self, f: F) -&gt; Option&lt;Self::Item&gt;<div class=\"where\">where\n    B: Ord,\n    Self: Sized,\n    F: FnMut(&amp;Self::Item) -&gt; B,</div></h4></section></summary><div class='docblock'>Returns the element that gives the minimum value from the\nspecified function. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.min_by\" class=\"method trait-impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.15.0\">1.15.0</span><a href=\"#method.min_by\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">min_by</a>&lt;F&gt;(self, compare: F) -&gt; Option&lt;Self::Item&gt;<div class=\"where\">where\n    Self: Sized,\n    F: FnMut(&amp;Self::Item, &amp;Self::Item) -&gt; Ordering,</div></h4></section></summary><div class='docblock'>Returns the element that gives the minimum value with respect to the\nspecified comparison function. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.unzip\" class=\"method trait-impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.0.0\">1.0.0</span><a href=\"#method.unzip\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">unzip</a>&lt;A, B, FromA, FromB&gt;(self) -&gt; (FromA, FromB)<div class=\"where\">where\n    FromA: Default + Extend&lt;A&gt;,\n    FromB: Default + Extend&lt;B&gt;,\n    Self: Sized + Iterator&lt;Item = (A, B)&gt;,</div></h4></section></summary><div class='docblock'>Converts an iterator of pairs into a pair of containers. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.copied\" class=\"method trait-impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.36.0\">1.36.0</span><a href=\"#method.copied\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">copied</a>&lt;'a, T&gt;(self) -&gt; Copied&lt;Self&gt;<div class=\"where\">where\n    T: 'a + Copy,\n    Self: Sized + Iterator&lt;Item = &amp;'a T&gt;,</div></h4></section></summary><div class='docblock'>Creates an iterator which copies all of its elements. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.cloned\" class=\"method trait-impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.0.0\">1.0.0</span><a href=\"#method.cloned\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">cloned</a>&lt;'a, T&gt;(self) -&gt; Cloned&lt;Self&gt;<div class=\"where\">where\n    T: 'a + Clone,\n    Self: Sized + Iterator&lt;Item = &amp;'a T&gt;,</div></h4></section></summary><div class='docblock'>Creates an iterator which <a href=\"Clone::clone\"><code>clone</code></a>s all of its elements. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.array_chunks\" class=\"method trait-impl\"><a href=\"#method.array_chunks\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">array_chunks</a>&lt;const N: usize&gt;(self) -&gt; ArrayChunks&lt;Self, N&gt;<div class=\"where\">where\n    Self: Sized,</div></h4></section></summary><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>iter_array_chunks</code>)</span></div></span><div class='docblock'>Returns an iterator over <code>N</code> elements of the iterator at a time. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.sum\" class=\"method trait-impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.11.0\">1.11.0</span><a href=\"#method.sum\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">sum</a>&lt;S&gt;(self) -&gt; S<div class=\"where\">where\n    Self: Sized,\n    S: Sum&lt;Self::Item&gt;,</div></h4></section></summary><div class='docblock'>Sums the elements of an iterator. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.product\" class=\"method trait-impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.11.0\">1.11.0</span><a href=\"#method.product\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">product</a>&lt;P&gt;(self) -&gt; P<div class=\"where\">where\n    Self: Sized,\n    P: Product&lt;Self::Item&gt;,</div></h4></section></summary><div class='docblock'>Iterates over the entire iterator, multiplying all the elements <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.cmp_by\" class=\"method trait-impl\"><a href=\"#method.cmp_by\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">cmp_by</a>&lt;I, F&gt;(self, other: I, cmp: F) -&gt; Ordering<div class=\"where\">where\n    Self: Sized,\n    I: IntoIterator,\n    F: FnMut(Self::Item, &lt;I as IntoIterator&gt;::Item) -&gt; Ordering,</div></h4></section></summary><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>iter_order_by</code>)</span></div></span><div class='docblock'><a href=\"Ord#lexicographical-comparison\">Lexicographically</a> compares the elements of this [<code>Iterator</code>] with those\nof another with respect to the specified comparison function. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.partial_cmp\" class=\"method trait-impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.5.0\">1.5.0</span><a href=\"#method.partial_cmp\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">partial_cmp</a>&lt;I&gt;(self, other: I) -&gt; Option&lt;Ordering&gt;<div class=\"where\">where\n    I: IntoIterator,\n    Self::Item: PartialOrd&lt;&lt;I as IntoIterator&gt;::Item&gt;,\n    Self: Sized,</div></h4></section></summary><div class='docblock'><a href=\"Ord#lexicographical-comparison\">Lexicographically</a> compares the [<code>PartialOrd</code>] elements of\nthis [<code>Iterator</code>] with those of another. The comparison works like short-circuit\nevaluation, returning a result without comparing the remaining elements.\nAs soon as an order can be determined, the evaluation stops and a result is returned. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.partial_cmp_by\" class=\"method trait-impl\"><a href=\"#method.partial_cmp_by\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">partial_cmp_by</a>&lt;I, F&gt;(self, other: I, partial_cmp: F) -&gt; Option&lt;Ordering&gt;<div class=\"where\">where\n    Self: Sized,\n    I: IntoIterator,\n    F: FnMut(Self::Item, &lt;I as IntoIterator&gt;::Item) -&gt; Option&lt;Ordering&gt;,</div></h4></section></summary><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>iter_order_by</code>)</span></div></span><div class='docblock'><a href=\"Ord#lexicographical-comparison\">Lexicographically</a> compares the elements of this [<code>Iterator</code>] with those\nof another with respect to the specified comparison function. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.eq\" class=\"method trait-impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.5.0\">1.5.0</span><a href=\"#method.eq\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">eq</a>&lt;I&gt;(self, other: I) -&gt; bool<div class=\"where\">where\n    I: IntoIterator,\n    Self::Item: PartialEq&lt;&lt;I as IntoIterator&gt;::Item&gt;,\n    Self: Sized,</div></h4></section></summary><div class='docblock'>Determines if the elements of this [<code>Iterator</code>] are equal to those of\nanother. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.eq_by\" class=\"method trait-impl\"><a href=\"#method.eq_by\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">eq_by</a>&lt;I, F&gt;(self, other: I, eq: F) -&gt; bool<div class=\"where\">where\n    Self: Sized,\n    I: IntoIterator,\n    F: FnMut(Self::Item, &lt;I as IntoIterator&gt;::Item) -&gt; bool,</div></h4></section></summary><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>iter_order_by</code>)</span></div></span><div class='docblock'>Determines if the elements of this [<code>Iterator</code>] are equal to those of\nanother with respect to the specified equality function. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.ne\" class=\"method trait-impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.5.0\">1.5.0</span><a href=\"#method.ne\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">ne</a>&lt;I&gt;(self, other: I) -&gt; bool<div class=\"where\">where\n    I: IntoIterator,\n    Self::Item: PartialEq&lt;&lt;I as IntoIterator&gt;::Item&gt;,\n    Self: Sized,</div></h4></section></summary><div class='docblock'>Determines if the elements of this [<code>Iterator</code>] are not equal to those of\nanother. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.lt\" class=\"method trait-impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.5.0\">1.5.0</span><a href=\"#method.lt\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">lt</a>&lt;I&gt;(self, other: I) -&gt; bool<div class=\"where\">where\n    I: IntoIterator,\n    Self::Item: PartialOrd&lt;&lt;I as IntoIterator&gt;::Item&gt;,\n    Self: Sized,</div></h4></section></summary><div class='docblock'>Determines if the elements of this [<code>Iterator</code>] are <a href=\"Ord#lexicographical-comparison\">lexicographically</a>\nless than those of another. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.le\" class=\"method trait-impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.5.0\">1.5.0</span><a href=\"#method.le\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">le</a>&lt;I&gt;(self, other: I) -&gt; bool<div class=\"where\">where\n    I: IntoIterator,\n    Self::Item: PartialOrd&lt;&lt;I as IntoIterator&gt;::Item&gt;,\n    Self: Sized,</div></h4></section></summary><div class='docblock'>Determines if the elements of this [<code>Iterator</code>] are <a href=\"Ord#lexicographical-comparison\">lexicographically</a>\nless or equal to those of another. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.gt\" class=\"method trait-impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.5.0\">1.5.0</span><a href=\"#method.gt\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">gt</a>&lt;I&gt;(self, other: I) -&gt; bool<div class=\"where\">where\n    I: IntoIterator,\n    Self::Item: PartialOrd&lt;&lt;I as IntoIterator&gt;::Item&gt;,\n    Self: Sized,</div></h4></section></summary><div class='docblock'>Determines if the elements of this [<code>Iterator</code>] are <a href=\"Ord#lexicographical-comparison\">lexicographically</a>\ngreater than those of another. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.ge\" class=\"method trait-impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.5.0\">1.5.0</span><a href=\"#method.ge\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">ge</a>&lt;I&gt;(self, other: I) -&gt; bool<div class=\"where\">where\n    I: IntoIterator,\n    Self::Item: PartialOrd&lt;&lt;I as IntoIterator&gt;::Item&gt;,\n    Self: Sized,</div></h4></section></summary><div class='docblock'>Determines if the elements of this [<code>Iterator</code>] are <a href=\"Ord#lexicographical-comparison\">lexicographically</a>\ngreater than or equal to those of another. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.is_sorted_by\" class=\"method trait-impl\"><a href=\"#method.is_sorted_by\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">is_sorted_by</a>&lt;F&gt;(self, compare: F) -&gt; bool<div class=\"where\">where\n    Self: Sized,\n    F: FnMut(&amp;Self::Item, &amp;Self::Item) -&gt; bool,</div></h4></section></summary><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>is_sorted</code>)</span></div></span><div class='docblock'>Checks if the elements of this iterator are sorted using the given comparator function. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.is_sorted_by_key\" class=\"method trait-impl\"><a href=\"#method.is_sorted_by_key\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">is_sorted_by_key</a>&lt;F, K&gt;(self, f: F) -&gt; bool<div class=\"where\">where\n    Self: Sized,\n    F: FnMut(Self::Item) -&gt; K,\n    K: PartialOrd,</div></h4></section></summary><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>is_sorted</code>)</span></div></span><div class='docblock'>Checks if the elements of this iterator are sorted using the given key extraction\nfunction. <a>Read more</a></div></details></div></details>","Iterator","rsiot::components::cmp_external_fn_process::FnProcess"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Ord-for-Box%3CT,+A%3E\" class=\"impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.0.0\">1.0.0</span><a href=\"#impl-Ord-for-Box%3CT,+A%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T, A&gt; Ord for Box&lt;T, A&gt;<div class=\"where\">where\n    T: Ord + ?Sized,\n    A: Allocator,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.cmp\" class=\"method trait-impl\"><a href=\"#method.cmp\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">cmp</a>(&amp;self, other: &amp;Box&lt;T, A&gt;) -&gt; Ordering</h4></section></summary><div class='docblock'>This method returns an [<code>Ordering</code>] between <code>self</code> and <code>other</code>. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.max\" class=\"method trait-impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.21.0\">1.21.0</span><a href=\"#method.max\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">max</a>(self, other: Self) -&gt; Self<div class=\"where\">where\n    Self: Sized,</div></h4></section></summary><div class='docblock'>Compares and returns the maximum of two values. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.min\" class=\"method trait-impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.21.0\">1.21.0</span><a href=\"#method.min\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">min</a>(self, other: Self) -&gt; Self<div class=\"where\">where\n    Self: Sized,</div></h4></section></summary><div class='docblock'>Compares and returns the minimum of two values. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.clamp\" class=\"method trait-impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.50.0\">1.50.0</span><a href=\"#method.clamp\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">clamp</a>(self, min: Self, max: Self) -&gt; Self<div class=\"where\">where\n    Self: Sized + PartialOrd,</div></h4></section></summary><div class='docblock'>Restrict a value to a certain interval. <a>Read more</a></div></details></div></details>","Ord","rsiot::components::cmp_external_fn_process::FnProcess"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Coroutine%3CR%3E-for-Box%3CG,+A%3E\" class=\"impl\"><a href=\"#impl-Coroutine%3CR%3E-for-Box%3CG,+A%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;G, R, A&gt; Coroutine&lt;R&gt; for Box&lt;G, A&gt;<div class=\"where\">where\n    G: Coroutine&lt;R&gt; + Unpin + ?Sized,\n    A: Allocator + 'static,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle\" open><summary><section id=\"associatedtype.Yield\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Yield\" class=\"anchor\">Â§</a><h4 class=\"code-header\">type <a class=\"associatedtype\">Yield</a> = &lt;G as Coroutine&lt;R&gt;&gt;::Yield</h4></section></summary><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>coroutine_trait</code>)</span></div></span><div class='docblock'>The type of value this coroutine yields. <a>Read more</a></div></details><details class=\"toggle\" open><summary><section id=\"associatedtype.Return\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Return\" class=\"anchor\">Â§</a><h4 class=\"code-header\">type <a class=\"associatedtype\">Return</a> = &lt;G as Coroutine&lt;R&gt;&gt;::Return</h4></section></summary><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>coroutine_trait</code>)</span></div></span><div class='docblock'>The type of value this coroutine returns. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.resume\" class=\"method trait-impl\"><a href=\"#method.resume\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">resume</a>(\n    self: Pin&lt;&amp;mut Box&lt;G, A&gt;&gt;,\n    arg: R\n) -&gt; CoroutineState&lt;&lt;Box&lt;G, A&gt; as Coroutine&lt;R&gt;&gt;::Yield, &lt;Box&lt;G, A&gt; as Coroutine&lt;R&gt;&gt;::Return&gt;</h4></section></summary><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>coroutine_trait</code>)</span></div></span><div class='docblock'>Resumes the execution of this coroutine. <a>Read more</a></div></details></div></details>","Coroutine<R>","rsiot::components::cmp_external_fn_process::FnProcess"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-AsyncIterator-for-Box%3CS%3E\" class=\"impl\"><a href=\"#impl-AsyncIterator-for-Box%3CS%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;S&gt; AsyncIterator for Box&lt;S&gt;<div class=\"where\">where\n    S: AsyncIterator + Unpin + ?Sized,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle\" open><summary><section id=\"associatedtype.Item\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item\" class=\"anchor\">Â§</a><h4 class=\"code-header\">type <a class=\"associatedtype\">Item</a> = &lt;S as AsyncIterator&gt;::Item</h4></section></summary><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>async_iterator</code>)</span></div></span><div class='docblock'>The type of items yielded by the async iterator.</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.poll_next\" class=\"method trait-impl\"><a href=\"#method.poll_next\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">poll_next</a>(\n    self: Pin&lt;&amp;mut Box&lt;S&gt;&gt;,\n    cx: &amp;mut Context&lt;'_&gt;\n) -&gt; Poll&lt;Option&lt;&lt;Box&lt;S&gt; as AsyncIterator&gt;::Item&gt;&gt;</h4></section></summary><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>async_iterator</code>)</span></div></span><div class='docblock'>Attempt to pull out the next value of this async iterator, registering the\ncurrent task for wakeup if the value is not yet available, and returning\n<code>None</code> if the async iterator is exhausted. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.size_hint\" class=\"method trait-impl\"><a href=\"#method.size_hint\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">size_hint</a>(&amp;self) -&gt; (usize, Option&lt;usize&gt;)</h4></section></summary><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>async_iterator</code>)</span></div></span><div class='docblock'>Returns the bounds on the remaining length of the async iterator. <a>Read more</a></div></details></div></details>","AsyncIterator","rsiot::components::cmp_external_fn_process::FnProcess"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Drop-for-Box%3CT,+A%3E\" class=\"impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.0.0\">1.0.0</span><a href=\"#impl-Drop-for-Box%3CT,+A%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T, A&gt; Drop for Box&lt;T, A&gt;<div class=\"where\">where\n    A: Allocator,\n    T: ?Sized,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.drop\" class=\"method trait-impl\"><a href=\"#method.drop\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">drop</a>(&amp;mut self)</h4></section></summary><div class='docblock'>Executes the destructor for this type. <a>Read more</a></div></details></div></details>","Drop","rsiot::components::cmp_external_fn_process::FnProcess"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Future-for-Box%3CF,+A%3E\" class=\"impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.36.0\">1.36.0</span><a href=\"#impl-Future-for-Box%3CF,+A%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;F, A&gt; Future for Box&lt;F, A&gt;<div class=\"where\">where\n    F: Future + Unpin + ?Sized,\n    A: Allocator + 'static,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle\" open><summary><section id=\"associatedtype.Output\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Output\" class=\"anchor\">Â§</a><h4 class=\"code-header\">type <a class=\"associatedtype\">Output</a> = &lt;F as Future&gt;::Output</h4></section></summary><div class='docblock'>The type of value produced on completion.</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.poll\" class=\"method trait-impl\"><a href=\"#method.poll\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">poll</a>(\n    self: Pin&lt;&amp;mut Box&lt;F, A&gt;&gt;,\n    cx: &amp;mut Context&lt;'_&gt;\n) -&gt; Poll&lt;&lt;Box&lt;F, A&gt; as Future&gt;::Output&gt;</h4></section></summary><div class='docblock'>Attempt to resolve the future to a final value, registering\nthe current task for wakeup if the value is not yet available. <a>Read more</a></div></details></div></details>","Future","rsiot::components::cmp_external_fn_process::FnProcess"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-DoubleEndedIterator-for-Box%3CI,+A%3E\" class=\"impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.0.0\">1.0.0</span><a href=\"#impl-DoubleEndedIterator-for-Box%3CI,+A%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;I, A&gt; DoubleEndedIterator for Box&lt;I, A&gt;<div class=\"where\">where\n    I: DoubleEndedIterator + ?Sized,\n    A: Allocator,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.next_back\" class=\"method trait-impl\"><a href=\"#method.next_back\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">next_back</a>(&amp;mut self) -&gt; Option&lt;&lt;I as Iterator&gt;::Item&gt;</h4></section></summary><div class='docblock'>Removes and returns an element from the end of the iterator. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.nth_back\" class=\"method trait-impl\"><a href=\"#method.nth_back\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">nth_back</a>(&amp;mut self, n: usize) -&gt; Option&lt;&lt;I as Iterator&gt;::Item&gt;</h4></section></summary><div class='docblock'>Returns the <code>n</code>th element from the end of the iterator. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.advance_back_by\" class=\"method trait-impl\"><a href=\"#method.advance_back_by\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">advance_back_by</a>(&amp;mut self, n: usize) -&gt; Result&lt;(), NonZero&lt;usize&gt;&gt;</h4></section></summary><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>iter_advance_by</code>)</span></div></span><div class='docblock'>Advances the iterator from the back by <code>n</code> elements. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.try_rfold\" class=\"method trait-impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.27.0\">1.27.0</span><a href=\"#method.try_rfold\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">try_rfold</a>&lt;B, F, R&gt;(&amp;mut self, init: B, f: F) -&gt; R<div class=\"where\">where\n    Self: Sized,\n    F: FnMut(B, Self::Item) -&gt; R,\n    R: Try&lt;Output = B&gt;,</div></h4></section></summary><div class='docblock'>This is the reverse version of [<code>Iterator::try_fold()</code>]: it takes\nelements starting from the back of the iterator. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.rfold\" class=\"method trait-impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.27.0\">1.27.0</span><a href=\"#method.rfold\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">rfold</a>&lt;B, F&gt;(self, init: B, f: F) -&gt; B<div class=\"where\">where\n    Self: Sized,\n    F: FnMut(B, Self::Item) -&gt; B,</div></h4></section></summary><div class='docblock'>An iterator method that reduces the iteratorâ€™s elements to a single,\nfinal value, starting from the back. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.rfind\" class=\"method trait-impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.27.0\">1.27.0</span><a href=\"#method.rfind\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">rfind</a>&lt;P&gt;(&amp;mut self, predicate: P) -&gt; Option&lt;Self::Item&gt;<div class=\"where\">where\n    Self: Sized,\n    P: FnMut(&amp;Self::Item) -&gt; bool,</div></h4></section></summary><div class='docblock'>Searches for an element of an iterator from the back that satisfies a predicate. <a>Read more</a></div></details></div></details>","DoubleEndedIterator","rsiot::components::cmp_external_fn_process::FnProcess"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-PartialOrd-for-Box%3CT,+A%3E\" class=\"impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.0.0\">1.0.0</span><a href=\"#impl-PartialOrd-for-Box%3CT,+A%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T, A&gt; PartialOrd for Box&lt;T, A&gt;<div class=\"where\">where\n    T: PartialOrd + ?Sized,\n    A: Allocator,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.partial_cmp\" class=\"method trait-impl\"><a href=\"#method.partial_cmp\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">partial_cmp</a>(&amp;self, other: &amp;Box&lt;T, A&gt;) -&gt; Option&lt;Ordering&gt;</h4></section></summary><div class='docblock'>This method returns an ordering between <code>self</code> and <code>other</code> values if one exists. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.lt\" class=\"method trait-impl\"><a href=\"#method.lt\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">lt</a>(&amp;self, other: &amp;Box&lt;T, A&gt;) -&gt; bool</h4></section></summary><div class='docblock'>This method tests less than (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;</code> operator. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.le\" class=\"method trait-impl\"><a href=\"#method.le\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">le</a>(&amp;self, other: &amp;Box&lt;T, A&gt;) -&gt; bool</h4></section></summary><div class='docblock'>This method tests less than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;=</code>\noperator. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.ge\" class=\"method trait-impl\"><a href=\"#method.ge\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">ge</a>(&amp;self, other: &amp;Box&lt;T, A&gt;) -&gt; bool</h4></section></summary><div class='docblock'>This method tests greater than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;=</code>\noperator. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.gt\" class=\"method trait-impl\"><a href=\"#method.gt\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">gt</a>(&amp;self, other: &amp;Box&lt;T, A&gt;) -&gt; bool</h4></section></summary><div class='docblock'>This method tests greater than (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;</code> operator. <a>Read more</a></div></details></div></details>","PartialOrd","rsiot::components::cmp_external_fn_process::FnProcess"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Error-for-Box%3CT%3E\" class=\"impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.8.0\">1.8.0</span><a href=\"#impl-Error-for-Box%3CT%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T&gt; Error for Box&lt;T&gt;<div class=\"where\">where\n    T: Error,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.description\" class=\"method trait-impl\"><a href=\"#method.description\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">description</a>(&amp;self) -&gt; &amp;str</h4></section></summary><span class=\"item-info\"><div class=\"stab deprecated\"><span class=\"emoji\">ðŸ‘Ž</span><span>Deprecated since 1.42.0: use the Display impl or to_string()</span></div></span><div class='docblock'> <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.cause\" class=\"method trait-impl\"><a href=\"#method.cause\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">cause</a>(&amp;self) -&gt; Option&lt;&amp;dyn Error&gt;</h4></section></summary><span class=\"item-info\"><div class=\"stab deprecated\"><span class=\"emoji\">ðŸ‘Ž</span><span>Deprecated since 1.33.0: replaced by Error::source, which can support downcasting</span></div></span></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.source\" class=\"method trait-impl\"><a href=\"#method.source\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">source</a>(&amp;self) -&gt; Option&lt;&amp;(dyn Error + 'static)&gt;</h4></section></summary><div class='docblock'>The lower-level source of this error, if any. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.provide\" class=\"method trait-impl\"><a href=\"#method.provide\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">provide</a>&lt;'b&gt;(&amp;'b self, request: &amp;mut Request&lt;'b&gt;)</h4></section></summary><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>error_generic_member_access</code>)</span></div></span><div class='docblock'>Provides type based access to context intended for error reports. <a>Read more</a></div></details></div></details>","Error","rsiot::components::cmp_external_fn_process::FnProcess"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-From%3CT%3E-for-Box%3CT%3E\" class=\"impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.6.0\">1.6.0</span><a href=\"#impl-From%3CT%3E-for-Box%3CT%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T&gt; From&lt;T&gt; for Box&lt;T&gt;</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.from\" class=\"method trait-impl\"><a href=\"#method.from\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">from</a>(t: T) -&gt; Box&lt;T&gt;</h4></section></summary><div class=\"docblock\"><p>Converts a <code>T</code> into a <code>Box&lt;T&gt;</code></p>\n<p>The conversion allocates on the heap and moves <code>t</code>\nfrom the stack into it.</p>\n<h5 id=\"examples\"><a class=\"doc-anchor\" href=\"#examples\">Â§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>x = <span class=\"number\">5</span>;\n<span class=\"kw\">let </span>boxed = Box::new(<span class=\"number\">5</span>);\n\n<span class=\"macro\">assert_eq!</span>(Box::from(x), boxed);</code></pre></div>\n</div></details></div></details>","From<T>","rsiot::components::cmp_external_fn_process::FnProcess"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Deref-for-Box%3CT,+A%3E\" class=\"impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.0.0\">1.0.0</span><a href=\"#impl-Deref-for-Box%3CT,+A%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T, A&gt; Deref for Box&lt;T, A&gt;<div class=\"where\">where\n    A: Allocator,\n    T: ?Sized,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle\" open><summary><section id=\"associatedtype.Target\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Target\" class=\"anchor\">Â§</a><h4 class=\"code-header\">type <a class=\"associatedtype\">Target</a> = T</h4></section></summary><div class='docblock'>The resulting type after dereferencing.</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.deref\" class=\"method trait-impl\"><a href=\"#method.deref\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">deref</a>(&amp;self) -&gt; &amp;T</h4></section></summary><div class='docblock'>Dereferences the value.</div></details></div></details>","Deref","rsiot::components::cmp_external_fn_process::FnProcess"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-BorrowMut%3CT%3E-for-Box%3CT,+A%3E\" class=\"impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.1.0\">1.1.0</span><a href=\"#impl-BorrowMut%3CT%3E-for-Box%3CT,+A%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T, A&gt; BorrowMut&lt;T&gt; for Box&lt;T, A&gt;<div class=\"where\">where\n    A: Allocator,\n    T: ?Sized,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.borrow_mut\" class=\"method trait-impl\"><a href=\"#method.borrow_mut\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">borrow_mut</a>(&amp;mut self) -&gt; &amp;mut T</h4></section></summary><div class='docblock'>Mutably borrows from an owned value. <a>Read more</a></div></details></div></details>","BorrowMut<T>","rsiot::components::cmp_external_fn_process::FnProcess"],["<section id=\"impl-Eq-for-Box%3CT,+A%3E\" class=\"impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.0.0\">1.0.0</span><a href=\"#impl-Eq-for-Box%3CT,+A%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T, A&gt; Eq for Box&lt;T, A&gt;<div class=\"where\">where\n    T: Eq + ?Sized,\n    A: Allocator,</div></h3></section>","Eq","rsiot::components::cmp_external_fn_process::FnProcess"],["<section id=\"impl-Unpin-for-Box%3CT,+A%3E\" class=\"impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.33.0\">1.33.0</span><a href=\"#impl-Unpin-for-Box%3CT,+A%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T, A&gt; Unpin for Box&lt;T, A&gt;<div class=\"where\">where\n    A: Allocator + 'static,\n    T: ?Sized,</div></h3></section>","Unpin","rsiot::components::cmp_external_fn_process::FnProcess"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Fn%3CArgs%3E-for-Box%3CF,+A%3E\" class=\"impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.35.0\">1.35.0</span><a href=\"#impl-Fn%3CArgs%3E-for-Box%3CF,+A%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;Args, F, A&gt; Fn&lt;Args&gt; for Box&lt;F, A&gt;<div class=\"where\">where\n    Args: Tuple,\n    F: Fn&lt;Args&gt; + ?Sized,\n    A: Allocator,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.call\" class=\"method trait-impl\"><a href=\"#method.call\" class=\"anchor\">Â§</a><h4 class=\"code-header\">extern &quot;rust-call&quot; fn <a class=\"fn\">call</a>(\n    &amp;self,\n    args: Args\n) -&gt; &lt;Box&lt;F, A&gt; as FnOnce&lt;Args&gt;&gt;::Output</h4></section></summary><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>fn_traits</code>)</span></div></span><div class='docblock'>Performs the call operation.</div></details></div></details>","Fn<Args>","rsiot::components::cmp_external_fn_process::FnProcess"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-FnOnce%3CArgs%3E-for-Box%3CF,+A%3E\" class=\"impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.35.0\">1.35.0</span><a href=\"#impl-FnOnce%3CArgs%3E-for-Box%3CF,+A%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;Args, F, A&gt; FnOnce&lt;Args&gt; for Box&lt;F, A&gt;<div class=\"where\">where\n    Args: Tuple,\n    F: FnOnce&lt;Args&gt; + ?Sized,\n    A: Allocator,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle\" open><summary><section id=\"associatedtype.Output\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Output\" class=\"anchor\">Â§</a><h4 class=\"code-header\">type <a class=\"associatedtype\">Output</a> = &lt;F as FnOnce&lt;Args&gt;&gt;::Output</h4></section></summary><div class='docblock'>The returned type after the call operator is used.</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.call_once\" class=\"method trait-impl\"><a href=\"#method.call_once\" class=\"anchor\">Â§</a><h4 class=\"code-header\">extern &quot;rust-call&quot; fn <a class=\"fn\">call_once</a>(\n    self,\n    args: Args\n) -&gt; &lt;Box&lt;F, A&gt; as FnOnce&lt;Args&gt;&gt;::Output</h4></section></summary><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>fn_traits</code>)</span></div></span><div class='docblock'>Performs the call operation.</div></details></div></details>","FnOnce<Args>","rsiot::components::cmp_external_fn_process::FnProcess"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Pointer-for-Box%3CT,+A%3E\" class=\"impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.0.0\">1.0.0</span><a href=\"#impl-Pointer-for-Box%3CT,+A%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T, A&gt; Pointer for Box&lt;T, A&gt;<div class=\"where\">where\n    A: Allocator,\n    T: ?Sized,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.fmt\" class=\"method trait-impl\"><a href=\"#method.fmt\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">fmt</a>(&amp;self, f: &amp;mut Formatter&lt;'_&gt;) -&gt; Result&lt;(), Error&gt;</h4></section></summary><div class='docblock'>Formats the value using the given formatter.</div></details></div></details>","Pointer","rsiot::components::cmp_external_fn_process::FnProcess"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Default-for-Box%3CT%3E\" class=\"impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.0.0\">1.0.0</span><a href=\"#impl-Default-for-Box%3CT%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T&gt; Default for Box&lt;T&gt;<div class=\"where\">where\n    T: Default,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.default\" class=\"method trait-impl\"><a href=\"#method.default\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">default</a>() -&gt; Box&lt;T&gt;</h4></section></summary><div class=\"docblock\"><p>Creates a <code>Box&lt;T&gt;</code>, with the <code>Default</code> value for T.</p>\n</div></details></div></details>","Default","rsiot::components::cmp_external_fn_process::FnProcess"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Debug-for-Box%3CT,+A%3E\" class=\"impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.0.0\">1.0.0</span><a href=\"#impl-Debug-for-Box%3CT,+A%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T, A&gt; Debug for Box&lt;T, A&gt;<div class=\"where\">where\n    T: Debug + ?Sized,\n    A: Allocator,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.fmt\" class=\"method trait-impl\"><a href=\"#method.fmt\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">fmt</a>(&amp;self, f: &amp;mut Formatter&lt;'_&gt;) -&gt; Result&lt;(), Error&gt;</h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a>Read more</a></div></details></div></details>","Debug","rsiot::components::cmp_external_fn_process::FnProcess"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Borrow%3CT%3E-for-Box%3CT,+A%3E\" class=\"impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.1.0\">1.1.0</span><a href=\"#impl-Borrow%3CT%3E-for-Box%3CT,+A%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T, A&gt; Borrow&lt;T&gt; for Box&lt;T, A&gt;<div class=\"where\">where\n    A: Allocator,\n    T: ?Sized,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.borrow\" class=\"method trait-impl\"><a href=\"#method.borrow\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">borrow</a>(&amp;self) -&gt; &amp;T</h4></section></summary><div class='docblock'>Immutably borrows from an owned value. <a>Read more</a></div></details></div></details>","Borrow<T>","rsiot::components::cmp_external_fn_process::FnProcess"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-PartialEq-for-Box%3CT,+A%3E\" class=\"impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.0.0\">1.0.0</span><a href=\"#impl-PartialEq-for-Box%3CT,+A%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T, A&gt; PartialEq for Box&lt;T, A&gt;<div class=\"where\">where\n    T: PartialEq + ?Sized,\n    A: Allocator,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.eq\" class=\"method trait-impl\"><a href=\"#method.eq\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">eq</a>(&amp;self, other: &amp;Box&lt;T, A&gt;) -&gt; bool</h4></section></summary><div class='docblock'>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used\nby <code>==</code>.</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.ne\" class=\"method trait-impl\"><a href=\"#method.ne\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">ne</a>(&amp;self, other: &amp;Box&lt;T, A&gt;) -&gt; bool</h4></section></summary><div class='docblock'>This method tests for <code>!=</code>. The default implementation is almost always\nsufficient, and should not be overridden without very good reason.</div></details></div></details>","PartialEq","rsiot::components::cmp_external_fn_process::FnProcess"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-DerefMut-for-Box%3CT,+A%3E\" class=\"impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.0.0\">1.0.0</span><a href=\"#impl-DerefMut-for-Box%3CT,+A%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T, A&gt; DerefMut for Box&lt;T, A&gt;<div class=\"where\">where\n    A: Allocator,\n    T: ?Sized,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.deref_mut\" class=\"method trait-impl\"><a href=\"#method.deref_mut\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">deref_mut</a>(&amp;mut self) -&gt; &amp;mut T</h4></section></summary><div class='docblock'>Mutably dereferences the value.</div></details></div></details>","DerefMut","rsiot::components::cmp_external_fn_process::FnProcess"],["<section id=\"impl-FusedIterator-for-Box%3CI,+A%3E\" class=\"impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.26.0\">1.26.0</span><a href=\"#impl-FusedIterator-for-Box%3CI,+A%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;I, A&gt; FusedIterator for Box&lt;I, A&gt;<div class=\"where\">where\n    I: FusedIterator + ?Sized,\n    A: Allocator,</div></h3></section>","FusedIterator","rsiot::components::cmp_external_fn_process::FnProcess"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Display-for-Box%3CT,+A%3E\" class=\"impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.0.0\">1.0.0</span><a href=\"#impl-Display-for-Box%3CT,+A%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T, A&gt; Display for Box&lt;T, A&gt;<div class=\"where\">where\n    T: Display + ?Sized,\n    A: Allocator,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.fmt\" class=\"method trait-impl\"><a href=\"#method.fmt\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">fmt</a>(&amp;self, f: &amp;mut Formatter&lt;'_&gt;) -&gt; Result&lt;(), Error&gt;</h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a>Read more</a></div></details></div></details>","Display","rsiot::components::cmp_external_fn_process::FnProcess"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-AsRef%3CT%3E-for-Box%3CT,+A%3E\" class=\"impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.5.0\">1.5.0</span><a href=\"#impl-AsRef%3CT%3E-for-Box%3CT,+A%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T, A&gt; AsRef&lt;T&gt; for Box&lt;T, A&gt;<div class=\"where\">where\n    A: Allocator,\n    T: ?Sized,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.as_ref\" class=\"method trait-impl\"><a href=\"#method.as_ref\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">as_ref</a>(&amp;self) -&gt; &amp;T</h4></section></summary><div class='docblock'>Converts this type into a shared reference of the (usually inferred) input type.</div></details></div></details>","AsRef<T>","rsiot::components::cmp_external_fn_process::FnProcess"],["<section id=\"impl-DispatchFromDyn%3CBox%3CU%3E%3E-for-Box%3CT%3E\" class=\"impl\"><a href=\"#impl-DispatchFromDyn%3CBox%3CU%3E%3E-for-Box%3CT%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T, U&gt; DispatchFromDyn&lt;Box&lt;U&gt;&gt; for Box&lt;T&gt;<div class=\"where\">where\n    T: Unsize&lt;U&gt; + ?Sized,\n    U: ?Sized,</div></h3></section>","DispatchFromDyn<Box<U>>","rsiot::components::cmp_external_fn_process::FnProcess"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Hasher-for-Box%3CT,+A%3E\" class=\"impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.22.0\">1.22.0</span><a href=\"#impl-Hasher-for-Box%3CT,+A%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T, A&gt; Hasher for Box&lt;T, A&gt;<div class=\"where\">where\n    T: Hasher + ?Sized,\n    A: Allocator,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.finish\" class=\"method trait-impl\"><a href=\"#method.finish\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">finish</a>(&amp;self) -&gt; u64</h4></section></summary><div class='docblock'>Returns the hash value for the values written so far. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.write\" class=\"method trait-impl\"><a href=\"#method.write\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">write</a>(&amp;mut self, bytes: &amp;[u8])</h4></section></summary><div class='docblock'>Writes some data into this <code>Hasher</code>. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.write_u8\" class=\"method trait-impl\"><a href=\"#method.write_u8\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">write_u8</a>(&amp;mut self, i: u8)</h4></section></summary><div class='docblock'>Writes a single <code>u8</code> into this hasher.</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.write_u16\" class=\"method trait-impl\"><a href=\"#method.write_u16\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">write_u16</a>(&amp;mut self, i: u16)</h4></section></summary><div class='docblock'>Writes a single <code>u16</code> into this hasher.</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.write_u32\" class=\"method trait-impl\"><a href=\"#method.write_u32\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">write_u32</a>(&amp;mut self, i: u32)</h4></section></summary><div class='docblock'>Writes a single <code>u32</code> into this hasher.</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.write_u64\" class=\"method trait-impl\"><a href=\"#method.write_u64\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">write_u64</a>(&amp;mut self, i: u64)</h4></section></summary><div class='docblock'>Writes a single <code>u64</code> into this hasher.</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.write_u128\" class=\"method trait-impl\"><a href=\"#method.write_u128\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">write_u128</a>(&amp;mut self, i: u128)</h4></section></summary><div class='docblock'>Writes a single <code>u128</code> into this hasher.</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.write_usize\" class=\"method trait-impl\"><a href=\"#method.write_usize\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">write_usize</a>(&amp;mut self, i: usize)</h4></section></summary><div class='docblock'>Writes a single <code>usize</code> into this hasher.</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.write_i8\" class=\"method trait-impl\"><a href=\"#method.write_i8\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">write_i8</a>(&amp;mut self, i: i8)</h4></section></summary><div class='docblock'>Writes a single <code>i8</code> into this hasher.</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.write_i16\" class=\"method trait-impl\"><a href=\"#method.write_i16\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">write_i16</a>(&amp;mut self, i: i16)</h4></section></summary><div class='docblock'>Writes a single <code>i16</code> into this hasher.</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.write_i32\" class=\"method trait-impl\"><a href=\"#method.write_i32\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">write_i32</a>(&amp;mut self, i: i32)</h4></section></summary><div class='docblock'>Writes a single <code>i32</code> into this hasher.</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.write_i64\" class=\"method trait-impl\"><a href=\"#method.write_i64\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">write_i64</a>(&amp;mut self, i: i64)</h4></section></summary><div class='docblock'>Writes a single <code>i64</code> into this hasher.</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.write_i128\" class=\"method trait-impl\"><a href=\"#method.write_i128\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">write_i128</a>(&amp;mut self, i: i128)</h4></section></summary><div class='docblock'>Writes a single <code>i128</code> into this hasher.</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.write_isize\" class=\"method trait-impl\"><a href=\"#method.write_isize\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">write_isize</a>(&amp;mut self, i: isize)</h4></section></summary><div class='docblock'>Writes a single <code>isize</code> into this hasher.</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.write_length_prefix\" class=\"method trait-impl\"><a href=\"#method.write_length_prefix\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">write_length_prefix</a>(&amp;mut self, len: usize)</h4></section></summary><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>hasher_prefixfree_extras</code>)</span></div></span><div class='docblock'>Writes a length prefix into this hasher, as part of being prefix-free. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.write_str\" class=\"method trait-impl\"><a href=\"#method.write_str\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">write_str</a>(&amp;mut self, s: &amp;str)</h4></section></summary><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>hasher_prefixfree_extras</code>)</span></div></span><div class='docblock'>Writes a single <code>str</code> into this hasher. <a>Read more</a></div></details></div></details>","Hasher","rsiot::components::cmp_external_fn_process::FnProcess"],["<section id=\"impl-CoerceUnsized%3CBox%3CU,+A%3E%3E-for-Box%3CT,+A%3E\" class=\"impl\"><a href=\"#impl-CoerceUnsized%3CBox%3CU,+A%3E%3E-for-Box%3CT,+A%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T, U, A&gt; CoerceUnsized&lt;Box&lt;U, A&gt;&gt; for Box&lt;T, A&gt;<div class=\"where\">where\n    T: Unsize&lt;U&gt; + ?Sized,\n    A: Allocator,\n    U: ?Sized,</div></h3></section>","CoerceUnsized<Box<U, A>>","rsiot::components::cmp_external_fn_process::FnProcess"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-AsyncSeek-for-Box%3CT%3E\" class=\"impl\"><a href=\"#impl-AsyncSeek-for-Box%3CT%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T&gt; AsyncSeek for Box&lt;T&gt;<div class=\"where\">where\n    T: AsyncSeek + Unpin + ?Sized,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.start_seek\" class=\"method trait-impl\"><a href=\"#method.start_seek\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">start_seek</a>(self: Pin&lt;&amp;mut Box&lt;T&gt;&gt;, pos: SeekFrom) -&gt; Result&lt;(), Error&gt;</h4></section></summary><div class='docblock'>Attempts to seek to an offset, in bytes, in a stream. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.poll_complete\" class=\"method trait-impl\"><a href=\"#method.poll_complete\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">poll_complete</a>(\n    self: Pin&lt;&amp;mut Box&lt;T&gt;&gt;,\n    cx: &amp;mut Context&lt;'_&gt;\n) -&gt; Poll&lt;Result&lt;u64, Error&gt;&gt;</h4></section></summary><div class='docblock'>Waits for a seek operation to complete. <a>Read more</a></div></details></div></details>","AsyncSeek","rsiot::components::cmp_external_fn_process::FnProcess"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-AsyncRead-for-Box%3CT%3E\" class=\"impl\"><a href=\"#impl-AsyncRead-for-Box%3CT%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T&gt; AsyncRead for Box&lt;T&gt;<div class=\"where\">where\n    T: AsyncRead + Unpin + ?Sized,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.poll_read\" class=\"method trait-impl\"><a href=\"#method.poll_read\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">poll_read</a>(\n    self: Pin&lt;&amp;mut Box&lt;T&gt;&gt;,\n    cx: &amp;mut Context&lt;'_&gt;,\n    buf: &amp;mut ReadBuf&lt;'_&gt;\n) -&gt; Poll&lt;Result&lt;(), Error&gt;&gt;</h4></section></summary><div class='docblock'>Attempts to read from the <code>AsyncRead</code> into <code>buf</code>. <a>Read more</a></div></details></div></details>","AsyncRead","rsiot::components::cmp_external_fn_process::FnProcess"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-AsyncWrite-for-Box%3CT%3E\" class=\"impl\"><a href=\"#impl-AsyncWrite-for-Box%3CT%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T&gt; AsyncWrite for Box&lt;T&gt;<div class=\"where\">where\n    T: AsyncWrite + Unpin + ?Sized,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.poll_write\" class=\"method trait-impl\"><a href=\"#method.poll_write\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">poll_write</a>(\n    self: Pin&lt;&amp;mut Box&lt;T&gt;&gt;,\n    cx: &amp;mut Context&lt;'_&gt;,\n    buf: &amp;[u8]\n) -&gt; Poll&lt;Result&lt;usize, Error&gt;&gt;</h4></section></summary><div class='docblock'>Attempt to write bytes from <code>buf</code> into the object. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.poll_write_vectored\" class=\"method trait-impl\"><a href=\"#method.poll_write_vectored\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">poll_write_vectored</a>(\n    self: Pin&lt;&amp;mut Box&lt;T&gt;&gt;,\n    cx: &amp;mut Context&lt;'_&gt;,\n    bufs: &amp;[IoSlice&lt;'_&gt;]\n) -&gt; Poll&lt;Result&lt;usize, Error&gt;&gt;</h4></section></summary><div class='docblock'>Like <a href=\"AsyncWrite::poll_write\"><code>poll_write</code></a>, except that it writes from a slice of buffers. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.is_write_vectored\" class=\"method trait-impl\"><a href=\"#method.is_write_vectored\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">is_write_vectored</a>(&amp;self) -&gt; bool</h4></section></summary><div class='docblock'>Determines if this writer has an efficient <a href=\"AsyncWrite::poll_write_vectored\"><code>poll_write_vectored</code></a>\nimplementation. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.poll_flush\" class=\"method trait-impl\"><a href=\"#method.poll_flush\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">poll_flush</a>(\n    self: Pin&lt;&amp;mut Box&lt;T&gt;&gt;,\n    cx: &amp;mut Context&lt;'_&gt;\n) -&gt; Poll&lt;Result&lt;(), Error&gt;&gt;</h4></section></summary><div class='docblock'>Attempts to flush the object, ensuring that any buffered data reach\ntheir destination. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.poll_shutdown\" class=\"method trait-impl\"><a href=\"#method.poll_shutdown\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">poll_shutdown</a>(\n    self: Pin&lt;&amp;mut Box&lt;T&gt;&gt;,\n    cx: &amp;mut Context&lt;'_&gt;\n) -&gt; Poll&lt;Result&lt;(), Error&gt;&gt;</h4></section></summary><div class='docblock'>Initiates or attempts to shut down this writer, returning success when\nthe I/O connection has completely shut down. <a>Read more</a></div></details></div></details>","AsyncWrite","rsiot::components::cmp_external_fn_process::FnProcess"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-AsyncBufRead-for-Box%3CT%3E\" class=\"impl\"><a href=\"#impl-AsyncBufRead-for-Box%3CT%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T&gt; AsyncBufRead for Box&lt;T&gt;<div class=\"where\">where\n    T: AsyncBufRead + Unpin + ?Sized,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.poll_fill_buf\" class=\"method trait-impl\"><a href=\"#method.poll_fill_buf\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">poll_fill_buf</a>(\n    self: Pin&lt;&amp;mut Box&lt;T&gt;&gt;,\n    cx: &amp;mut Context&lt;'_&gt;\n) -&gt; Poll&lt;Result&lt;&amp;[u8], Error&gt;&gt;</h4></section></summary><div class='docblock'>Attempts to return the contents of the internal buffer, filling it with more data\nfrom the inner reader if it is empty. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.consume\" class=\"method trait-impl\"><a href=\"#method.consume\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">consume</a>(self: Pin&lt;&amp;mut Box&lt;T&gt;&gt;, amt: usize)</h4></section></summary><div class='docblock'>Tells this buffer that <code>amt</code> bytes have been consumed from the buffer,\nso they should no longer be returned in calls to <a href=\"AsyncRead::poll_read\"><code>poll_read</code></a>. <a>Read more</a></div></details></div></details>","AsyncBufRead","rsiot::components::cmp_external_fn_process::FnProcess"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Log-for-Box%3CT%3E\" class=\"impl\"><a class=\"src rightside\" href=\"https://docs.rs/log/0.4.21/src/log/lib.rs.html#1184-1186\">source</a><a href=\"#impl-Log-for-Box%3CT%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"https://docs.rs/log/0.4.21/log/trait.Log.html\" title=\"trait log::Log\">Log</a> for Box&lt;T&gt;<div class=\"where\">where\n    T: <a class=\"trait\" href=\"https://docs.rs/log/0.4.21/log/trait.Log.html\" title=\"trait log::Log\">Log</a> + ?Sized,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.enabled\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://docs.rs/log/0.4.21/src/log/lib.rs.html#1188\">source</a><a href=\"#method.enabled\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a href=\"https://docs.rs/log/0.4.21/log/trait.Log.html#tymethod.enabled\" class=\"fn\">enabled</a>(&amp;self, metadata: &amp;<a class=\"struct\" href=\"https://docs.rs/log/0.4.21/log/struct.Metadata.html\" title=\"struct log::Metadata\">Metadata</a>&lt;'_&gt;) -&gt; bool</h4></section></summary><div class='docblock'>Determines if a log message with the specified metadata would be\nlogged. <a href=\"https://docs.rs/log/0.4.21/log/trait.Log.html#tymethod.enabled\">Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.log\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://docs.rs/log/0.4.21/src/log/lib.rs.html#1192\">source</a><a href=\"#method.log\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a href=\"https://docs.rs/log/0.4.21/log/trait.Log.html#tymethod.log\" class=\"fn\">log</a>(&amp;self, record: &amp;<a class=\"struct\" href=\"https://docs.rs/log/0.4.21/log/struct.Record.html\" title=\"struct log::Record\">Record</a>&lt;'_&gt;)</h4></section></summary><div class='docblock'>Logs the <code>Record</code>. <a href=\"https://docs.rs/log/0.4.21/log/trait.Log.html#tymethod.log\">Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.flush\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://docs.rs/log/0.4.21/src/log/lib.rs.html#1195\">source</a><a href=\"#method.flush\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a href=\"https://docs.rs/log/0.4.21/log/trait.Log.html#tymethod.flush\" class=\"fn\">flush</a>(&amp;self)</h4></section></summary><div class='docblock'>Flushes any buffered records.</div></details></div></details>","Log","rsiot::components::cmp_external_fn_process::FnProcess"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-ErrorType-for-Box%3CT%3E\" class=\"impl\"><a href=\"#impl-ErrorType-for-Box%3CT%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T&gt; ErrorType for Box&lt;T&gt;<div class=\"where\">where\n    T: ErrorType + ?Sized,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle\" open><summary><section id=\"associatedtype.Error\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Error\" class=\"anchor\">Â§</a><h4 class=\"code-header\">type <a class=\"associatedtype\">Error</a> = &lt;T as ErrorType&gt;::Error</h4></section></summary><div class='docblock'>Error type of all the IO operations on this type.</div></details></div></details>","ErrorType","rsiot::components::cmp_external_fn_process::FnProcess"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-BufRead-for-Box%3CT%3E\" class=\"impl\"><a href=\"#impl-BufRead-for-Box%3CT%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T&gt; BufRead for Box&lt;T&gt;<div class=\"where\">where\n    T: BufRead + ?Sized,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.fill_buf\" class=\"method trait-impl\"><a href=\"#method.fill_buf\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">fill_buf</a>(&amp;mut self) -&gt; Result&lt;&amp;[u8], &lt;Box&lt;T&gt; as ErrorType&gt;::Error&gt;</h4></section></summary><div class='docblock'>Return the contents of the internal buffer, filling it with more data from the inner reader if it is empty. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.consume\" class=\"method trait-impl\"><a href=\"#method.consume\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">consume</a>(&amp;mut self, amt: usize)</h4></section></summary><div class='docblock'>Tell this buffer that <code>amt</code> bytes have been consumed from the buffer, so they should no longer be returned in calls to <code>fill_buf</code>.</div></details></div></details>","BufRead","rsiot::components::cmp_external_fn_process::FnProcess"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Read-for-Box%3CT%3E\" class=\"impl\"><a href=\"#impl-Read-for-Box%3CT%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T&gt; Read for Box&lt;T&gt;<div class=\"where\">where\n    T: Read + ?Sized,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.read\" class=\"method trait-impl\"><a href=\"#method.read\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">read</a>(\n    &amp;mut self,\n    buf: &amp;mut [u8]\n) -&gt; Result&lt;usize, &lt;Box&lt;T&gt; as ErrorType&gt;::Error&gt;</h4></section></summary><div class='docblock'>Read some bytes from this source into the specified buffer, returning how many bytes were read. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.read_exact\" class=\"method trait-impl\"><a href=\"#method.read_exact\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">read_exact</a>(\n    &amp;mut self,\n    buf: &amp;mut [u8]\n) -&gt; Result&lt;(), ReadExactError&lt;Self::Error&gt;&gt;</h4></section></summary><div class='docblock'>Read the exact number of bytes required to fill <code>buf</code>. <a>Read more</a></div></details></div></details>","Read","rsiot::components::cmp_external_fn_process::FnProcess"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Write-for-Box%3CT%3E\" class=\"impl\"><a href=\"#impl-Write-for-Box%3CT%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T&gt; Write for Box&lt;T&gt;<div class=\"where\">where\n    T: Write + ?Sized,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.write\" class=\"method trait-impl\"><a href=\"#method.write\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">write</a>(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;usize, &lt;Box&lt;T&gt; as ErrorType&gt;::Error&gt;</h4></section></summary><div class='docblock'>Write a buffer into this writer, returning how many bytes were written. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.flush\" class=\"method trait-impl\"><a href=\"#method.flush\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">flush</a>(&amp;mut self) -&gt; Result&lt;(), &lt;Box&lt;T&gt; as ErrorType&gt;::Error&gt;</h4></section></summary><div class='docblock'>Flush this output stream, blocking until all intermediately buffered contents reach their destination.</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.write_all\" class=\"method trait-impl\"><a href=\"#method.write_all\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">write_all</a>(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;(), Self::Error&gt;</h4></section></summary><div class='docblock'>Write an entire buffer into this writer. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.write_fmt\" class=\"method trait-impl\"><a href=\"#method.write_fmt\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">write_fmt</a>(\n    &amp;mut self,\n    fmt: Arguments&lt;'_&gt;\n) -&gt; Result&lt;(), WriteFmtError&lt;Self::Error&gt;&gt;</h4></section></summary><div class='docblock'>Write a formatted string into this writer, returning any error encountered. <a>Read more</a></div></details></div></details>","Write","rsiot::components::cmp_external_fn_process::FnProcess"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-ReadReady-for-Box%3CT%3E\" class=\"impl\"><a href=\"#impl-ReadReady-for-Box%3CT%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T&gt; ReadReady for Box&lt;T&gt;<div class=\"where\">where\n    T: ReadReady + ?Sized,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.read_ready\" class=\"method trait-impl\"><a href=\"#method.read_ready\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">read_ready</a>(&amp;mut self) -&gt; Result&lt;bool, &lt;Box&lt;T&gt; as ErrorType&gt;::Error&gt;</h4></section></summary><div class='docblock'>Get whether the reader is ready for immediately reading. <a>Read more</a></div></details></div></details>","ReadReady","rsiot::components::cmp_external_fn_process::FnProcess"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Seek-for-Box%3CT%3E\" class=\"impl\"><a href=\"#impl-Seek-for-Box%3CT%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T&gt; Seek for Box&lt;T&gt;<div class=\"where\">where\n    T: Seek + ?Sized,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.seek\" class=\"method trait-impl\"><a href=\"#method.seek\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">seek</a>(&amp;mut self, pos: SeekFrom) -&gt; Result&lt;u64, &lt;Box&lt;T&gt; as ErrorType&gt;::Error&gt;</h4></section></summary><div class='docblock'>Seek to an offset, in bytes, in a stream.</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.rewind\" class=\"method trait-impl\"><a href=\"#method.rewind\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">rewind</a>(&amp;mut self) -&gt; Result&lt;(), Self::Error&gt;</h4></section></summary><div class='docblock'>Rewind to the beginning of a stream.</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.stream_position\" class=\"method trait-impl\"><a href=\"#method.stream_position\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">stream_position</a>(&amp;mut self) -&gt; Result&lt;u64, Self::Error&gt;</h4></section></summary><div class='docblock'>Returns the current seek position from the start of the stream.</div></details></div></details>","Seek","rsiot::components::cmp_external_fn_process::FnProcess"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-WriteReady-for-Box%3CT%3E\" class=\"impl\"><a href=\"#impl-WriteReady-for-Box%3CT%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T&gt; WriteReady for Box&lt;T&gt;<div class=\"where\">where\n    T: WriteReady + ?Sized,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.write_ready\" class=\"method trait-impl\"><a href=\"#method.write_ready\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">write_ready</a>(&amp;mut self) -&gt; Result&lt;bool, &lt;Box&lt;T&gt; as ErrorType&gt;::Error&gt;</h4></section></summary><div class='docblock'>Get whether the writer is ready for immediately writing. <a>Read more</a></div></details></div></details>","WriteReady","rsiot::components::cmp_external_fn_process::FnProcess"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Read-for-Box%3CT%3E\" class=\"impl\"><a href=\"#impl-Read-for-Box%3CT%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T&gt; Read for Box&lt;T&gt;<div class=\"where\">where\n    T: Read + ?Sized,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.read\" class=\"method trait-impl\"><a href=\"#method.read\" class=\"anchor\">Â§</a><h4 class=\"code-header\">async fn <a class=\"fn\">read</a>(\n    &amp;mut self,\n    buf: &amp;mut [u8]\n) -&gt; Result&lt;usize, &lt;Box&lt;T&gt; as ErrorType&gt;::Error&gt;</h4></section></summary><div class='docblock'>Read some bytes from this source into the specified buffer, returning how many bytes were read. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.read_exact\" class=\"method trait-impl\"><a href=\"#method.read_exact\" class=\"anchor\">Â§</a><h4 class=\"code-header\">async fn <a class=\"fn\">read_exact</a>(\n    &amp;mut self,\n    buf: &amp;mut [u8]\n) -&gt; Result&lt;(), ReadExactError&lt;Self::Error&gt;&gt;</h4></section></summary><div class='docblock'>Read the exact number of bytes required to fill <code>buf</code>. <a>Read more</a></div></details></div></details>","Read","rsiot::components::cmp_external_fn_process::FnProcess"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Seek-for-Box%3CT%3E\" class=\"impl\"><a href=\"#impl-Seek-for-Box%3CT%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T&gt; Seek for Box&lt;T&gt;<div class=\"where\">where\n    T: Seek + ?Sized,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.seek\" class=\"method trait-impl\"><a href=\"#method.seek\" class=\"anchor\">Â§</a><h4 class=\"code-header\">async fn <a class=\"fn\">seek</a>(\n    &amp;mut self,\n    pos: SeekFrom\n) -&gt; Result&lt;u64, &lt;Box&lt;T&gt; as ErrorType&gt;::Error&gt;</h4></section></summary><div class='docblock'>Seek to an offset, in bytes, in a stream.</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.rewind\" class=\"method trait-impl\"><a href=\"#method.rewind\" class=\"anchor\">Â§</a><h4 class=\"code-header\">async fn <a class=\"fn\">rewind</a>(&amp;mut self) -&gt; Result&lt;(), Self::Error&gt;</h4></section></summary><div class='docblock'>Rewind to the beginning of a stream.</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.stream_position\" class=\"method trait-impl\"><a href=\"#method.stream_position\" class=\"anchor\">Â§</a><h4 class=\"code-header\">async fn <a class=\"fn\">stream_position</a>(&amp;mut self) -&gt; Result&lt;u64, Self::Error&gt;</h4></section></summary><div class='docblock'>Returns the current seek position from the start of the stream.</div></details></div></details>","Seek","rsiot::components::cmp_external_fn_process::FnProcess"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Write-for-Box%3CT%3E\" class=\"impl\"><a href=\"#impl-Write-for-Box%3CT%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T&gt; Write for Box&lt;T&gt;<div class=\"where\">where\n    T: Write + ?Sized,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.write\" class=\"method trait-impl\"><a href=\"#method.write\" class=\"anchor\">Â§</a><h4 class=\"code-header\">async fn <a class=\"fn\">write</a>(\n    &amp;mut self,\n    buf: &amp;[u8]\n) -&gt; Result&lt;usize, &lt;Box&lt;T&gt; as ErrorType&gt;::Error&gt;</h4></section></summary><div class='docblock'>Write a buffer into this writer, returning how many bytes were written. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.flush\" class=\"method trait-impl\"><a href=\"#method.flush\" class=\"anchor\">Â§</a><h4 class=\"code-header\">async fn <a class=\"fn\">flush</a>(&amp;mut self) -&gt; Result&lt;(), &lt;Box&lt;T&gt; as ErrorType&gt;::Error&gt;</h4></section></summary><div class='docblock'>Flush this output stream, ensuring that all intermediately buffered contents reach their destination.</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.write_all\" class=\"method trait-impl\"><a href=\"#method.write_all\" class=\"anchor\">Â§</a><h4 class=\"code-header\">async fn <a class=\"fn\">write_all</a>(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;(), Self::Error&gt;</h4></section></summary><div class='docblock'>Write an entire buffer into this writer. <a>Read more</a></div></details></div></details>","Write","rsiot::components::cmp_external_fn_process::FnProcess"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-BufRead-for-Box%3CT%3E\" class=\"impl\"><a href=\"#impl-BufRead-for-Box%3CT%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T&gt; BufRead for Box&lt;T&gt;<div class=\"where\">where\n    T: BufRead + ?Sized,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.fill_buf\" class=\"method trait-impl\"><a href=\"#method.fill_buf\" class=\"anchor\">Â§</a><h4 class=\"code-header\">async fn <a class=\"fn\">fill_buf</a>(&amp;mut self) -&gt; Result&lt;&amp;[u8], &lt;Box&lt;T&gt; as ErrorType&gt;::Error&gt;</h4></section></summary><div class='docblock'>Return the contents of the internal buffer, filling it with more data from the inner reader if it is empty. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.consume\" class=\"method trait-impl\"><a href=\"#method.consume\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">consume</a>(&amp;mut self, amt: usize)</h4></section></summary><div class='docblock'>Tell this buffer that <code>amt</code> bytes have been consumed from the buffer, so they should no longer be returned in calls to <code>fill_buf</code>.</div></details></div></details>","BufRead","rsiot::components::cmp_external_fn_process::FnProcess"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Deserialize%3C'de%3E-for-Box%3CT%3E\" class=\"impl\"><a class=\"src rightside\" href=\"https://docs.rs/serde/1.0.197/src/serde/de/impls.rs.html#1854-1858\">source</a><a href=\"#impl-Deserialize%3C'de%3E-for-Box%3CT%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;'de, T&gt; <a class=\"trait\" href=\"rsiot/message/trait.Deserialize.html\" title=\"trait rsiot::message::Deserialize\">Deserialize</a>&lt;'de&gt; for Box&lt;T&gt;<div class=\"where\">where\n    T: <a class=\"trait\" href=\"rsiot/message/trait.Deserialize.html\" title=\"trait rsiot::message::Deserialize\">Deserialize</a>&lt;'de&gt;,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.deserialize\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://docs.rs/serde/1.0.197/src/serde/de/impls.rs.html#1854-1858\">source</a><a href=\"#method.deserialize\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a href=\"rsiot/message/trait.Deserialize.html#tymethod.deserialize\" class=\"fn\">deserialize</a>&lt;D&gt;(\n    deserializer: D\n) -&gt; Result&lt;Box&lt;T&gt;, &lt;D as <a class=\"trait\" href=\"https://docs.rs/serde/1.0.197/serde/de/trait.Deserializer.html\" title=\"trait serde::de::Deserializer\">Deserializer</a>&lt;'de&gt;&gt;::<a class=\"associatedtype\" href=\"https://docs.rs/serde/1.0.197/serde/de/trait.Deserializer.html#associatedtype.Error\" title=\"type serde::de::Deserializer::Error\">Error</a>&gt;<div class=\"where\">where\n    D: <a class=\"trait\" href=\"https://docs.rs/serde/1.0.197/serde/de/trait.Deserializer.html\" title=\"trait serde::de::Deserializer\">Deserializer</a>&lt;'de&gt;,</div></h4></section></summary><div class='docblock'>Deserialize this value from the given Serde deserializer. <a href=\"rsiot/message/trait.Deserialize.html#tymethod.deserialize\">Read more</a></div></details></div></details>","Deserialize<'de>","rsiot::components::cmp_external_fn_process::FnProcess"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Serialize-for-Box%3CT%3E\" class=\"impl\"><a class=\"src rightside\" href=\"https://docs.rs/serde/1.0.197/src/serde/ser/impls.rs.html#514-518\">source</a><a href=\"#impl-Serialize-for-Box%3CT%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"rsiot/message/trait.Serialize.html\" title=\"trait rsiot::message::Serialize\">Serialize</a> for Box&lt;T&gt;<div class=\"where\">where\n    T: <a class=\"trait\" href=\"rsiot/message/trait.Serialize.html\" title=\"trait rsiot::message::Serialize\">Serialize</a> + ?Sized,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.serialize\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://docs.rs/serde/1.0.197/src/serde/ser/impls.rs.html#514-518\">source</a><a href=\"#method.serialize\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a href=\"rsiot/message/trait.Serialize.html#tymethod.serialize\" class=\"fn\">serialize</a>&lt;S&gt;(\n    &amp;self,\n    serializer: S\n) -&gt; Result&lt;&lt;S as <a class=\"trait\" href=\"https://docs.rs/serde/1.0.197/serde/ser/trait.Serializer.html\" title=\"trait serde::ser::Serializer\">Serializer</a>&gt;::<a class=\"associatedtype\" href=\"https://docs.rs/serde/1.0.197/serde/ser/trait.Serializer.html#associatedtype.Ok\" title=\"type serde::ser::Serializer::Ok\">Ok</a>, &lt;S as <a class=\"trait\" href=\"https://docs.rs/serde/1.0.197/serde/ser/trait.Serializer.html\" title=\"trait serde::ser::Serializer\">Serializer</a>&gt;::<a class=\"associatedtype\" href=\"https://docs.rs/serde/1.0.197/serde/ser/trait.Serializer.html#associatedtype.Error\" title=\"type serde::ser::Serializer::Error\">Error</a>&gt;<div class=\"where\">where\n    S: <a class=\"trait\" href=\"https://docs.rs/serde/1.0.197/serde/ser/trait.Serializer.html\" title=\"trait serde::ser::Serializer\">Serializer</a>,</div></h4></section></summary><div class='docblock'>Serialize this value into the given Serde serializer. <a href=\"rsiot/message/trait.Serialize.html#tymethod.serialize\">Read more</a></div></details></div></details>","Serialize","rsiot::components::cmp_external_fn_process::FnProcess"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Stream-for-Box%3CS%3E\" class=\"impl\"><a href=\"#impl-Stream-for-Box%3CS%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;S&gt; Stream for Box&lt;S&gt;<div class=\"where\">where\n    S: Stream + Unpin + ?Sized,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle\" open><summary><section id=\"associatedtype.Item\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item\" class=\"anchor\">Â§</a><h4 class=\"code-header\">type <a class=\"associatedtype\">Item</a> = &lt;S as Stream&gt;::Item</h4></section></summary><div class='docblock'>Values yielded by the stream.</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.poll_next\" class=\"method trait-impl\"><a href=\"#method.poll_next\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">poll_next</a>(\n    self: Pin&lt;&amp;mut Box&lt;S&gt;&gt;,\n    cx: &amp;mut Context&lt;'_&gt;\n) -&gt; Poll&lt;Option&lt;&lt;Box&lt;S&gt; as Stream&gt;::Item&gt;&gt;</h4></section></summary><div class='docblock'>Attempt to pull out the next value of this stream, registering the\ncurrent task for wakeup if the value is not yet available, and returning\n<code>None</code> if the stream is exhausted. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.size_hint\" class=\"method trait-impl\"><a href=\"#method.size_hint\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">size_hint</a>(&amp;self) -&gt; (usize, Option&lt;usize&gt;)</h4></section></summary><div class='docblock'>Returns the bounds on the remaining length of the stream. <a>Read more</a></div></details></div></details>","Stream","rsiot::components::cmp_external_fn_process::FnProcess"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-FusedFuture-for-Box%3CF%3E\" class=\"impl\"><a href=\"#impl-FusedFuture-for-Box%3CF%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;F&gt; FusedFuture for Box&lt;F&gt;<div class=\"where\">where\n    F: FusedFuture + Unpin + ?Sized,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.is_terminated\" class=\"method trait-impl\"><a href=\"#method.is_terminated\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">is_terminated</a>(&amp;self) -&gt; bool</h4></section></summary><div class='docblock'>Returns <code>true</code> if the underlying future should no longer be polled.</div></details></div></details>","FusedFuture","rsiot::components::cmp_external_fn_process::FnProcess"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-FusedStream-for-Box%3CS%3E\" class=\"impl\"><a href=\"#impl-FusedStream-for-Box%3CS%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;S&gt; FusedStream for Box&lt;S&gt;<div class=\"where\">where\n    S: FusedStream + Unpin + ?Sized,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.is_terminated\" class=\"method trait-impl\"><a href=\"#method.is_terminated\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">is_terminated</a>(&amp;self) -&gt; bool</h4></section></summary><div class='docblock'>Returns <code>true</code> if the stream should no longer be polled.</div></details></div></details>","FusedStream","rsiot::components::cmp_external_fn_process::FnProcess"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-LocalSpawn-for-Box%3CSp%3E\" class=\"impl\"><a href=\"#impl-LocalSpawn-for-Box%3CSp%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;Sp&gt; LocalSpawn for Box&lt;Sp&gt;<div class=\"where\">where\n    Sp: LocalSpawn + ?Sized,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.spawn_local_obj\" class=\"method trait-impl\"><a href=\"#method.spawn_local_obj\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">spawn_local_obj</a>(\n    &amp;self,\n    future: LocalFutureObj&lt;'static, ()&gt;\n) -&gt; Result&lt;(), SpawnError&gt;</h4></section></summary><div class='docblock'>Spawns a future that will be run to completion. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.status_local\" class=\"method trait-impl\"><a href=\"#method.status_local\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">status_local</a>(&amp;self) -&gt; Result&lt;(), SpawnError&gt;</h4></section></summary><div class='docblock'>Determines whether the executor is able to spawn new tasks. <a>Read more</a></div></details></div></details>","LocalSpawn","rsiot::components::cmp_external_fn_process::FnProcess"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Spawn-for-Box%3CSp%3E\" class=\"impl\"><a href=\"#impl-Spawn-for-Box%3CSp%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;Sp&gt; Spawn for Box&lt;Sp&gt;<div class=\"where\">where\n    Sp: Spawn + ?Sized,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.spawn_obj\" class=\"method trait-impl\"><a href=\"#method.spawn_obj\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">spawn_obj</a>(&amp;self, future: FutureObj&lt;'static, ()&gt;) -&gt; Result&lt;(), SpawnError&gt;</h4></section></summary><div class='docblock'>Spawns a future that will be run to completion. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.status\" class=\"method trait-impl\"><a href=\"#method.status\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">status</a>(&amp;self) -&gt; Result&lt;(), SpawnError&gt;</h4></section></summary><div class='docblock'>Determines whether the executor is able to spawn new tasks. <a>Read more</a></div></details></div></details>","Spawn","rsiot::components::cmp_external_fn_process::FnProcess"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-UnsafeFutureObj%3C'a,+T%3E-for-Box%3CF%3E\" class=\"impl\"><a href=\"#impl-UnsafeFutureObj%3C'a,+T%3E-for-Box%3CF%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;'a, T, F&gt; UnsafeFutureObj&lt;'a, T&gt; for Box&lt;F&gt;<div class=\"where\">where\n    F: Future&lt;Output = T&gt; + 'a,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.into_raw\" class=\"method trait-impl\"><a href=\"#method.into_raw\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">into_raw</a>(self) -&gt; *mut dyn Future&lt;Output = T&gt; + 'a</h4></section></summary><div class='docblock'>Convert an owned instance into a (conceptually owned) fat pointer. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.drop\" class=\"method trait-impl\"><a href=\"#method.drop\" class=\"anchor\">Â§</a><h4 class=\"code-header\">unsafe fn <a class=\"fn\">drop</a>(ptr: *mut dyn Future&lt;Output = T&gt; + 'a)</h4></section></summary><div class='docblock'>Drops the future represented by the given fat pointer. <a>Read more</a></div></details></div></details>","UnsafeFutureObj<'a, T>","rsiot::components::cmp_external_fn_process::FnProcess"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Sink%3CItem%3E-for-Box%3CS%3E\" class=\"impl\"><a href=\"#impl-Sink%3CItem%3E-for-Box%3CS%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;S, Item&gt; Sink&lt;Item&gt; for Box&lt;S&gt;<div class=\"where\">where\n    S: Sink&lt;Item&gt; + Unpin + ?Sized,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle\" open><summary><section id=\"associatedtype.Error\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Error\" class=\"anchor\">Â§</a><h4 class=\"code-header\">type <a class=\"associatedtype\">Error</a> = &lt;S as Sink&lt;Item&gt;&gt;::Error</h4></section></summary><div class='docblock'>The type of value produced by the sink when an error occurs.</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.poll_ready\" class=\"method trait-impl\"><a href=\"#method.poll_ready\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">poll_ready</a>(\n    self: Pin&lt;&amp;mut Box&lt;S&gt;&gt;,\n    cx: &amp;mut Context&lt;'_&gt;\n) -&gt; Poll&lt;Result&lt;(), &lt;Box&lt;S&gt; as Sink&lt;Item&gt;&gt;::Error&gt;&gt;</h4></section></summary><div class='docblock'>Attempts to prepare the <code>Sink</code> to receive a value. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.start_send\" class=\"method trait-impl\"><a href=\"#method.start_send\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">start_send</a>(\n    self: Pin&lt;&amp;mut Box&lt;S&gt;&gt;,\n    item: Item\n) -&gt; Result&lt;(), &lt;Box&lt;S&gt; as Sink&lt;Item&gt;&gt;::Error&gt;</h4></section></summary><div class='docblock'>Begin the process of sending a value to the sink.\nEach call to this function must be preceded by a successful call to\n<code>poll_ready</code> which returned <code>Poll::Ready(Ok(()))</code>. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.poll_flush\" class=\"method trait-impl\"><a href=\"#method.poll_flush\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">poll_flush</a>(\n    self: Pin&lt;&amp;mut Box&lt;S&gt;&gt;,\n    cx: &amp;mut Context&lt;'_&gt;\n) -&gt; Poll&lt;Result&lt;(), &lt;Box&lt;S&gt; as Sink&lt;Item&gt;&gt;::Error&gt;&gt;</h4></section></summary><div class='docblock'>Flush any remaining output from this sink. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.poll_close\" class=\"method trait-impl\"><a href=\"#method.poll_close\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">poll_close</a>(\n    self: Pin&lt;&amp;mut Box&lt;S&gt;&gt;,\n    cx: &amp;mut Context&lt;'_&gt;\n) -&gt; Poll&lt;Result&lt;(), &lt;Box&lt;S&gt; as Sink&lt;Item&gt;&gt;::Error&gt;&gt;</h4></section></summary><div class='docblock'>Flush any remaining output and close this sink, if necessary. <a>Read more</a></div></details></div></details>","Sink<Item>","rsiot::components::cmp_external_fn_process::FnProcess"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-AsyncWrite-for-Box%3CT%3E\" class=\"impl\"><a href=\"#impl-AsyncWrite-for-Box%3CT%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T&gt; AsyncWrite for Box&lt;T&gt;<div class=\"where\">where\n    T: AsyncWrite + Unpin + ?Sized,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.poll_write\" class=\"method trait-impl\"><a href=\"#method.poll_write\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">poll_write</a>(\n    self: Pin&lt;&amp;mut Box&lt;T&gt;&gt;,\n    cx: &amp;mut Context&lt;'_&gt;,\n    buf: &amp;[u8]\n) -&gt; Poll&lt;Result&lt;usize, Error&gt;&gt;</h4></section></summary><div class='docblock'>Attempt to write bytes from <code>buf</code> into the object. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.poll_write_vectored\" class=\"method trait-impl\"><a href=\"#method.poll_write_vectored\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">poll_write_vectored</a>(\n    self: Pin&lt;&amp;mut Box&lt;T&gt;&gt;,\n    cx: &amp;mut Context&lt;'_&gt;,\n    bufs: &amp;[IoSlice&lt;'_&gt;]\n) -&gt; Poll&lt;Result&lt;usize, Error&gt;&gt;</h4></section></summary><div class='docblock'>Attempt to write bytes from <code>bufs</code> into the object using vectored\nIO operations. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.poll_flush\" class=\"method trait-impl\"><a href=\"#method.poll_flush\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">poll_flush</a>(\n    self: Pin&lt;&amp;mut Box&lt;T&gt;&gt;,\n    cx: &amp;mut Context&lt;'_&gt;\n) -&gt; Poll&lt;Result&lt;(), Error&gt;&gt;</h4></section></summary><div class='docblock'>Attempt to flush the object, ensuring that any buffered data reach\ntheir destination. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.poll_close\" class=\"method trait-impl\"><a href=\"#method.poll_close\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">poll_close</a>(\n    self: Pin&lt;&amp;mut Box&lt;T&gt;&gt;,\n    cx: &amp;mut Context&lt;'_&gt;\n) -&gt; Poll&lt;Result&lt;(), Error&gt;&gt;</h4></section></summary><div class='docblock'>Attempt to close the object. <a>Read more</a></div></details></div></details>","AsyncWrite","rsiot::components::cmp_external_fn_process::FnProcess"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-AsyncSeek-for-Box%3CT%3E\" class=\"impl\"><a href=\"#impl-AsyncSeek-for-Box%3CT%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T&gt; AsyncSeek for Box&lt;T&gt;<div class=\"where\">where\n    T: AsyncSeek + Unpin + ?Sized,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.poll_seek\" class=\"method trait-impl\"><a href=\"#method.poll_seek\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">poll_seek</a>(\n    self: Pin&lt;&amp;mut Box&lt;T&gt;&gt;,\n    cx: &amp;mut Context&lt;'_&gt;,\n    pos: SeekFrom\n) -&gt; Poll&lt;Result&lt;u64, Error&gt;&gt;</h4></section></summary><div class='docblock'>Attempt to seek to an offset, in bytes, in a stream. <a>Read more</a></div></details></div></details>","AsyncSeek","rsiot::components::cmp_external_fn_process::FnProcess"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-AsyncRead-for-Box%3CT%3E\" class=\"impl\"><a href=\"#impl-AsyncRead-for-Box%3CT%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T&gt; AsyncRead for Box&lt;T&gt;<div class=\"where\">where\n    T: AsyncRead + Unpin + ?Sized,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.poll_read\" class=\"method trait-impl\"><a href=\"#method.poll_read\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">poll_read</a>(\n    self: Pin&lt;&amp;mut Box&lt;T&gt;&gt;,\n    cx: &amp;mut Context&lt;'_&gt;,\n    buf: &amp;mut [u8]\n) -&gt; Poll&lt;Result&lt;usize, Error&gt;&gt;</h4></section></summary><div class='docblock'>Attempt to read from the <code>AsyncRead</code> into <code>buf</code>. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.poll_read_vectored\" class=\"method trait-impl\"><a href=\"#method.poll_read_vectored\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">poll_read_vectored</a>(\n    self: Pin&lt;&amp;mut Box&lt;T&gt;&gt;,\n    cx: &amp;mut Context&lt;'_&gt;,\n    bufs: &amp;mut [IoSliceMut&lt;'_&gt;]\n) -&gt; Poll&lt;Result&lt;usize, Error&gt;&gt;</h4></section></summary><div class='docblock'>Attempt to read from the <code>AsyncRead</code> into <code>bufs</code> using vectored\nIO operations. <a>Read more</a></div></details></div></details>","AsyncRead","rsiot::components::cmp_external_fn_process::FnProcess"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-AsyncBufRead-for-Box%3CT%3E\" class=\"impl\"><a href=\"#impl-AsyncBufRead-for-Box%3CT%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T&gt; AsyncBufRead for Box&lt;T&gt;<div class=\"where\">where\n    T: AsyncBufRead + Unpin + ?Sized,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.poll_fill_buf\" class=\"method trait-impl\"><a href=\"#method.poll_fill_buf\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">poll_fill_buf</a>(\n    self: Pin&lt;&amp;mut Box&lt;T&gt;&gt;,\n    cx: &amp;mut Context&lt;'_&gt;\n) -&gt; Poll&lt;Result&lt;&amp;[u8], Error&gt;&gt;</h4></section></summary><div class='docblock'>Attempt to return the contents of the internal buffer, filling it with more data\nfrom the inner reader if it is empty. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.consume\" class=\"method trait-impl\"><a href=\"#method.consume\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">consume</a>(self: Pin&lt;&amp;mut Box&lt;T&gt;&gt;, amt: usize)</h4></section></summary><div class='docblock'>Tells this buffer that <code>amt</code> bytes have been consumed from the buffer,\nso they should no longer be returned in calls to <a href=\"AsyncRead::poll_read\"><code>poll_read</code></a>. <a>Read more</a></div></details></div></details>","AsyncBufRead","rsiot::components::cmp_external_fn_process::FnProcess"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Value-for-Box%3CT%3E\" class=\"impl\"><a href=\"#impl-Value-for-Box%3CT%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T&gt; Value for Box&lt;T&gt;<div class=\"where\">where\n    T: Value + ?Sized,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.record\" class=\"method trait-impl\"><a href=\"#method.record\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">record</a>(&amp;self, key: &amp;Field, visitor: &amp;mut dyn Visit)</h4></section></summary><div class='docblock'>Visits this value with the given <code>Visitor</code>.</div></details></div></details>","Value","rsiot::components::cmp_external_fn_process::FnProcess"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Subscriber-for-Box%3CS%3E\" class=\"impl\"><a href=\"#impl-Subscriber-for-Box%3CS%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;S&gt; Subscriber for Box&lt;S&gt;<div class=\"where\">where\n    S: Subscriber + ?Sized,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.register_callsite\" class=\"method trait-impl\"><a href=\"#method.register_callsite\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">register_callsite</a>(&amp;self, metadata: &amp;'static Metadata&lt;'static&gt;) -&gt; Interest</h4></section></summary><div class='docblock'>Registers a new <a href=\"crate::callsite\">callsite</a> with this subscriber, returning whether or not\nthe subscriber is interested in being notified about the callsite. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.enabled\" class=\"method trait-impl\"><a href=\"#method.enabled\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">enabled</a>(&amp;self, metadata: &amp;Metadata&lt;'_&gt;) -&gt; bool</h4></section></summary><div class='docblock'>Returns true if a span or event with the specified <a href=\"super::metadata::Metadata\">metadata</a> would be\nrecorded. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.max_level_hint\" class=\"method trait-impl\"><a href=\"#method.max_level_hint\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">max_level_hint</a>(&amp;self) -&gt; Option&lt;LevelFilter&gt;</h4></section></summary><div class='docblock'>Returns the highest <a href=\"super::Level\">verbosity level</a> that this <code>Subscriber</code> will\nenable, or <code>None</code>, if the subscriber does not implement level-based\nfiltering or chooses not to implement this method. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.new_span\" class=\"method trait-impl\"><a href=\"#method.new_span\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">new_span</a>(&amp;self, span: &amp;Attributes&lt;'_&gt;) -&gt; Id</h4></section></summary><div class='docblock'>Visit the construction of a new span, returning a new <a href=\"super::span::Id\">span ID</a> for the\nspan being constructed. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.record\" class=\"method trait-impl\"><a href=\"#method.record\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">record</a>(&amp;self, span: &amp;Id, values: &amp;Record&lt;'_&gt;)</h4></section></summary><div class='docblock'>Record a set of values on a span. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.record_follows_from\" class=\"method trait-impl\"><a href=\"#method.record_follows_from\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">record_follows_from</a>(&amp;self, span: &amp;Id, follows: &amp;Id)</h4></section></summary><div class='docblock'>Adds an indication that <code>span</code> follows from the span with the id\n<code>follows</code>. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.event_enabled\" class=\"method trait-impl\"><a href=\"#method.event_enabled\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">event_enabled</a>(&amp;self, event: &amp;Event&lt;'_&gt;) -&gt; bool</h4></section></summary><div class='docblock'>Determine if an [<code>Event</code>] should be recorded. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.event\" class=\"method trait-impl\"><a href=\"#method.event\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">event</a>(&amp;self, event: &amp;Event&lt;'_&gt;)</h4></section></summary><div class='docblock'>Records that an <a href=\"super::event::Event\"><code>Event</code></a> has occurred. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.enter\" class=\"method trait-impl\"><a href=\"#method.enter\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">enter</a>(&amp;self, span: &amp;Id)</h4></section></summary><div class='docblock'>Records that a span has been entered. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.exit\" class=\"method trait-impl\"><a href=\"#method.exit\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">exit</a>(&amp;self, span: &amp;Id)</h4></section></summary><div class='docblock'>Records that a span has been exited. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.clone_span\" class=\"method trait-impl\"><a href=\"#method.clone_span\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">clone_span</a>(&amp;self, id: &amp;Id) -&gt; Id</h4></section></summary><div class='docblock'>Notifies the subscriber that a <a href=\"super::span::Id\">span ID</a> has been cloned. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.try_close\" class=\"method trait-impl\"><a href=\"#method.try_close\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">try_close</a>(&amp;self, id: Id) -&gt; bool</h4></section></summary><div class='docblock'>Notifies the subscriber that a <a href=\"super::span::Id\">span ID</a> has been dropped, and returns\n<code>true</code> if there are now 0 IDs that refer to that span. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.drop_span\" class=\"method trait-impl\"><a href=\"#method.drop_span\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">drop_span</a>(&amp;self, id: Id)</h4></section></summary><span class=\"item-info\"><div class=\"stab deprecated\"><span class=\"emoji\">ðŸ‘Ž</span><span>Deprecated since 0.1.2: use <code>Subscriber::try_close</code> instead</span></div></span><div class='docblock'><strong>This method is deprecated.</strong> <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.current_span\" class=\"method trait-impl\"><a href=\"#method.current_span\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">current_span</a>(&amp;self) -&gt; Current</h4></section></summary><div class='docblock'>Returns a type representing this subscriberâ€™s view of the current span. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.downcast_raw\" class=\"method trait-impl\"><a href=\"#method.downcast_raw\" class=\"anchor\">Â§</a><h4 class=\"code-header\">unsafe fn <a class=\"fn\">downcast_raw</a>(&amp;self, id: TypeId) -&gt; Option&lt;*const ()&gt;</h4></section></summary><div class='docblock'>If <code>self</code> is the same type as the provided <code>TypeId</code>, returns an untyped\n<code>*const</code> pointer to that type. Otherwise, returns <code>None</code>. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.on_register_dispatch\" class=\"method trait-impl\"><a href=\"#method.on_register_dispatch\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">on_register_dispatch</a>(&amp;self, subscriber: &amp;Dispatch)</h4></section></summary><div class='docblock'>Invoked when this subscriber becomes a [<code>Dispatch</code>]. <a>Read more</a></div></details></div></details>","Subscriber","rsiot::components::cmp_external_fn_process::FnProcess"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Io-for-Box%3CT%3E\" class=\"impl\"><a href=\"#impl-Io-for-Box%3CT%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T&gt; Io for Box&lt;T&gt;<div class=\"where\">where\n    T: Io + ?Sized,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle\" open><summary><section id=\"associatedtype.Error\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Error\" class=\"anchor\">Â§</a><h4 class=\"code-header\">type <a class=\"associatedtype\">Error</a> = &lt;T as Io&gt;::Error</h4></section></summary><div class='docblock'>Error type of all the IO operations on this type.</div></details></div></details>","Io","rsiot::components::cmp_external_fn_process::FnProcess"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Seek-for-Box%3CT%3E\" class=\"impl\"><a href=\"#impl-Seek-for-Box%3CT%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T&gt; Seek for Box&lt;T&gt;<div class=\"where\">where\n    T: Seek + ?Sized,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.seek\" class=\"method trait-impl\"><a href=\"#method.seek\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">seek</a>(&amp;mut self, pos: SeekFrom) -&gt; Result&lt;u64, &lt;Box&lt;T&gt; as Io&gt;::Error&gt;</h4></section></summary><div class='docblock'>Seek to an offset, in bytes, in a stream.</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.rewind\" class=\"method trait-impl\"><a href=\"#method.rewind\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">rewind</a>(&amp;mut self) -&gt; Result&lt;(), Self::Error&gt;</h4></section></summary><div class='docblock'>Rewind to the beginning of a stream.</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.stream_position\" class=\"method trait-impl\"><a href=\"#method.stream_position\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">stream_position</a>(&amp;mut self) -&gt; Result&lt;u64, Self::Error&gt;</h4></section></summary><div class='docblock'>Returns the current seek position from the start of the stream.</div></details></div></details>","Seek","rsiot::components::cmp_external_fn_process::FnProcess"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Write-for-Box%3CT%3E\" class=\"impl\"><a href=\"#impl-Write-for-Box%3CT%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T&gt; Write for Box&lt;T&gt;<div class=\"where\">where\n    T: Write + ?Sized,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.write\" class=\"method trait-impl\"><a href=\"#method.write\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">write</a>(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;usize, &lt;Box&lt;T&gt; as Io&gt;::Error&gt;</h4></section></summary><div class='docblock'>Write a buffer into this writer, returning how many bytes were written.</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.flush\" class=\"method trait-impl\"><a href=\"#method.flush\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">flush</a>(&amp;mut self) -&gt; Result&lt;(), &lt;Box&lt;T&gt; as Io&gt;::Error&gt;</h4></section></summary><div class='docblock'>Flush this output stream, ensuring that all intermediately buffered contents reach their destination.</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.write_all\" class=\"method trait-impl\"><a href=\"#method.write_all\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">write_all</a>(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;(), Self::Error&gt;</h4></section></summary><div class='docblock'>Write an entire buffer into this writer.</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.write_fmt\" class=\"method trait-impl\"><a href=\"#method.write_fmt\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">write_fmt</a>(\n    &amp;mut self,\n    fmt: Arguments&lt;'_&gt;\n) -&gt; Result&lt;(), WriteFmtError&lt;Self::Error&gt;&gt;</h4></section></summary><div class='docblock'>Write a formatted string into this writer, returning any error encountered.</div></details></div></details>","Write","rsiot::components::cmp_external_fn_process::FnProcess"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-BufRead-for-Box%3CT%3E\" class=\"impl\"><a href=\"#impl-BufRead-for-Box%3CT%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T&gt; BufRead for Box&lt;T&gt;<div class=\"where\">where\n    T: BufRead + ?Sized,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.fill_buf\" class=\"method trait-impl\"><a href=\"#method.fill_buf\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">fill_buf</a>(&amp;mut self) -&gt; Result&lt;&amp;[u8], &lt;Box&lt;T&gt; as Io&gt;::Error&gt;</h4></section></summary><div class='docblock'>Return the contents of the internal buffer, filling it with more data from the inner reader if it is empty.</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.consume\" class=\"method trait-impl\"><a href=\"#method.consume\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">consume</a>(&amp;mut self, amt: usize)</h4></section></summary><div class='docblock'>Tell this buffer that <code>amt</code> bytes have been consumed from the buffer, so they should no longer be returned in calls to <code>fill_buf</code>.</div></details></div></details>","BufRead","rsiot::components::cmp_external_fn_process::FnProcess"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Read-for-Box%3CT%3E\" class=\"impl\"><a href=\"#impl-Read-for-Box%3CT%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T&gt; Read for Box&lt;T&gt;<div class=\"where\">where\n    T: Read + ?Sized,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.read\" class=\"method trait-impl\"><a href=\"#method.read\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">read</a>(&amp;mut self, buf: &amp;mut [u8]) -&gt; Result&lt;usize, &lt;Box&lt;T&gt; as Io&gt;::Error&gt;</h4></section></summary><div class='docblock'>Pull some bytes from this source into the specified buffer, returning how many bytes were read.</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.read_exact\" class=\"method trait-impl\"><a href=\"#method.read_exact\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">read_exact</a>(\n    &amp;mut self,\n    buf: &amp;mut [u8]\n) -&gt; Result&lt;(), ReadExactError&lt;Self::Error&gt;&gt;</h4></section></summary><div class='docblock'>Read the exact number of bytes required to fill <code>buf</code>.</div></details></div></details>","Read","rsiot::components::cmp_external_fn_process::FnProcess"]]
};if (window.register_type_impls) {window.register_type_impls(type_impls);} else {window.pending_type_impls = type_impls;}})()