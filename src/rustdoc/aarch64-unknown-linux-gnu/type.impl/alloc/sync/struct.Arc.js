(function() {var type_impls = {
"rsiot":[["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Arbitrary%3C'a%3E-for-Arc%3CA%3E\" class=\"impl\"><a href=\"#impl-Arbitrary%3C'a%3E-for-Arc%3CA%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;'a, A&gt; Arbitrary&lt;'a&gt; for Arc&lt;A&gt;<div class=\"where\">where\n    A: Arbitrary&lt;'a&gt;,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.arbitrary\" class=\"method trait-impl\"><a href=\"#method.arbitrary\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">arbitrary</a>(u: &amp;mut Unstructured&lt;'a&gt;) -&gt; Result&lt;Arc&lt;A&gt;, Error&gt;</h4></section></summary><div class='docblock'>Generate an arbitrary value of <code>Self</code> from the given unstructured data. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.size_hint\" class=\"method trait-impl\"><a href=\"#method.size_hint\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">size_hint</a>(depth: usize) -&gt; (usize, Option&lt;usize&gt;)</h4></section></summary><div class='docblock'>Get a size hint for how many bytes out of an <code>Unstructured</code> this type\nneeds to construct itself. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.arbitrary_take_rest\" class=\"method trait-impl\"><a href=\"#method.arbitrary_take_rest\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">arbitrary_take_rest</a>(u: Unstructured&lt;'a&gt;) -&gt; Result&lt;Self, Error&gt;</h4></section></summary><div class='docblock'>Generate an arbitrary value of <code>Self</code> from the entirety of the given\nunstructured data. <a>Read more</a></div></details></div></details>","Arbitrary<'a>","rsiot::components::cmp_surrealdb::fn_process::Db"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Arc%3CT%3E\" class=\"impl\"><a href=\"#impl-Arc%3CT%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T&gt; Arc&lt;T&gt;</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.new\" class=\"method\"><span class=\"since rightside\" title=\"Stable since Rust version 1.0.0\">1.0.0</span><h4 class=\"code-header\">pub fn <a class=\"fn\">new</a>(data: T) -&gt; Arc&lt;T&gt;</h4></section></summary><div class=\"docblock\"><p>Constructs a new <code>Arc&lt;T&gt;</code>.</p>\n<h5 id=\"examples\"><a class=\"doc-anchor\" href=\"#examples\">Â§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::sync::Arc;\n\n<span class=\"kw\">let </span>five = Arc::new(<span class=\"number\">5</span>);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.new_cyclic\" class=\"method\"><span class=\"since rightside\" title=\"Stable since Rust version 1.60.0\">1.60.0</span><h4 class=\"code-header\">pub fn <a class=\"fn\">new_cyclic</a>&lt;F&gt;(data_fn: F) -&gt; Arc&lt;T&gt;<div class=\"where\">where\n    F: FnOnce(&amp;Weak&lt;T&gt;) -&gt; T,</div></h4></section></summary><div class=\"docblock\"><p>Constructs a new <code>Arc&lt;T&gt;</code> while giving you a <code>Weak&lt;T&gt;</code> to the allocation,\nto allow you to construct a <code>T</code> which holds a weak pointer to itself.</p>\n<p>Generally, a structure circularly referencing itself, either directly or\nindirectly, should not hold a strong reference to itself to prevent a memory leak.\nUsing this function, you get access to the weak pointer during the\ninitialization of <code>T</code>, before the <code>Arc&lt;T&gt;</code> is created, such that you can\nclone and store it inside the <code>T</code>.</p>\n<p><code>new_cyclic</code> first allocates the managed allocation for the <code>Arc&lt;T&gt;</code>,\nthen calls your closure, giving it a <code>Weak&lt;T&gt;</code> to this allocation,\nand only afterwards completes the construction of the <code>Arc&lt;T&gt;</code> by placing\nthe <code>T</code> returned from your closure into the allocation.</p>\n<p>Since the new <code>Arc&lt;T&gt;</code> is not fully-constructed until <code>Arc&lt;T&gt;::new_cyclic</code>\nreturns, calling <a href=\"Weak::upgrade\"><code>upgrade</code></a> on the weak reference inside your closure will\nfail and result in a <code>None</code> value.</p>\n<h5 id=\"panics\"><a class=\"doc-anchor\" href=\"#panics\">Â§</a>Panics</h5>\n<p>If <code>data_fn</code> panics, the panic is propagated to the caller, and the\ntemporary [<code>Weak&lt;T&gt;</code>] is dropped normally.</p>\n<h5 id=\"example\"><a class=\"doc-anchor\" href=\"#example\">Â§</a>Example</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::sync::{Arc, Weak};\n\n<span class=\"kw\">struct </span>Gadget {\n    me: Weak&lt;Gadget&gt;,\n}\n\n<span class=\"kw\">impl </span>Gadget {\n    <span class=\"doccomment\">/// Construct a reference counted Gadget.\n    </span><span class=\"kw\">fn </span>new() -&gt; Arc&lt;<span class=\"self\">Self</span>&gt; {\n        <span class=\"comment\">// `me` is a `Weak&lt;Gadget&gt;` pointing at the new allocation of the\n        // `Arc` we're constructing.\n        </span>Arc::new_cyclic(|me| {\n            <span class=\"comment\">// Create the actual struct here.\n            </span>Gadget { me: me.clone() }\n        })\n    }\n\n    <span class=\"doccomment\">/// Return a reference counted pointer to Self.\n    </span><span class=\"kw\">fn </span>me(<span class=\"kw-2\">&amp;</span><span class=\"self\">self</span>) -&gt; Arc&lt;<span class=\"self\">Self</span>&gt; {\n        <span class=\"self\">self</span>.me.upgrade().unwrap()\n    }\n}</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.new_uninit\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">new_uninit</a>() -&gt; Arc&lt;MaybeUninit&lt;T&gt;&gt;</h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>new_uninit</code>)</span></div></span></summary><div class=\"docblock\"><p>Constructs a new <code>Arc</code> with uninitialized contents.</p>\n<h5 id=\"examples-1\"><a class=\"doc-anchor\" href=\"#examples-1\">Â§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(new_uninit)]\n#![feature(get_mut_unchecked)]\n\n</span><span class=\"kw\">use </span>std::sync::Arc;\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>five = Arc::&lt;u32&gt;::new_uninit();\n\n<span class=\"comment\">// Deferred initialization:\n</span>Arc::get_mut(<span class=\"kw-2\">&amp;mut </span>five).unwrap().write(<span class=\"number\">5</span>);\n\n<span class=\"kw\">let </span>five = <span class=\"kw\">unsafe </span>{ five.assume_init() };\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"kw-2\">*</span>five, <span class=\"number\">5</span>)</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.new_zeroed\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">new_zeroed</a>() -&gt; Arc&lt;MaybeUninit&lt;T&gt;&gt;</h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>new_uninit</code>)</span></div></span></summary><div class=\"docblock\"><p>Constructs a new <code>Arc</code> with uninitialized contents, with the memory\nbeing filled with <code>0</code> bytes.</p>\n<p>See <a href=\"mem::MaybeUninit::zeroed\"><code>MaybeUninit::zeroed</code></a> for examples of correct and incorrect usage\nof this method.</p>\n<h5 id=\"examples-2\"><a class=\"doc-anchor\" href=\"#examples-2\">Â§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(new_uninit)]\n\n</span><span class=\"kw\">use </span>std::sync::Arc;\n\n<span class=\"kw\">let </span>zero = Arc::&lt;u32&gt;::new_zeroed();\n<span class=\"kw\">let </span>zero = <span class=\"kw\">unsafe </span>{ zero.assume_init() };\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"kw-2\">*</span>zero, <span class=\"number\">0</span>)</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.pin\" class=\"method\"><span class=\"since rightside\" title=\"Stable since Rust version 1.33.0\">1.33.0</span><h4 class=\"code-header\">pub fn <a class=\"fn\">pin</a>(data: T) -&gt; Pin&lt;Arc&lt;T&gt;&gt;</h4></section></summary><div class=\"docblock\"><p>Constructs a new <code>Pin&lt;Arc&lt;T&gt;&gt;</code>. If <code>T</code> does not implement <code>Unpin</code>, then\n<code>data</code> will be pinned in memory and unable to be moved.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.try_pin\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">try_pin</a>(data: T) -&gt; Result&lt;Pin&lt;Arc&lt;T&gt;&gt;, AllocError&gt;</h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>allocator_api</code>)</span></div></span></summary><div class=\"docblock\"><p>Constructs a new <code>Pin&lt;Arc&lt;T&gt;&gt;</code>, return an error if allocation fails.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.try_new\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">try_new</a>(data: T) -&gt; Result&lt;Arc&lt;T&gt;, AllocError&gt;</h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>allocator_api</code>)</span></div></span></summary><div class=\"docblock\"><p>Constructs a new <code>Arc&lt;T&gt;</code>, returning an error if allocation fails.</p>\n<h5 id=\"examples-3\"><a class=\"doc-anchor\" href=\"#examples-3\">Â§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(allocator_api)]\n</span><span class=\"kw\">use </span>std::sync::Arc;\n\n<span class=\"kw\">let </span>five = Arc::try_new(<span class=\"number\">5</span>)<span class=\"question-mark\">?</span>;</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.try_new_uninit\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">try_new_uninit</a>() -&gt; Result&lt;Arc&lt;MaybeUninit&lt;T&gt;&gt;, AllocError&gt;</h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>allocator_api</code>)</span></div></span></summary><div class=\"docblock\"><p>Constructs a new <code>Arc</code> with uninitialized contents, returning an error\nif allocation fails.</p>\n<h5 id=\"examples-4\"><a class=\"doc-anchor\" href=\"#examples-4\">Â§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(new_uninit, allocator_api)]\n#![feature(get_mut_unchecked)]\n\n</span><span class=\"kw\">use </span>std::sync::Arc;\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>five = Arc::&lt;u32&gt;::try_new_uninit()<span class=\"question-mark\">?</span>;\n\n<span class=\"comment\">// Deferred initialization:\n</span>Arc::get_mut(<span class=\"kw-2\">&amp;mut </span>five).unwrap().write(<span class=\"number\">5</span>);\n\n<span class=\"kw\">let </span>five = <span class=\"kw\">unsafe </span>{ five.assume_init() };\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"kw-2\">*</span>five, <span class=\"number\">5</span>);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.try_new_zeroed\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">try_new_zeroed</a>() -&gt; Result&lt;Arc&lt;MaybeUninit&lt;T&gt;&gt;, AllocError&gt;</h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>allocator_api</code>)</span></div></span></summary><div class=\"docblock\"><p>Constructs a new <code>Arc</code> with uninitialized contents, with the memory\nbeing filled with <code>0</code> bytes, returning an error if allocation fails.</p>\n<p>See <a href=\"mem::MaybeUninit::zeroed\"><code>MaybeUninit::zeroed</code></a> for examples of correct and incorrect usage\nof this method.</p>\n<h5 id=\"examples-5\"><a class=\"doc-anchor\" href=\"#examples-5\">Â§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(new_uninit, allocator_api)]\n\n</span><span class=\"kw\">use </span>std::sync::Arc;\n\n<span class=\"kw\">let </span>zero = Arc::&lt;u32&gt;::try_new_zeroed()<span class=\"question-mark\">?</span>;\n<span class=\"kw\">let </span>zero = <span class=\"kw\">unsafe </span>{ zero.assume_init() };\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"kw-2\">*</span>zero, <span class=\"number\">0</span>);</code></pre></div>\n</div></details></div></details>",0,"rsiot::components::cmp_surrealdb::fn_process::Db"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Arc%3CT%3E\" class=\"impl\"><a href=\"#impl-Arc%3CT%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T&gt; Arc&lt;T&gt;<div class=\"where\">where\n    T: ?Sized,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.from_raw\" class=\"method\"><span class=\"since rightside\" title=\"Stable since Rust version 1.17.0\">1.17.0</span><h4 class=\"code-header\">pub unsafe fn <a class=\"fn\">from_raw</a>(ptr: *const T) -&gt; Arc&lt;T&gt;</h4></section></summary><div class=\"docblock\"><p>Constructs an <code>Arc&lt;T&gt;</code> from a raw pointer.</p>\n<p>The raw pointer must have been previously returned by a call to\n<a href=\"Arc::into_raw\"><code>Arc&lt;U&gt;::into_raw</code></a> with the following requirements:</p>\n<ul>\n<li>If <code>U</code> is sized, it must have the same size and alignment as <code>T</code>. This\nis trivially true if <code>U</code> is <code>T</code>.</li>\n<li>If <code>U</code> is unsized, its data pointer must have the same size and\nalignment as <code>T</code>. This is trivially true if <code>Arc&lt;U&gt;</code> was constructed\nthrough <code>Arc&lt;T&gt;</code> and then converted to <code>Arc&lt;U&gt;</code> through an <a href=\"https://doc.rust-lang.org/reference/type-coercions.html#unsized-coercions\">unsized\ncoercion</a>.</li>\n</ul>\n<p>Note that if <code>U</code> or <code>U</code>â€™s data pointer is not <code>T</code> but has the same size\nand alignment, this is basically like transmuting references of\ndifferent types. See <a href=\"core::mem::transmute\"><code>mem::transmute</code></a> for more information\non what restrictions apply in this case.</p>\n<p>The user of <code>from_raw</code> has to make sure a specific value of <code>T</code> is only\ndropped once.</p>\n<p>This function is unsafe because improper use may lead to memory unsafety,\neven if the returned <code>Arc&lt;T&gt;</code> is never accessed.</p>\n<h5 id=\"examples\"><a class=\"doc-anchor\" href=\"#examples\">Â§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::sync::Arc;\n\n<span class=\"kw\">let </span>x = Arc::new(<span class=\"string\">\"hello\"</span>.to_owned());\n<span class=\"kw\">let </span>x_ptr = Arc::into_raw(x);\n\n<span class=\"kw\">unsafe </span>{\n    <span class=\"comment\">// Convert back to an `Arc` to prevent leak.\n    </span><span class=\"kw\">let </span>x = Arc::from_raw(x_ptr);\n    <span class=\"macro\">assert_eq!</span>(<span class=\"kw-2\">&amp;*</span>x, <span class=\"string\">\"hello\"</span>);\n\n    <span class=\"comment\">// Further calls to `Arc::from_raw(x_ptr)` would be memory-unsafe.\n</span>}\n\n<span class=\"comment\">// The memory was freed when `x` went out of scope above, so `x_ptr` is now dangling!</span></code></pre></div>\n<p>Convert a slice back into its original array:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::sync::Arc;\n\n<span class=\"kw\">let </span>x: Arc&lt;[u32]&gt; = Arc::new([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]);\n<span class=\"kw\">let </span>x_ptr: <span class=\"kw-2\">*const </span>[u32] = Arc::into_raw(x);\n\n<span class=\"kw\">unsafe </span>{\n    <span class=\"kw\">let </span>x: Arc&lt;[u32; <span class=\"number\">3</span>]&gt; = Arc::from_raw(x_ptr.cast::&lt;[u32; <span class=\"number\">3</span>]&gt;());\n    <span class=\"macro\">assert_eq!</span>(<span class=\"kw-2\">&amp;*</span>x, <span class=\"kw-2\">&amp;</span>[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]);\n}</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.increment_strong_count\" class=\"method\"><span class=\"since rightside\" title=\"Stable since Rust version 1.51.0\">1.51.0</span><h4 class=\"code-header\">pub unsafe fn <a class=\"fn\">increment_strong_count</a>(ptr: *const T)</h4></section></summary><div class=\"docblock\"><p>Increments the strong reference count on the <code>Arc&lt;T&gt;</code> associated with the\nprovided pointer by one.</p>\n<h5 id=\"safety\"><a class=\"doc-anchor\" href=\"#safety\">Â§</a>Safety</h5>\n<p>The pointer must have been obtained through <code>Arc::into_raw</code>, and the\nassociated <code>Arc</code> instance must be valid (i.e. the strong count must be at\nleast 1) for the duration of this method.</p>\n<h5 id=\"examples-1\"><a class=\"doc-anchor\" href=\"#examples-1\">Â§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::sync::Arc;\n\n<span class=\"kw\">let </span>five = Arc::new(<span class=\"number\">5</span>);\n\n<span class=\"kw\">unsafe </span>{\n    <span class=\"kw\">let </span>ptr = Arc::into_raw(five);\n    Arc::increment_strong_count(ptr);\n\n    <span class=\"comment\">// This assertion is deterministic because we haven't shared\n    // the `Arc` between threads.\n    </span><span class=\"kw\">let </span>five = Arc::from_raw(ptr);\n    <span class=\"macro\">assert_eq!</span>(<span class=\"number\">2</span>, Arc::strong_count(<span class=\"kw-2\">&amp;</span>five));\n}</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.decrement_strong_count\" class=\"method\"><span class=\"since rightside\" title=\"Stable since Rust version 1.51.0\">1.51.0</span><h4 class=\"code-header\">pub unsafe fn <a class=\"fn\">decrement_strong_count</a>(ptr: *const T)</h4></section></summary><div class=\"docblock\"><p>Decrements the strong reference count on the <code>Arc&lt;T&gt;</code> associated with the\nprovided pointer by one.</p>\n<h5 id=\"safety-1\"><a class=\"doc-anchor\" href=\"#safety-1\">Â§</a>Safety</h5>\n<p>The pointer must have been obtained through <code>Arc::into_raw</code>, and the\nassociated <code>Arc</code> instance must be valid (i.e. the strong count must be at\nleast 1) when invoking this method. This method can be used to release the final\n<code>Arc</code> and backing storage, but <strong>should not</strong> be called after the final <code>Arc</code> has been\nreleased.</p>\n<h5 id=\"examples-2\"><a class=\"doc-anchor\" href=\"#examples-2\">Â§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::sync::Arc;\n\n<span class=\"kw\">let </span>five = Arc::new(<span class=\"number\">5</span>);\n\n<span class=\"kw\">unsafe </span>{\n    <span class=\"kw\">let </span>ptr = Arc::into_raw(five);\n    Arc::increment_strong_count(ptr);\n\n    <span class=\"comment\">// Those assertions are deterministic because we haven't shared\n    // the `Arc` between threads.\n    </span><span class=\"kw\">let </span>five = Arc::from_raw(ptr);\n    <span class=\"macro\">assert_eq!</span>(<span class=\"number\">2</span>, Arc::strong_count(<span class=\"kw-2\">&amp;</span>five));\n    Arc::decrement_strong_count(ptr);\n    <span class=\"macro\">assert_eq!</span>(<span class=\"number\">1</span>, Arc::strong_count(<span class=\"kw-2\">&amp;</span>five));\n}</code></pre></div>\n</div></details></div></details>",0,"rsiot::components::cmp_surrealdb::fn_process::Db"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Arc%3CT,+A%3E\" class=\"impl\"><a href=\"#impl-Arc%3CT,+A%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T, A&gt; Arc&lt;T, A&gt;<div class=\"where\">where\n    A: Allocator,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.allocator\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">allocator</a>(this: &amp;Arc&lt;T, A&gt;) -&gt; &amp;A</h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>allocator_api</code>)</span></div></span></summary><div class=\"docblock\"><p>Returns a reference to the underlying allocator.</p>\n<p>Note: this is an associated function, which means that you have\nto call it as <code>Arc::allocator(&amp;a)</code> instead of <code>a.allocator()</code>. This\nis so that there is no conflict with a method on the inner type.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.new_in\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">new_in</a>(data: T, alloc: A) -&gt; Arc&lt;T, A&gt;</h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>allocator_api</code>)</span></div></span></summary><div class=\"docblock\"><p>Constructs a new <code>Arc&lt;T&gt;</code> in the provided allocator.</p>\n<h5 id=\"examples\"><a class=\"doc-anchor\" href=\"#examples\">Â§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(allocator_api)]\n\n</span><span class=\"kw\">use </span>std::sync::Arc;\n<span class=\"kw\">use </span>std::alloc::System;\n\n<span class=\"kw\">let </span>five = Arc::new_in(<span class=\"number\">5</span>, System);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.new_uninit_in\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">new_uninit_in</a>(alloc: A) -&gt; Arc&lt;MaybeUninit&lt;T&gt;, A&gt;</h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>allocator_api</code>)</span></div></span></summary><div class=\"docblock\"><p>Constructs a new <code>Arc</code> with uninitialized contents in the provided allocator.</p>\n<h5 id=\"examples-1\"><a class=\"doc-anchor\" href=\"#examples-1\">Â§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(new_uninit)]\n#![feature(get_mut_unchecked)]\n#![feature(allocator_api)]\n\n</span><span class=\"kw\">use </span>std::sync::Arc;\n<span class=\"kw\">use </span>std::alloc::System;\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>five = Arc::&lt;u32, <span class=\"kw\">_</span>&gt;::new_uninit_in(System);\n\n<span class=\"kw\">let </span>five = <span class=\"kw\">unsafe </span>{\n    <span class=\"comment\">// Deferred initialization:\n    </span>Arc::get_mut_unchecked(<span class=\"kw-2\">&amp;mut </span>five).as_mut_ptr().write(<span class=\"number\">5</span>);\n\n    five.assume_init()\n};\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"kw-2\">*</span>five, <span class=\"number\">5</span>)</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.new_zeroed_in\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">new_zeroed_in</a>(alloc: A) -&gt; Arc&lt;MaybeUninit&lt;T&gt;, A&gt;</h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>allocator_api</code>)</span></div></span></summary><div class=\"docblock\"><p>Constructs a new <code>Arc</code> with uninitialized contents, with the memory\nbeing filled with <code>0</code> bytes, in the provided allocator.</p>\n<p>See <a href=\"mem::MaybeUninit::zeroed\"><code>MaybeUninit::zeroed</code></a> for examples of correct and incorrect usage\nof this method.</p>\n<h5 id=\"examples-2\"><a class=\"doc-anchor\" href=\"#examples-2\">Â§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(new_uninit)]\n#![feature(allocator_api)]\n\n</span><span class=\"kw\">use </span>std::sync::Arc;\n<span class=\"kw\">use </span>std::alloc::System;\n\n<span class=\"kw\">let </span>zero = Arc::&lt;u32, <span class=\"kw\">_</span>&gt;::new_zeroed_in(System);\n<span class=\"kw\">let </span>zero = <span class=\"kw\">unsafe </span>{ zero.assume_init() };\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"kw-2\">*</span>zero, <span class=\"number\">0</span>)</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.pin_in\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">pin_in</a>(data: T, alloc: A) -&gt; Pin&lt;Arc&lt;T, A&gt;&gt;<div class=\"where\">where\n    A: 'static,</div></h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>allocator_api</code>)</span></div></span></summary><div class=\"docblock\"><p>Constructs a new <code>Pin&lt;Arc&lt;T, A&gt;&gt;</code> in the provided allocator. If <code>T</code> does not implement <code>Unpin</code>,\nthen <code>data</code> will be pinned in memory and unable to be moved.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.try_pin_in\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">try_pin_in</a>(data: T, alloc: A) -&gt; Result&lt;Pin&lt;Arc&lt;T, A&gt;&gt;, AllocError&gt;<div class=\"where\">where\n    A: 'static,</div></h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>allocator_api</code>)</span></div></span></summary><div class=\"docblock\"><p>Constructs a new <code>Pin&lt;Arc&lt;T, A&gt;&gt;</code> in the provided allocator, return an error if allocation\nfails.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.try_new_in\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">try_new_in</a>(data: T, alloc: A) -&gt; Result&lt;Arc&lt;T, A&gt;, AllocError&gt;</h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>allocator_api</code>)</span></div></span></summary><div class=\"docblock\"><p>Constructs a new <code>Arc&lt;T, A&gt;</code> in the provided allocator, returning an error if allocation fails.</p>\n<h5 id=\"examples-3\"><a class=\"doc-anchor\" href=\"#examples-3\">Â§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(allocator_api)]\n\n</span><span class=\"kw\">use </span>std::sync::Arc;\n<span class=\"kw\">use </span>std::alloc::System;\n\n<span class=\"kw\">let </span>five = Arc::try_new_in(<span class=\"number\">5</span>, System)<span class=\"question-mark\">?</span>;</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.try_new_uninit_in\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">try_new_uninit_in</a>(alloc: A) -&gt; Result&lt;Arc&lt;MaybeUninit&lt;T&gt;, A&gt;, AllocError&gt;</h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>allocator_api</code>)</span></div></span></summary><div class=\"docblock\"><p>Constructs a new <code>Arc</code> with uninitialized contents, in the provided allocator, returning an\nerror if allocation fails.</p>\n<h5 id=\"examples-4\"><a class=\"doc-anchor\" href=\"#examples-4\">Â§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(new_uninit, allocator_api)]\n#![feature(get_mut_unchecked)]\n\n</span><span class=\"kw\">use </span>std::sync::Arc;\n<span class=\"kw\">use </span>std::alloc::System;\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>five = Arc::&lt;u32, <span class=\"kw\">_</span>&gt;::try_new_uninit_in(System)<span class=\"question-mark\">?</span>;\n\n<span class=\"kw\">let </span>five = <span class=\"kw\">unsafe </span>{\n    <span class=\"comment\">// Deferred initialization:\n    </span>Arc::get_mut_unchecked(<span class=\"kw-2\">&amp;mut </span>five).as_mut_ptr().write(<span class=\"number\">5</span>);\n\n    five.assume_init()\n};\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"kw-2\">*</span>five, <span class=\"number\">5</span>);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.try_new_zeroed_in\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">try_new_zeroed_in</a>(alloc: A) -&gt; Result&lt;Arc&lt;MaybeUninit&lt;T&gt;, A&gt;, AllocError&gt;</h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>allocator_api</code>)</span></div></span></summary><div class=\"docblock\"><p>Constructs a new <code>Arc</code> with uninitialized contents, with the memory\nbeing filled with <code>0</code> bytes, in the provided allocator, returning an error if allocation\nfails.</p>\n<p>See <a href=\"mem::MaybeUninit::zeroed\"><code>MaybeUninit::zeroed</code></a> for examples of correct and incorrect usage\nof this method.</p>\n<h5 id=\"examples-5\"><a class=\"doc-anchor\" href=\"#examples-5\">Â§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(new_uninit, allocator_api)]\n\n</span><span class=\"kw\">use </span>std::sync::Arc;\n<span class=\"kw\">use </span>std::alloc::System;\n\n<span class=\"kw\">let </span>zero = Arc::&lt;u32, <span class=\"kw\">_</span>&gt;::try_new_zeroed_in(System)<span class=\"question-mark\">?</span>;\n<span class=\"kw\">let </span>zero = <span class=\"kw\">unsafe </span>{ zero.assume_init() };\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"kw-2\">*</span>zero, <span class=\"number\">0</span>);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.try_unwrap\" class=\"method\"><span class=\"since rightside\" title=\"Stable since Rust version 1.4.0\">1.4.0</span><h4 class=\"code-header\">pub fn <a class=\"fn\">try_unwrap</a>(this: Arc&lt;T, A&gt;) -&gt; Result&lt;T, Arc&lt;T, A&gt;&gt;</h4></section></summary><div class=\"docblock\"><p>Returns the inner value, if the <code>Arc</code> has exactly one strong reference.</p>\n<p>Otherwise, an [<code>Err</code>] is returned with the same <code>Arc</code> that was\npassed in.</p>\n<p>This will succeed even if there are outstanding weak references.</p>\n<p>It is strongly recommended to use [<code>Arc::into_inner</code>] instead if you donâ€™t\nwant to keep the <code>Arc</code> in the [<code>Err</code>] case.\nImmediately dropping the [<code>Err</code>] payload, like in the expression\n<code>Arc::try_unwrap(this).ok()</code>, can still cause the strong count to\ndrop to zero and the inner value of the <code>Arc</code> to be dropped:\nFor instance if two threads each execute this expression in parallel, then\nthere is a race condition. The threads could first both check whether they\nhave the last clone of their <code>Arc</code> via <code>Arc::try_unwrap</code>, and then\nboth drop their <code>Arc</code> in the call to [<code>ok</code>][<code>Result::ok</code>],\ntaking the strong count from two down to zero.</p>\n<h5 id=\"examples-6\"><a class=\"doc-anchor\" href=\"#examples-6\">Â§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::sync::Arc;\n\n<span class=\"kw\">let </span>x = Arc::new(<span class=\"number\">3</span>);\n<span class=\"macro\">assert_eq!</span>(Arc::try_unwrap(x), <span class=\"prelude-val\">Ok</span>(<span class=\"number\">3</span>));\n\n<span class=\"kw\">let </span>x = Arc::new(<span class=\"number\">4</span>);\n<span class=\"kw\">let </span>_y = Arc::clone(<span class=\"kw-2\">&amp;</span>x);\n<span class=\"macro\">assert_eq!</span>(<span class=\"kw-2\">*</span>Arc::try_unwrap(x).unwrap_err(), <span class=\"number\">4</span>);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.into_inner\" class=\"method\"><span class=\"since rightside\" title=\"Stable since Rust version 1.70.0\">1.70.0</span><h4 class=\"code-header\">pub fn <a class=\"fn\">into_inner</a>(this: Arc&lt;T, A&gt;) -&gt; Option&lt;T&gt;</h4></section></summary><div class=\"docblock\"><p>Returns the inner value, if the <code>Arc</code> has exactly one strong reference.</p>\n<p>Otherwise, [<code>None</code>] is returned and the <code>Arc</code> is dropped.</p>\n<p>This will succeed even if there are outstanding weak references.</p>\n<p>If <code>Arc::into_inner</code> is called on every clone of this <code>Arc</code>,\nit is guaranteed that exactly one of the calls returns the inner value.\nThis means in particular that the inner value is not dropped.</p>\n<p>[<code>Arc::try_unwrap</code>] is conceptually similar to <code>Arc::into_inner</code>, but it\nis meant for different use-cases. If used as a direct replacement\nfor <code>Arc::into_inner</code> anyway, such as with the expression\n<code>[Arc::try_unwrap](this).[ok]<a href=\"\">Result::ok</a></code>, then it does\n<strong>not</strong> give the same guarantee as described in the previous paragraph.\nFor more information, see the examples below and read the documentation\nof [<code>Arc::try_unwrap</code>].</p>\n<h5 id=\"examples-7\"><a class=\"doc-anchor\" href=\"#examples-7\">Â§</a>Examples</h5>\n<p>Minimal example demonstrating the guarantee that <code>Arc::into_inner</code> gives.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::sync::Arc;\n\n<span class=\"kw\">let </span>x = Arc::new(<span class=\"number\">3</span>);\n<span class=\"kw\">let </span>y = Arc::clone(<span class=\"kw-2\">&amp;</span>x);\n\n<span class=\"comment\">// Two threads calling `Arc::into_inner` on both clones of an `Arc`:\n</span><span class=\"kw\">let </span>x_thread = std::thread::spawn(|| Arc::into_inner(x));\n<span class=\"kw\">let </span>y_thread = std::thread::spawn(|| Arc::into_inner(y));\n\n<span class=\"kw\">let </span>x_inner_value = x_thread.join().unwrap();\n<span class=\"kw\">let </span>y_inner_value = y_thread.join().unwrap();\n\n<span class=\"comment\">// One of the threads is guaranteed to receive the inner value:\n</span><span class=\"macro\">assert!</span>(<span class=\"macro\">matches!</span>(\n    (x_inner_value, y_inner_value),\n    (<span class=\"prelude-val\">None</span>, <span class=\"prelude-val\">Some</span>(<span class=\"number\">3</span>)) | (<span class=\"prelude-val\">Some</span>(<span class=\"number\">3</span>), <span class=\"prelude-val\">None</span>)\n));\n<span class=\"comment\">// The result could also be `(None, None)` if the threads called\n// `Arc::try_unwrap(x).ok()` and `Arc::try_unwrap(y).ok()` instead.</span></code></pre></div>\n<p>A more practical example demonstrating the need for <code>Arc::into_inner</code>:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::sync::Arc;\n\n<span class=\"comment\">// Definition of a simple singly linked list using `Arc`:\n</span><span class=\"attr\">#[derive(Clone)]\n</span><span class=\"kw\">struct </span>LinkedList&lt;T&gt;(<span class=\"prelude-ty\">Option</span>&lt;Arc&lt;Node&lt;T&gt;&gt;&gt;);\n<span class=\"kw\">struct </span>Node&lt;T&gt;(T, <span class=\"prelude-ty\">Option</span>&lt;Arc&lt;Node&lt;T&gt;&gt;&gt;);\n\n<span class=\"comment\">// Dropping a long `LinkedList&lt;T&gt;` relying on the destructor of `Arc`\n// can cause a stack overflow. To prevent this, we can provide a\n// manual `Drop` implementation that does the destruction in a loop:\n</span><span class=\"kw\">impl</span>&lt;T&gt; Drop <span class=\"kw\">for </span>LinkedList&lt;T&gt; {\n    <span class=\"kw\">fn </span>drop(<span class=\"kw-2\">&amp;mut </span><span class=\"self\">self</span>) {\n        <span class=\"kw\">let </span><span class=\"kw-2\">mut </span>link = <span class=\"self\">self</span>.<span class=\"number\">0</span>.take();\n        <span class=\"kw\">while let </span><span class=\"prelude-val\">Some</span>(arc_node) = link.take() {\n            <span class=\"kw\">if let </span><span class=\"prelude-val\">Some</span>(Node(_value, next)) = Arc::into_inner(arc_node) {\n                link = next;\n            }\n        }\n    }\n}\n\n<span class=\"comment\">// Implementation of `new` and `push` omitted\n</span><span class=\"kw\">impl</span>&lt;T&gt; LinkedList&lt;T&gt; {\n    <span class=\"comment\">/* ... */\n</span>}\n\n<span class=\"comment\">// The following code could have still caused a stack overflow\n// despite the manual `Drop` impl if that `Drop` impl had used\n// `Arc::try_unwrap(arc).ok()` instead of `Arc::into_inner(arc)`.\n\n// Create a long list and clone it\n</span><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>x = LinkedList::new();\n<span class=\"kw\">let </span>size = <span class=\"number\">100000</span>;\n<span class=\"kw\">for </span>i <span class=\"kw\">in </span><span class=\"number\">0</span>..size {\n    x.push(i); <span class=\"comment\">// Adds i to the front of x\n</span>}\n<span class=\"kw\">let </span>y = x.clone();\n\n<span class=\"comment\">// Drop the clones in parallel\n</span><span class=\"kw\">let </span>x_thread = std::thread::spawn(|| drop(x));\n<span class=\"kw\">let </span>y_thread = std::thread::spawn(|| drop(y));\nx_thread.join().unwrap();\ny_thread.join().unwrap();</code></pre></div>\n</div></details></div></details>",0,"rsiot::components::cmp_surrealdb::fn_process::Db"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Arc%3CT,+A%3E\" class=\"impl\"><a href=\"#impl-Arc%3CT,+A%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T, A&gt; Arc&lt;T, A&gt;<div class=\"where\">where\n    A: Allocator,\n    T: ?Sized,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.get_mut\" class=\"method\"><span class=\"since rightside\" title=\"Stable since Rust version 1.4.0\">1.4.0</span><h4 class=\"code-header\">pub fn <a class=\"fn\">get_mut</a>(this: &amp;mut Arc&lt;T, A&gt;) -&gt; Option&lt;&amp;mut T&gt;</h4></section></summary><div class=\"docblock\"><p>Returns a mutable reference into the given <code>Arc</code>, if there are\nno other <code>Arc</code> or [<code>Weak</code>] pointers to the same allocation.</p>\n<p>Returns [<code>None</code>] otherwise, because it is not safe to\nmutate a shared value.</p>\n<p>See also <a href=\"Arc::make_mut\"><code>make_mut</code></a>, which will <a href=\"Clone::clone\"><code>clone</code></a>\nthe inner value when there are other <code>Arc</code> pointers.</p>\n<h5 id=\"examples\"><a class=\"doc-anchor\" href=\"#examples\">Â§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::sync::Arc;\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>x = Arc::new(<span class=\"number\">3</span>);\n<span class=\"kw-2\">*</span>Arc::get_mut(<span class=\"kw-2\">&amp;mut </span>x).unwrap() = <span class=\"number\">4</span>;\n<span class=\"macro\">assert_eq!</span>(<span class=\"kw-2\">*</span>x, <span class=\"number\">4</span>);\n\n<span class=\"kw\">let </span>_y = Arc::clone(<span class=\"kw-2\">&amp;</span>x);\n<span class=\"macro\">assert!</span>(Arc::get_mut(<span class=\"kw-2\">&amp;mut </span>x).is_none());</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.get_mut_unchecked\" class=\"method\"><h4 class=\"code-header\">pub unsafe fn <a class=\"fn\">get_mut_unchecked</a>(this: &amp;mut Arc&lt;T, A&gt;) -&gt; &amp;mut T</h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>get_mut_unchecked</code>)</span></div></span></summary><div class=\"docblock\"><p>Returns a mutable reference into the given <code>Arc</code>,\nwithout any check.</p>\n<p>See also <a href=\"Arc::get_mut\"><code>get_mut</code></a>, which is safe and does appropriate checks.</p>\n<h5 id=\"safety\"><a class=\"doc-anchor\" href=\"#safety\">Â§</a>Safety</h5>\n<p>If any other <code>Arc</code> or [<code>Weak</code>] pointers to the same allocation exist, then\nthey must not be dereferenced or have active borrows for the duration\nof the returned borrow, and their inner type must be exactly the same as the\ninner type of this Rc (including lifetimes). This is trivially the case if no\nsuch pointers exist, for example immediately after <code>Arc::new</code>.</p>\n<h5 id=\"examples-1\"><a class=\"doc-anchor\" href=\"#examples-1\">Â§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(get_mut_unchecked)]\n\n</span><span class=\"kw\">use </span>std::sync::Arc;\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>x = Arc::new(String::new());\n<span class=\"kw\">unsafe </span>{\n    Arc::get_mut_unchecked(<span class=\"kw-2\">&amp;mut </span>x).push_str(<span class=\"string\">\"foo\"</span>)\n}\n<span class=\"macro\">assert_eq!</span>(<span class=\"kw-2\">*</span>x, <span class=\"string\">\"foo\"</span>);</code></pre></div>\n<p>Other <code>Arc</code> pointers to the same allocation must be to the same type.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(get_mut_unchecked)]\n\n</span><span class=\"kw\">use </span>std::sync::Arc;\n\n<span class=\"kw\">let </span>x: Arc&lt;str&gt; = Arc::from(<span class=\"string\">\"Hello, world!\"</span>);\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>y: Arc&lt;[u8]&gt; = x.clone().into();\n<span class=\"kw\">unsafe </span>{\n    <span class=\"comment\">// this is Undefined Behavior, because x's inner type is str, not [u8]\n    </span>Arc::get_mut_unchecked(<span class=\"kw-2\">&amp;mut </span>y).fill(<span class=\"number\">0xff</span>); <span class=\"comment\">// 0xff is invalid in UTF-8\n</span>}\n<span class=\"macro\">println!</span>(<span class=\"string\">\"{}\"</span>, <span class=\"kw-2\">&amp;*</span>x); <span class=\"comment\">// Invalid UTF-8 in a str</span></code></pre></div>\n<p>Other <code>Arc</code> pointers to the same allocation must be to the exact same type, including lifetimes.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(get_mut_unchecked)]\n\n</span><span class=\"kw\">use </span>std::sync::Arc;\n\n<span class=\"kw\">let </span>x: Arc&lt;<span class=\"kw-2\">&amp;</span>str&gt; = Arc::new(<span class=\"string\">\"Hello, world!\"</span>);\n{\n    <span class=\"kw\">let </span>s = String::from(<span class=\"string\">\"Oh, no!\"</span>);\n    <span class=\"kw\">let </span><span class=\"kw-2\">mut </span>y: Arc&lt;<span class=\"kw-2\">&amp;</span>str&gt; = x.clone().into();\n    <span class=\"kw\">unsafe </span>{\n        <span class=\"comment\">// this is Undefined Behavior, because x's inner type\n        // is &amp;'long str, not &amp;'short str\n        </span><span class=\"kw-2\">*</span>Arc::get_mut_unchecked(<span class=\"kw-2\">&amp;mut </span>y) = <span class=\"kw-2\">&amp;</span>s;\n    }\n}\n<span class=\"macro\">println!</span>(<span class=\"string\">\"{}\"</span>, <span class=\"kw-2\">&amp;*</span>x); <span class=\"comment\">// Use-after-free</span></code></pre></div>\n</div></details></div></details>",0,"rsiot::components::cmp_surrealdb::fn_process::Db"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Arc%3CT,+A%3E\" class=\"impl\"><a href=\"#impl-Arc%3CT,+A%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T, A&gt; Arc&lt;T, A&gt;<div class=\"where\">where\n    A: Allocator,\n    T: ?Sized,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.into_raw\" class=\"method\"><span class=\"since rightside\" title=\"Stable since Rust version 1.17.0\">1.17.0</span><h4 class=\"code-header\">pub fn <a class=\"fn\">into_raw</a>(this: Arc&lt;T, A&gt;) -&gt; *const T</h4></section></summary><div class=\"docblock\"><p>Consumes the <code>Arc</code>, returning the wrapped pointer.</p>\n<p>To avoid a memory leak the pointer must be converted back to an <code>Arc</code> using\n[<code>Arc::from_raw</code>].</p>\n<h5 id=\"examples\"><a class=\"doc-anchor\" href=\"#examples\">Â§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::sync::Arc;\n\n<span class=\"kw\">let </span>x = Arc::new(<span class=\"string\">\"hello\"</span>.to_owned());\n<span class=\"kw\">let </span>x_ptr = Arc::into_raw(x);\n<span class=\"macro\">assert_eq!</span>(<span class=\"kw\">unsafe </span>{ <span class=\"kw-2\">&amp;*</span>x_ptr }, <span class=\"string\">\"hello\"</span>);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.as_ptr\" class=\"method\"><span class=\"since rightside\" title=\"Stable since Rust version 1.45.0\">1.45.0</span><h4 class=\"code-header\">pub fn <a class=\"fn\">as_ptr</a>(this: &amp;Arc&lt;T, A&gt;) -&gt; *const T</h4></section></summary><div class=\"docblock\"><p>Provides a raw pointer to the data.</p>\n<p>The counts are not affected in any way and the <code>Arc</code> is not consumed. The pointer is valid for\nas long as there are strong counts in the <code>Arc</code>.</p>\n<h5 id=\"examples-1\"><a class=\"doc-anchor\" href=\"#examples-1\">Â§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::sync::Arc;\n\n<span class=\"kw\">let </span>x = Arc::new(<span class=\"string\">\"hello\"</span>.to_owned());\n<span class=\"kw\">let </span>y = Arc::clone(<span class=\"kw-2\">&amp;</span>x);\n<span class=\"kw\">let </span>x_ptr = Arc::as_ptr(<span class=\"kw-2\">&amp;</span>x);\n<span class=\"macro\">assert_eq!</span>(x_ptr, Arc::as_ptr(<span class=\"kw-2\">&amp;</span>y));\n<span class=\"macro\">assert_eq!</span>(<span class=\"kw\">unsafe </span>{ <span class=\"kw-2\">&amp;*</span>x_ptr }, <span class=\"string\">\"hello\"</span>);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.from_raw_in\" class=\"method\"><h4 class=\"code-header\">pub unsafe fn <a class=\"fn\">from_raw_in</a>(ptr: *const T, alloc: A) -&gt; Arc&lt;T, A&gt;</h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>allocator_api</code>)</span></div></span></summary><div class=\"docblock\"><p>Constructs an <code>Arc&lt;T, A&gt;</code> from a raw pointer.</p>\n<p>The raw pointer must have been previously returned by a call to <a href=\"Arc::into_raw\"><code>Arc&lt;U, A&gt;::into_raw</code></a> with the following requirements:</p>\n<ul>\n<li>If <code>U</code> is sized, it must have the same size and alignment as <code>T</code>. This\nis trivially true if <code>U</code> is <code>T</code>.</li>\n<li>If <code>U</code> is unsized, its data pointer must have the same size and\nalignment as <code>T</code>. This is trivially true if <code>Arc&lt;U&gt;</code> was constructed\nthrough <code>Arc&lt;T&gt;</code> and then converted to <code>Arc&lt;U&gt;</code> through an <a href=\"https://doc.rust-lang.org/reference/type-coercions.html#unsized-coercions\">unsized\ncoercion</a>.</li>\n</ul>\n<p>Note that if <code>U</code> or <code>U</code>â€™s data pointer is not <code>T</code> but has the same size\nand alignment, this is basically like transmuting references of\ndifferent types. See <a href=\"core::mem::transmute\"><code>mem::transmute</code></a> for more information\non what restrictions apply in this case.</p>\n<p>The raw pointer must point to a block of memory allocated by <code>alloc</code></p>\n<p>The user of <code>from_raw</code> has to make sure a specific value of <code>T</code> is only\ndropped once.</p>\n<p>This function is unsafe because improper use may lead to memory unsafety,\neven if the returned <code>Arc&lt;T&gt;</code> is never accessed.</p>\n<h5 id=\"examples-2\"><a class=\"doc-anchor\" href=\"#examples-2\">Â§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(allocator_api)]\n\n</span><span class=\"kw\">use </span>std::sync::Arc;\n<span class=\"kw\">use </span>std::alloc::System;\n\n<span class=\"kw\">let </span>x = Arc::new_in(<span class=\"string\">\"hello\"</span>.to_owned(), System);\n<span class=\"kw\">let </span>x_ptr = Arc::into_raw(x);\n\n<span class=\"kw\">unsafe </span>{\n    <span class=\"comment\">// Convert back to an `Arc` to prevent leak.\n    </span><span class=\"kw\">let </span>x = Arc::from_raw_in(x_ptr, System);\n    <span class=\"macro\">assert_eq!</span>(<span class=\"kw-2\">&amp;*</span>x, <span class=\"string\">\"hello\"</span>);\n\n    <span class=\"comment\">// Further calls to `Arc::from_raw(x_ptr)` would be memory-unsafe.\n</span>}\n\n<span class=\"comment\">// The memory was freed when `x` went out of scope above, so `x_ptr` is now dangling!</span></code></pre></div>\n<p>Convert a slice back into its original array:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(allocator_api)]\n\n</span><span class=\"kw\">use </span>std::sync::Arc;\n<span class=\"kw\">use </span>std::alloc::System;\n\n<span class=\"kw\">let </span>x: Arc&lt;[u32], <span class=\"kw\">_</span>&gt; = Arc::new_in([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>], System);\n<span class=\"kw\">let </span>x_ptr: <span class=\"kw-2\">*const </span>[u32] = Arc::into_raw(x);\n\n<span class=\"kw\">unsafe </span>{\n    <span class=\"kw\">let </span>x: Arc&lt;[u32; <span class=\"number\">3</span>], <span class=\"kw\">_</span>&gt; = Arc::from_raw_in(x_ptr.cast::&lt;[u32; <span class=\"number\">3</span>]&gt;(), System);\n    <span class=\"macro\">assert_eq!</span>(<span class=\"kw-2\">&amp;*</span>x, <span class=\"kw-2\">&amp;</span>[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]);\n}</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.downgrade\" class=\"method\"><span class=\"since rightside\" title=\"Stable since Rust version 1.4.0\">1.4.0</span><h4 class=\"code-header\">pub fn <a class=\"fn\">downgrade</a>(this: &amp;Arc&lt;T, A&gt;) -&gt; Weak&lt;T, A&gt;<div class=\"where\">where\n    A: Clone,</div></h4></section></summary><div class=\"docblock\"><p>Creates a new [<code>Weak</code>] pointer to this allocation.</p>\n<h5 id=\"examples-3\"><a class=\"doc-anchor\" href=\"#examples-3\">Â§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::sync::Arc;\n\n<span class=\"kw\">let </span>five = Arc::new(<span class=\"number\">5</span>);\n\n<span class=\"kw\">let </span>weak_five = Arc::downgrade(<span class=\"kw-2\">&amp;</span>five);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.weak_count\" class=\"method\"><span class=\"since rightside\" title=\"Stable since Rust version 1.15.0\">1.15.0</span><h4 class=\"code-header\">pub fn <a class=\"fn\">weak_count</a>(this: &amp;Arc&lt;T, A&gt;) -&gt; usize</h4></section></summary><div class=\"docblock\"><p>Gets the number of [<code>Weak</code>] pointers to this allocation.</p>\n<h5 id=\"safety\"><a class=\"doc-anchor\" href=\"#safety\">Â§</a>Safety</h5>\n<p>This method by itself is safe, but using it correctly requires extra care.\nAnother thread can change the weak count at any time,\nincluding potentially between calling this method and acting on the result.</p>\n<h5 id=\"examples-4\"><a class=\"doc-anchor\" href=\"#examples-4\">Â§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::sync::Arc;\n\n<span class=\"kw\">let </span>five = Arc::new(<span class=\"number\">5</span>);\n<span class=\"kw\">let </span>_weak_five = Arc::downgrade(<span class=\"kw-2\">&amp;</span>five);\n\n<span class=\"comment\">// This assertion is deterministic because we haven't shared\n// the `Arc` or `Weak` between threads.\n</span><span class=\"macro\">assert_eq!</span>(<span class=\"number\">1</span>, Arc::weak_count(<span class=\"kw-2\">&amp;</span>five));</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.strong_count\" class=\"method\"><span class=\"since rightside\" title=\"Stable since Rust version 1.15.0\">1.15.0</span><h4 class=\"code-header\">pub fn <a class=\"fn\">strong_count</a>(this: &amp;Arc&lt;T, A&gt;) -&gt; usize</h4></section></summary><div class=\"docblock\"><p>Gets the number of strong (<code>Arc</code>) pointers to this allocation.</p>\n<h5 id=\"safety-1\"><a class=\"doc-anchor\" href=\"#safety-1\">Â§</a>Safety</h5>\n<p>This method by itself is safe, but using it correctly requires extra care.\nAnother thread can change the strong count at any time,\nincluding potentially between calling this method and acting on the result.</p>\n<h5 id=\"examples-5\"><a class=\"doc-anchor\" href=\"#examples-5\">Â§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::sync::Arc;\n\n<span class=\"kw\">let </span>five = Arc::new(<span class=\"number\">5</span>);\n<span class=\"kw\">let </span>_also_five = Arc::clone(<span class=\"kw-2\">&amp;</span>five);\n\n<span class=\"comment\">// This assertion is deterministic because we haven't shared\n// the `Arc` between threads.\n</span><span class=\"macro\">assert_eq!</span>(<span class=\"number\">2</span>, Arc::strong_count(<span class=\"kw-2\">&amp;</span>five));</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.increment_strong_count_in\" class=\"method\"><h4 class=\"code-header\">pub unsafe fn <a class=\"fn\">increment_strong_count_in</a>(ptr: *const T, alloc: A)<div class=\"where\">where\n    A: Clone,</div></h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>allocator_api</code>)</span></div></span></summary><div class=\"docblock\"><p>Increments the strong reference count on the <code>Arc&lt;T&gt;</code> associated with the\nprovided pointer by one.</p>\n<h5 id=\"safety-2\"><a class=\"doc-anchor\" href=\"#safety-2\">Â§</a>Safety</h5>\n<p>The pointer must have been obtained through <code>Arc::into_raw</code>, and the\nassociated <code>Arc</code> instance must be valid (i.e. the strong count must be at\nleast 1) for the duration of this method,, and <code>ptr</code> must point to a block of memory\nallocated by <code>alloc</code>.</p>\n<h5 id=\"examples-6\"><a class=\"doc-anchor\" href=\"#examples-6\">Â§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(allocator_api)]\n\n</span><span class=\"kw\">use </span>std::sync::Arc;\n<span class=\"kw\">use </span>std::alloc::System;\n\n<span class=\"kw\">let </span>five = Arc::new_in(<span class=\"number\">5</span>, System);\n\n<span class=\"kw\">unsafe </span>{\n    <span class=\"kw\">let </span>ptr = Arc::into_raw(five);\n    Arc::increment_strong_count_in(ptr, System);\n\n    <span class=\"comment\">// This assertion is deterministic because we haven't shared\n    // the `Arc` between threads.\n    </span><span class=\"kw\">let </span>five = Arc::from_raw_in(ptr, System);\n    <span class=\"macro\">assert_eq!</span>(<span class=\"number\">2</span>, Arc::strong_count(<span class=\"kw-2\">&amp;</span>five));\n}</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.decrement_strong_count_in\" class=\"method\"><h4 class=\"code-header\">pub unsafe fn <a class=\"fn\">decrement_strong_count_in</a>(ptr: *const T, alloc: A)</h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>allocator_api</code>)</span></div></span></summary><div class=\"docblock\"><p>Decrements the strong reference count on the <code>Arc&lt;T&gt;</code> associated with the\nprovided pointer by one.</p>\n<h5 id=\"safety-3\"><a class=\"doc-anchor\" href=\"#safety-3\">Â§</a>Safety</h5>\n<p>The pointer must have been obtained through <code>Arc::into_raw</code>,  the\nassociated <code>Arc</code> instance must be valid (i.e. the strong count must be at\nleast 1) when invoking this method, and <code>ptr</code> must point to a block of memory\nallocated by <code>alloc</code>. This method can be used to release the final\n<code>Arc</code> and backing storage, but <strong>should not</strong> be called after the final <code>Arc</code> has been\nreleased.</p>\n<h5 id=\"examples-7\"><a class=\"doc-anchor\" href=\"#examples-7\">Â§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(allocator_api)]\n\n</span><span class=\"kw\">use </span>std::sync::Arc;\n<span class=\"kw\">use </span>std::alloc::System;\n\n<span class=\"kw\">let </span>five = Arc::new_in(<span class=\"number\">5</span>, System);\n\n<span class=\"kw\">unsafe </span>{\n    <span class=\"kw\">let </span>ptr = Arc::into_raw(five);\n    Arc::increment_strong_count_in(ptr, System);\n\n    <span class=\"comment\">// Those assertions are deterministic because we haven't shared\n    // the `Arc` between threads.\n    </span><span class=\"kw\">let </span>five = Arc::from_raw_in(ptr, System);\n    <span class=\"macro\">assert_eq!</span>(<span class=\"number\">2</span>, Arc::strong_count(<span class=\"kw-2\">&amp;</span>five));\n    Arc::decrement_strong_count_in(ptr, System);\n    <span class=\"macro\">assert_eq!</span>(<span class=\"number\">1</span>, Arc::strong_count(<span class=\"kw-2\">&amp;</span>five));\n}</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.ptr_eq\" class=\"method\"><span class=\"since rightside\" title=\"Stable since Rust version 1.17.0\">1.17.0</span><h4 class=\"code-header\">pub fn <a class=\"fn\">ptr_eq</a>(this: &amp;Arc&lt;T, A&gt;, other: &amp;Arc&lt;T, A&gt;) -&gt; bool</h4></section></summary><div class=\"docblock\"><p>Returns <code>true</code> if the two <code>Arc</code>s point to the same allocation in a vein similar to\n<a href=\"core::ptr::eq\" title=\"ptr::eq\"><code>ptr::eq</code></a>. This function ignores the metadata of  <code>dyn Trait</code> pointers.</p>\n<h5 id=\"examples-8\"><a class=\"doc-anchor\" href=\"#examples-8\">Â§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::sync::Arc;\n\n<span class=\"kw\">let </span>five = Arc::new(<span class=\"number\">5</span>);\n<span class=\"kw\">let </span>same_five = Arc::clone(<span class=\"kw-2\">&amp;</span>five);\n<span class=\"kw\">let </span>other_five = Arc::new(<span class=\"number\">5</span>);\n\n<span class=\"macro\">assert!</span>(Arc::ptr_eq(<span class=\"kw-2\">&amp;</span>five, <span class=\"kw-2\">&amp;</span>same_five));\n<span class=\"macro\">assert!</span>(!Arc::ptr_eq(<span class=\"kw-2\">&amp;</span>five, <span class=\"kw-2\">&amp;</span>other_five));</code></pre></div>\n</div></details></div></details>",0,"rsiot::components::cmp_surrealdb::fn_process::Db"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Arc%3CT,+A%3E\" class=\"impl\"><a href=\"#impl-Arc%3CT,+A%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T, A&gt; Arc&lt;T, A&gt;<div class=\"where\">where\n    T: Clone,\n    A: Allocator + Clone,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.make_mut\" class=\"method\"><span class=\"since rightside\" title=\"Stable since Rust version 1.4.0\">1.4.0</span><h4 class=\"code-header\">pub fn <a class=\"fn\">make_mut</a>(this: &amp;mut Arc&lt;T, A&gt;) -&gt; &amp;mut T</h4></section></summary><div class=\"docblock\"><p>Makes a mutable reference into the given <code>Arc</code>.</p>\n<p>If there are other <code>Arc</code> pointers to the same allocation, then <code>make_mut</code> will\n<a href=\"Clone::clone\"><code>clone</code></a> the inner value to a new allocation to ensure unique ownership.  This is also\nreferred to as clone-on-write.</p>\n<p>However, if there are no other <code>Arc</code> pointers to this allocation, but some [<code>Weak</code>]\npointers, then the [<code>Weak</code>] pointers will be dissociated and the inner value will not\nbe cloned.</p>\n<p>See also <a href=\"Arc::get_mut\"><code>get_mut</code></a>, which will fail rather than cloning the inner value\nor dissociating [<code>Weak</code>] pointers.</p>\n<h5 id=\"examples\"><a class=\"doc-anchor\" href=\"#examples\">Â§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::sync::Arc;\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>data = Arc::new(<span class=\"number\">5</span>);\n\n<span class=\"kw-2\">*</span>Arc::make_mut(<span class=\"kw-2\">&amp;mut </span>data) += <span class=\"number\">1</span>;         <span class=\"comment\">// Won't clone anything\n</span><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>other_data = Arc::clone(<span class=\"kw-2\">&amp;</span>data); <span class=\"comment\">// Won't clone inner data\n</span><span class=\"kw-2\">*</span>Arc::make_mut(<span class=\"kw-2\">&amp;mut </span>data) += <span class=\"number\">1</span>;         <span class=\"comment\">// Clones inner data\n</span><span class=\"kw-2\">*</span>Arc::make_mut(<span class=\"kw-2\">&amp;mut </span>data) += <span class=\"number\">1</span>;         <span class=\"comment\">// Won't clone anything\n</span><span class=\"kw-2\">*</span>Arc::make_mut(<span class=\"kw-2\">&amp;mut </span>other_data) <span class=\"kw-2\">*</span>= <span class=\"number\">2</span>;   <span class=\"comment\">// Won't clone anything\n\n// Now `data` and `other_data` point to different allocations.\n</span><span class=\"macro\">assert_eq!</span>(<span class=\"kw-2\">*</span>data, <span class=\"number\">8</span>);\n<span class=\"macro\">assert_eq!</span>(<span class=\"kw-2\">*</span>other_data, <span class=\"number\">12</span>);</code></pre></div>\n<p>[<code>Weak</code>] pointers will be dissociated:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::sync::Arc;\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>data = Arc::new(<span class=\"number\">75</span>);\n<span class=\"kw\">let </span>weak = Arc::downgrade(<span class=\"kw-2\">&amp;</span>data);\n\n<span class=\"macro\">assert!</span>(<span class=\"number\">75 </span>== <span class=\"kw-2\">*</span>data);\n<span class=\"macro\">assert!</span>(<span class=\"number\">75 </span>== <span class=\"kw-2\">*</span>weak.upgrade().unwrap());\n\n<span class=\"kw-2\">*</span>Arc::make_mut(<span class=\"kw-2\">&amp;mut </span>data) += <span class=\"number\">1</span>;\n\n<span class=\"macro\">assert!</span>(<span class=\"number\">76 </span>== <span class=\"kw-2\">*</span>data);\n<span class=\"macro\">assert!</span>(weak.upgrade().is_none());</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.unwrap_or_clone\" class=\"method\"><span class=\"since rightside\" title=\"Stable since Rust version 1.76.0\">1.76.0</span><h4 class=\"code-header\">pub fn <a class=\"fn\">unwrap_or_clone</a>(this: Arc&lt;T, A&gt;) -&gt; T</h4></section></summary><div class=\"docblock\"><p>If we have the only reference to <code>T</code> then unwrap it. Otherwise, clone <code>T</code> and return the\nclone.</p>\n<p>Assuming <code>arc_t</code> is of type <code>Arc&lt;T&gt;</code>, this function is functionally equivalent to\n<code>(*arc_t).clone()</code>, but will avoid cloning the inner value where possible.</p>\n<h5 id=\"examples-1\"><a class=\"doc-anchor\" href=\"#examples-1\">Â§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>inner = String::from(<span class=\"string\">\"test\"</span>);\n<span class=\"kw\">let </span>ptr = inner.as_ptr();\n\n<span class=\"kw\">let </span>arc = Arc::new(inner);\n<span class=\"kw\">let </span>inner = Arc::unwrap_or_clone(arc);\n<span class=\"comment\">// The inner value was not cloned\n</span><span class=\"macro\">assert!</span>(ptr::eq(ptr, inner.as_ptr()));\n\n<span class=\"kw\">let </span>arc = Arc::new(inner);\n<span class=\"kw\">let </span>arc2 = arc.clone();\n<span class=\"kw\">let </span>inner = Arc::unwrap_or_clone(arc);\n<span class=\"comment\">// Because there were 2 references, we had to clone the inner value.\n</span><span class=\"macro\">assert!</span>(!ptr::eq(ptr, inner.as_ptr()));\n<span class=\"comment\">// `arc2` is the last reference, so when we unwrap it we get back\n// the original `String`.\n</span><span class=\"kw\">let </span>inner = Arc::unwrap_or_clone(arc2);\n<span class=\"macro\">assert!</span>(ptr::eq(ptr, inner.as_ptr()));</code></pre></div>\n</div></details></div></details>",0,"rsiot::components::cmp_surrealdb::fn_process::Db"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-AsFd-for-Arc%3CT%3E\" class=\"impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.64.0\">1.64.0</span><a href=\"#impl-AsFd-for-Arc%3CT%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T&gt; AsFd for Arc&lt;T&gt;<div class=\"where\">where\n    T: AsFd + ?Sized,</div></h3></section></summary><div class=\"docblock\"><p>This impl allows implementing traits that require <code>AsFd</code> on Arc.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::net::UdpSocket;\n<span class=\"kw\">use </span>std::sync::Arc;\n\n<span class=\"kw\">trait </span>MyTrait: AsFd {}\n<span class=\"kw\">impl </span>MyTrait <span class=\"kw\">for </span>Arc&lt;UdpSocket&gt; {}\n<span class=\"kw\">impl </span>MyTrait <span class=\"kw\">for </span>Box&lt;UdpSocket&gt; {}</code></pre></div>\n</div><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.as_fd\" class=\"method trait-impl\"><a href=\"#method.as_fd\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">as_fd</a>(&amp;self) -&gt; BorrowedFd&lt;'_&gt;</h4></section></summary><div class='docblock'>Borrows the file descriptor. <a>Read more</a></div></details></div></details>","AsFd","rsiot::components::cmp_surrealdb::fn_process::Db"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-AsRawFd-for-Arc%3CT%3E\" class=\"impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.63.0\">1.63.0</span><a href=\"#impl-AsRawFd-for-Arc%3CT%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T&gt; AsRawFd for Arc&lt;T&gt;<div class=\"where\">where\n    T: AsRawFd,</div></h3></section></summary><div class=\"docblock\"><p>This impl allows implementing traits that require <code>AsRawFd</code> on Arc.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::net::UdpSocket;\n<span class=\"kw\">use </span>std::sync::Arc;\n<span class=\"kw\">trait </span>MyTrait: AsRawFd {\n}\n<span class=\"kw\">impl </span>MyTrait <span class=\"kw\">for </span>Arc&lt;UdpSocket&gt; {}\n<span class=\"kw\">impl </span>MyTrait <span class=\"kw\">for </span>Box&lt;UdpSocket&gt; {}</code></pre></div>\n</div><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.as_raw_fd\" class=\"method trait-impl\"><a href=\"#method.as_raw_fd\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">as_raw_fd</a>(&amp;self) -&gt; i32</h4></section></summary><div class='docblock'>Extracts the raw file descriptor. <a>Read more</a></div></details></div></details>","AsRawFd","rsiot::components::cmp_surrealdb::fn_process::Db"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-AsRawXcbConnection-for-Arc%3CT%3E\" class=\"impl\"><a href=\"#impl-AsRawXcbConnection-for-Arc%3CT%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T&gt; AsRawXcbConnection for Arc&lt;T&gt;<div class=\"where\">where\n    T: AsRawXcbConnection + ?Sized,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.as_raw_xcb_connection\" class=\"method trait-impl\"><a href=\"#method.as_raw_xcb_connection\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">as_raw_xcb_connection</a>(&amp;self) -&gt; *mut xcb_connection_t</h4></section></summary><div class='docblock'>Get a raw xcb connection pointer from this object.</div></details></div></details>","AsRawXcbConnection","rsiot::components::cmp_surrealdb::fn_process::Db"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-AsRef%3CT%3E-for-Arc%3CT,+A%3E\" class=\"impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.5.0\">1.5.0</span><a href=\"#impl-AsRef%3CT%3E-for-Arc%3CT,+A%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T, A&gt; AsRef&lt;T&gt; for Arc&lt;T, A&gt;<div class=\"where\">where\n    A: Allocator,\n    T: ?Sized,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.as_ref\" class=\"method trait-impl\"><a href=\"#method.as_ref\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">as_ref</a>(&amp;self) -&gt; &amp;T</h4></section></summary><div class='docblock'>Converts this type into a shared reference of the (usually inferred) input type.</div></details></div></details>","AsRef<T>","rsiot::components::cmp_surrealdb::fn_process::Db"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Borrow%3CT%3E-for-Arc%3CT,+A%3E\" class=\"impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.0.0\">1.0.0</span><a href=\"#impl-Borrow%3CT%3E-for-Arc%3CT,+A%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T, A&gt; Borrow&lt;T&gt; for Arc&lt;T, A&gt;<div class=\"where\">where\n    A: Allocator,\n    T: ?Sized,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.borrow\" class=\"method trait-impl\"><a href=\"#method.borrow\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">borrow</a>(&amp;self) -&gt; &amp;T</h4></section></summary><div class='docblock'>Immutably borrows from an owned value. <a>Read more</a></div></details></div></details>","Borrow<T>","rsiot::components::cmp_surrealdb::fn_process::Db"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Clone-for-Arc%3CT,+A%3E\" class=\"impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.0.0\">1.0.0</span><a href=\"#impl-Clone-for-Arc%3CT,+A%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T, A&gt; Clone for Arc&lt;T, A&gt;<div class=\"where\">where\n    A: Allocator + Clone,\n    T: ?Sized,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.clone\" class=\"method trait-impl\"><a href=\"#method.clone\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">clone</a>(&amp;self) -&gt; Arc&lt;T, A&gt;</h4></section></summary><div class=\"docblock\"><p>Makes a clone of the <code>Arc</code> pointer.</p>\n<p>This creates another pointer to the same allocation, increasing the\nstrong reference count.</p>\n<h5 id=\"examples\"><a class=\"doc-anchor\" href=\"#examples\">Â§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::sync::Arc;\n\n<span class=\"kw\">let </span>five = Arc::new(<span class=\"number\">5</span>);\n\n<span class=\"kw\">let _ </span>= Arc::clone(<span class=\"kw-2\">&amp;</span>five);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.clone_from\" class=\"method trait-impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.0.0\">1.0.0</span><a href=\"#method.clone_from\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">clone_from</a>(&amp;mut self, source: &amp;Self)</h4></section></summary><div class='docblock'>Performs copy-assignment from <code>source</code>. <a>Read more</a></div></details></div></details>","Clone","rsiot::components::cmp_surrealdb::fn_process::Db"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Connection-for-Arc%3CC%3E\" class=\"impl\"><a href=\"#impl-Connection-for-Arc%3CC%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;C&gt; Connection for Arc&lt;C&gt;<div class=\"where\">where\n    C: Connection + ?Sized,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.wait_for_event\" class=\"method trait-impl\"><a href=\"#method.wait_for_event\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">wait_for_event</a>(&amp;self) -&gt; Result&lt;Event, ConnectionError&gt;</h4></section></summary><div class='docblock'>Wait for a new event from the X11 server.</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.wait_for_raw_event\" class=\"method trait-impl\"><a href=\"#method.wait_for_raw_event\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">wait_for_raw_event</a>(\n    &amp;self\n) -&gt; Result&lt;&lt;Arc&lt;C&gt; as RequestConnection&gt;::Buf, ConnectionError&gt;</h4></section></summary><div class='docblock'>Wait for a new raw/unparsed event from the X11 server.</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.wait_for_event_with_sequence\" class=\"method trait-impl\"><a href=\"#method.wait_for_event_with_sequence\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">wait_for_event_with_sequence</a>(&amp;self) -&gt; Result&lt;(Event, u64), ConnectionError&gt;</h4></section></summary><div class='docblock'>Wait for a new event from the X11 server.</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.wait_for_raw_event_with_sequence\" class=\"method trait-impl\"><a href=\"#method.wait_for_raw_event_with_sequence\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">wait_for_raw_event_with_sequence</a>(\n    &amp;self\n) -&gt; Result&lt;(&lt;Arc&lt;C&gt; as RequestConnection&gt;::Buf, u64), ConnectionError&gt;</h4></section></summary><div class='docblock'>Wait for a new raw/unparsed event from the X11 server.</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.poll_for_event\" class=\"method trait-impl\"><a href=\"#method.poll_for_event\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">poll_for_event</a>(&amp;self) -&gt; Result&lt;Option&lt;Event&gt;, ConnectionError&gt;</h4></section></summary><div class='docblock'>Poll for a new event from the X11 server.</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.poll_for_raw_event\" class=\"method trait-impl\"><a href=\"#method.poll_for_raw_event\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">poll_for_raw_event</a>(\n    &amp;self\n) -&gt; Result&lt;Option&lt;&lt;Arc&lt;C&gt; as RequestConnection&gt;::Buf&gt;, ConnectionError&gt;</h4></section></summary><div class='docblock'>Poll for a new raw/unparsed event from the X11 server.</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.poll_for_event_with_sequence\" class=\"method trait-impl\"><a href=\"#method.poll_for_event_with_sequence\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">poll_for_event_with_sequence</a>(\n    &amp;self\n) -&gt; Result&lt;Option&lt;(Event, u64)&gt;, ConnectionError&gt;</h4></section></summary><div class='docblock'>Poll for a new event from the X11 server.</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.poll_for_raw_event_with_sequence\" class=\"method trait-impl\"><a href=\"#method.poll_for_raw_event_with_sequence\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">poll_for_raw_event_with_sequence</a>(\n    &amp;self\n) -&gt; Result&lt;Option&lt;(&lt;Arc&lt;C&gt; as RequestConnection&gt;::Buf, u64)&gt;, ConnectionError&gt;</h4></section></summary><div class='docblock'>Poll for a new unparsed/raw event from the X11 server.</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.flush\" class=\"method trait-impl\"><a href=\"#method.flush\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">flush</a>(&amp;self) -&gt; Result&lt;(), ConnectionError&gt;</h4></section></summary><div class='docblock'>Send all pending requests to the server. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.setup\" class=\"method trait-impl\"><a href=\"#method.setup\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">setup</a>(&amp;self) -&gt; &amp;Setup</h4></section></summary><div class='docblock'>Get the setup information sent by the X11 server. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.generate_id\" class=\"method trait-impl\"><a href=\"#method.generate_id\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">generate_id</a>(&amp;self) -&gt; Result&lt;u32, ReplyOrIdError&gt;</h4></section></summary><div class='docblock'>Generate a new X11 identifier. <a>Read more</a></div></details></div></details>","Connection","rsiot::components::cmp_surrealdb::fn_process::Db"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Cross-for-Arc%3CT%3E\" class=\"impl\"><a href=\"#impl-Cross-for-Arc%3CT%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T&gt; Cross for Arc&lt;T&gt;<div class=\"where\">where\n    T: Cross,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle\" open><summary><section id=\"associatedtype.Scalar\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Scalar\" class=\"anchor\">Â§</a><h4 class=\"code-header\">type <a class=\"associatedtype\">Scalar</a> = &lt;T as Cross&gt;::Scalar</h4></section></summary><div class='docblock'>Scalar used the coordinates.</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.line\" class=\"method trait-impl\"><a href=\"#method.line\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">line</a>(&amp;self) -&gt; LineOrPoint&lt;&lt;Arc&lt;T&gt; as Cross&gt;::Scalar&gt;</h4></section></summary><div class='docblock'>The geometry associated with this type. Use a <code>Line</code> with the\n<code>start</code> and <code>end</code> coordinates to represent a point.</div></details></div></details>","Cross","rsiot::components::cmp_surrealdb::fn_process::Db"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Cross-for-Arc%3CT%3E\" class=\"impl\"><a href=\"#impl-Cross-for-Arc%3CT%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T&gt; Cross for Arc&lt;T&gt;<div class=\"where\">where\n    T: Cross,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle\" open><summary><section id=\"associatedtype.Scalar\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Scalar\" class=\"anchor\">Â§</a><h4 class=\"code-header\">type <a class=\"associatedtype\">Scalar</a> = &lt;T as Cross&gt;::Scalar</h4></section></summary><div class='docblock'>Scalar used the coordinates.</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.line\" class=\"method trait-impl\"><a href=\"#method.line\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">line</a>(&amp;self) -&gt; LineOrPoint&lt;&lt;Arc&lt;T&gt; as Cross&gt;::Scalar&gt;</h4></section></summary><div class='docblock'>The geometry associated with this type. Use a <code>Line</code> with the\n<code>start</code> and <code>end</code> coordinates to represent a point.</div></details></div></details>","Cross","rsiot::components::cmp_surrealdb::fn_process::Db"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Debug-for-Arc%3CT,+A%3E\" class=\"impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.0.0\">1.0.0</span><a href=\"#impl-Debug-for-Arc%3CT,+A%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T, A&gt; Debug for Arc&lt;T, A&gt;<div class=\"where\">where\n    T: Debug + ?Sized,\n    A: Allocator,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.fmt\" class=\"method trait-impl\"><a href=\"#method.fmt\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">fmt</a>(&amp;self, f: &amp;mut Formatter&lt;'_&gt;) -&gt; Result&lt;(), Error&gt;</h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a>Read more</a></div></details></div></details>","Debug","rsiot::components::cmp_surrealdb::fn_process::Db"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Default-for-Arc%3CT%3E\" class=\"impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.0.0\">1.0.0</span><a href=\"#impl-Default-for-Arc%3CT%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T&gt; Default for Arc&lt;T&gt;<div class=\"where\">where\n    T: Default,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.default\" class=\"method trait-impl\"><a href=\"#method.default\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">default</a>() -&gt; Arc&lt;T&gt;</h4></section></summary><div class=\"docblock\"><p>Creates a new <code>Arc&lt;T&gt;</code>, with the <code>Default</code> value for <code>T</code>.</p>\n<h5 id=\"examples\"><a class=\"doc-anchor\" href=\"#examples\">Â§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::sync::Arc;\n\n<span class=\"kw\">let </span>x: Arc&lt;i32&gt; = Default::default();\n<span class=\"macro\">assert_eq!</span>(<span class=\"kw-2\">*</span>x, <span class=\"number\">0</span>);</code></pre></div>\n</div></details></div></details>","Default","rsiot::components::cmp_surrealdb::fn_process::Db"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Deref-for-Arc%3CT,+A%3E\" class=\"impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.0.0\">1.0.0</span><a href=\"#impl-Deref-for-Arc%3CT,+A%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T, A&gt; Deref for Arc&lt;T, A&gt;<div class=\"where\">where\n    A: Allocator,\n    T: ?Sized,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle\" open><summary><section id=\"associatedtype.Target\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Target\" class=\"anchor\">Â§</a><h4 class=\"code-header\">type <a class=\"associatedtype\">Target</a> = T</h4></section></summary><div class='docblock'>The resulting type after dereferencing.</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.deref\" class=\"method trait-impl\"><a href=\"#method.deref\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">deref</a>(&amp;self) -&gt; &amp;T</h4></section></summary><div class='docblock'>Dereferences the value.</div></details></div></details>","Deref","rsiot::components::cmp_surrealdb::fn_process::Db"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Deserialize%3C'de%3E-for-Arc%3CT%3E\" class=\"impl\"><a class=\"src rightside\" href=\"https://docs.rs/serde/1.0.198/src/serde/de/impls.rs.html#2080-2091\">source</a><a href=\"#impl-Deserialize%3C'de%3E-for-Arc%3CT%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;'de, T&gt; <a class=\"trait\" href=\"rsiot/message/trait.Deserialize.html\" title=\"trait rsiot::message::Deserialize\">Deserialize</a>&lt;'de&gt; for Arc&lt;T&gt;<div class=\"where\">where\n    Box&lt;T&gt;: <a class=\"trait\" href=\"rsiot/message/trait.Deserialize.html\" title=\"trait rsiot::message::Deserialize\">Deserialize</a>&lt;'de&gt;,\n    T: ?Sized,</div></h3></section></summary><div class=\"docblock\"><p>This impl requires the <a href=\"https://serde.rs/feature-flags.html#-features-rc\"><code>&quot;rc&quot;</code></a> Cargo feature of Serde.</p>\n<p>Deserializing a data structure containing <code>Arc</code> will not attempt to\ndeduplicate <code>Arc</code> references to the same data. Every deserialized <code>Arc</code>\nwill end up with a strong count of 1.</p>\n</div><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.deserialize\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://docs.rs/serde/1.0.198/src/serde/de/impls.rs.html#2080-2091\">source</a><a href=\"#method.deserialize\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a href=\"rsiot/message/trait.Deserialize.html#tymethod.deserialize\" class=\"fn\">deserialize</a>&lt;D&gt;(\n    deserializer: D\n) -&gt; Result&lt;Arc&lt;T&gt;, &lt;D as <a class=\"trait\" href=\"https://docs.rs/serde/1.0.198/serde/de/trait.Deserializer.html\" title=\"trait serde::de::Deserializer\">Deserializer</a>&lt;'de&gt;&gt;::<a class=\"associatedtype\" href=\"https://docs.rs/serde/1.0.198/serde/de/trait.Deserializer.html#associatedtype.Error\" title=\"type serde::de::Deserializer::Error\">Error</a>&gt;<div class=\"where\">where\n    D: <a class=\"trait\" href=\"https://docs.rs/serde/1.0.198/serde/de/trait.Deserializer.html\" title=\"trait serde::de::Deserializer\">Deserializer</a>&lt;'de&gt;,</div></h4></section></summary><div class='docblock'>Deserialize this value from the given Serde deserializer. <a href=\"rsiot/message/trait.Deserialize.html#tymethod.deserialize\">Read more</a></div></details></div></details>","Deserialize<'de>","rsiot::components::cmp_surrealdb::fn_process::Db"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-DeserializeAs%3C'de,+Arc%3CT%3E%3E-for-Arc%3CU%3E\" class=\"impl\"><a class=\"src rightside\" href=\"https://docs.rs/serde_with/3.7.0/src/serde_with/de/impls.rs.html#225-227\">source</a><a href=\"#impl-DeserializeAs%3C'de,+Arc%3CT%3E%3E-for-Arc%3CU%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;'de, T, U&gt; <a class=\"trait\" href=\"https://docs.rs/serde_with/3.7.0/serde_with/de/trait.DeserializeAs.html\" title=\"trait serde_with::de::DeserializeAs\">DeserializeAs</a>&lt;'de, Arc&lt;T&gt;&gt; for Arc&lt;U&gt;<div class=\"where\">where\n    U: <a class=\"trait\" href=\"https://docs.rs/serde_with/3.7.0/serde_with/de/trait.DeserializeAs.html\" title=\"trait serde_with::de::DeserializeAs\">DeserializeAs</a>&lt;'de, T&gt;,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.deserialize_as\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://docs.rs/serde_with/3.7.0/src/serde_with/de/impls.rs.html#229-231\">source</a><a href=\"#method.deserialize_as\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a href=\"https://docs.rs/serde_with/3.7.0/serde_with/de/trait.DeserializeAs.html#tymethod.deserialize_as\" class=\"fn\">deserialize_as</a>&lt;D&gt;(\n    deserializer: D\n) -&gt; Result&lt;Arc&lt;T&gt;, &lt;D as <a class=\"trait\" href=\"https://docs.rs/serde/1.0.198/serde/de/trait.Deserializer.html\" title=\"trait serde::de::Deserializer\">Deserializer</a>&lt;'de&gt;&gt;::<a class=\"associatedtype\" href=\"https://docs.rs/serde/1.0.198/serde/de/trait.Deserializer.html#associatedtype.Error\" title=\"type serde::de::Deserializer::Error\">Error</a>&gt;<div class=\"where\">where\n    D: <a class=\"trait\" href=\"https://docs.rs/serde/1.0.198/serde/de/trait.Deserializer.html\" title=\"trait serde::de::Deserializer\">Deserializer</a>&lt;'de&gt;,</div></h4></section></summary><div class='docblock'>Deserialize this value from the given Serde deserializer.</div></details></div></details>","DeserializeAs<'de, Arc<T>>","rsiot::components::cmp_surrealdb::fn_process::Db"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Display-for-Arc%3CT,+A%3E\" class=\"impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.0.0\">1.0.0</span><a href=\"#impl-Display-for-Arc%3CT,+A%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T, A&gt; Display for Arc&lt;T, A&gt;<div class=\"where\">where\n    T: Display + ?Sized,\n    A: Allocator,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.fmt\" class=\"method trait-impl\"><a href=\"#method.fmt\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">fmt</a>(&amp;self, f: &amp;mut Formatter&lt;'_&gt;) -&gt; Result&lt;(), Error&gt;</h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a>Read more</a></div></details></div></details>","Display","rsiot::components::cmp_surrealdb::fn_process::Db"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Drop-for-Arc%3CT,+A%3E\" class=\"impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.0.0\">1.0.0</span><a href=\"#impl-Drop-for-Arc%3CT,+A%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T, A&gt; Drop for Arc&lt;T, A&gt;<div class=\"where\">where\n    A: Allocator,\n    T: ?Sized,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.drop\" class=\"method trait-impl\"><a href=\"#method.drop\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">drop</a>(&amp;mut self)</h4></section></summary><div class=\"docblock\"><p>Drops the <code>Arc</code>.</p>\n<p>This will decrement the strong reference count. If the strong reference\ncount reaches zero then the only other references (if any) are\n[<code>Weak</code>], so we <code>drop</code> the inner value.</p>\n<h5 id=\"examples\"><a class=\"doc-anchor\" href=\"#examples\">Â§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::sync::Arc;\n\n<span class=\"kw\">struct </span>Foo;\n\n<span class=\"kw\">impl </span>Drop <span class=\"kw\">for </span>Foo {\n    <span class=\"kw\">fn </span>drop(<span class=\"kw-2\">&amp;mut </span><span class=\"self\">self</span>) {\n        <span class=\"macro\">println!</span>(<span class=\"string\">\"dropped!\"</span>);\n    }\n}\n\n<span class=\"kw\">let </span>foo  = Arc::new(Foo);\n<span class=\"kw\">let </span>foo2 = Arc::clone(<span class=\"kw-2\">&amp;</span>foo);\n\ndrop(foo);    <span class=\"comment\">// Doesn't print anything\n</span>drop(foo2);   <span class=\"comment\">// Prints \"dropped!\"</span></code></pre></div>\n</div></details></div></details>","Drop","rsiot::components::cmp_surrealdb::fn_process::Db"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Error-for-Arc%3CT%3E\" class=\"impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.52.0\">1.52.0</span><a href=\"#impl-Error-for-Arc%3CT%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T&gt; Error for Arc&lt;T&gt;<div class=\"where\">where\n    T: Error + ?Sized,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.description\" class=\"method trait-impl\"><a href=\"#method.description\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">description</a>(&amp;self) -&gt; &amp;str</h4></section></summary><span class=\"item-info\"><div class=\"stab deprecated\"><span class=\"emoji\">ðŸ‘Ž</span><span>Deprecated since 1.42.0: use the Display impl or to_string()</span></div></span><div class='docblock'> <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.cause\" class=\"method trait-impl\"><a href=\"#method.cause\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">cause</a>(&amp;self) -&gt; Option&lt;&amp;dyn Error&gt;</h4></section></summary><span class=\"item-info\"><div class=\"stab deprecated\"><span class=\"emoji\">ðŸ‘Ž</span><span>Deprecated since 1.33.0: replaced by Error::source, which can support downcasting</span></div></span></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.source\" class=\"method trait-impl\"><a href=\"#method.source\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">source</a>(&amp;self) -&gt; Option&lt;&amp;(dyn Error + 'static)&gt;</h4></section></summary><div class='docblock'>The lower-level source of this error, if any. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.provide\" class=\"method trait-impl\"><a href=\"#method.provide\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">provide</a>&lt;'a&gt;(&amp;'a self, req: &amp;mut Request&lt;'a&gt;)</h4></section></summary><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>error_generic_member_access</code>)</span></div></span><div class='docblock'>Provides type based access to context intended for error reports. <a>Read more</a></div></details></div></details>","Error","rsiot::components::cmp_surrealdb::fn_process::Db"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-From%3CBox%3CT,+A%3E%3E-for-Arc%3CT,+A%3E\" class=\"impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.21.0\">1.21.0</span><a href=\"#impl-From%3CBox%3CT,+A%3E%3E-for-Arc%3CT,+A%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T, A&gt; From&lt;Box&lt;T, A&gt;&gt; for Arc&lt;T, A&gt;<div class=\"where\">where\n    A: Allocator,\n    T: ?Sized,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.from\" class=\"method trait-impl\"><a href=\"#method.from\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">from</a>(v: Box&lt;T, A&gt;) -&gt; Arc&lt;T, A&gt;</h4></section></summary><div class=\"docblock\"><p>Move a boxed object to a new, reference-counted allocation.</p>\n<h5 id=\"example\"><a class=\"doc-anchor\" href=\"#example\">Â§</a>Example</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>unique: Box&lt;str&gt; = Box::from(<span class=\"string\">\"eggplant\"</span>);\n<span class=\"kw\">let </span>shared: Arc&lt;str&gt; = Arc::from(unique);\n<span class=\"macro\">assert_eq!</span>(<span class=\"string\">\"eggplant\"</span>, <span class=\"kw-2\">&amp;</span>shared[..]);</code></pre></div>\n</div></details></div></details>","From<Box<T, A>>","rsiot::components::cmp_surrealdb::fn_process::Db"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-From%3CCow%3C'a,+B%3E%3E-for-Arc%3CB%3E\" class=\"impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.45.0\">1.45.0</span><a href=\"#impl-From%3CCow%3C'a,+B%3E%3E-for-Arc%3CB%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;'a, B&gt; From&lt;Cow&lt;'a, B&gt;&gt; for Arc&lt;B&gt;<div class=\"where\">where\n    B: ToOwned + ?Sized,\n    Arc&lt;B&gt;: From&lt;&amp;'a B&gt; + From&lt;&lt;B as ToOwned&gt;::Owned&gt;,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.from\" class=\"method trait-impl\"><a href=\"#method.from\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">from</a>(cow: Cow&lt;'a, B&gt;) -&gt; Arc&lt;B&gt;</h4></section></summary><div class=\"docblock\"><p>Create an atomically reference-counted pointer from\na clone-on-write pointer by copying its content.</p>\n<h5 id=\"example\"><a class=\"doc-anchor\" href=\"#example\">Â§</a>Example</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>cow: Cow&lt;<span class=\"lifetime\">'_</span>, str&gt; = Cow::Borrowed(<span class=\"string\">\"eggplant\"</span>);\n<span class=\"kw\">let </span>shared: Arc&lt;str&gt; = Arc::from(cow);\n<span class=\"macro\">assert_eq!</span>(<span class=\"string\">\"eggplant\"</span>, <span class=\"kw-2\">&amp;</span>shared[..]);</code></pre></div>\n</div></details></div></details>","From<Cow<'a, B>>","rsiot::components::cmp_surrealdb::fn_process::Db"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-From%3CT%3E-for-Arc%3CT%3E\" class=\"impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.6.0\">1.6.0</span><a href=\"#impl-From%3CT%3E-for-Arc%3CT%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T&gt; From&lt;T&gt; for Arc&lt;T&gt;</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.from\" class=\"method trait-impl\"><a href=\"#method.from\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">from</a>(t: T) -&gt; Arc&lt;T&gt;</h4></section></summary><div class=\"docblock\"><p>Converts a <code>T</code> into an <code>Arc&lt;T&gt;</code></p>\n<p>The conversion moves the value into a\nnewly allocated <code>Arc</code>. It is equivalent to\ncalling <code>Arc::new(t)</code>.</p>\n<h5 id=\"example\"><a class=\"doc-anchor\" href=\"#example\">Â§</a>Example</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>x = <span class=\"number\">5</span>;\n<span class=\"kw\">let </span>arc = Arc::new(<span class=\"number\">5</span>);\n\n<span class=\"macro\">assert_eq!</span>(Arc::from(x), arc);</code></pre></div>\n</div></details></div></details>","From<T>","rsiot::components::cmp_surrealdb::fn_process::Db"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-HasDisplayHandle-for-Arc%3CH%3E\" class=\"impl\"><a href=\"#impl-HasDisplayHandle-for-Arc%3CH%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;H&gt; HasDisplayHandle for Arc&lt;H&gt;<div class=\"where\">where\n    H: HasDisplayHandle + ?Sized,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.display_handle\" class=\"method trait-impl\"><a href=\"#method.display_handle\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">display_handle</a>(&amp;self) -&gt; Result&lt;DisplayHandle&lt;'_&gt;, HandleError&gt;</h4></section></summary><div class='docblock'>Get a handle to the display controller of the windowing system.</div></details></div></details>","HasDisplayHandle","rsiot::components::cmp_surrealdb::fn_process::Db"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-HasDisplayHandle-for-Arc%3CH%3E\" class=\"impl\"><a href=\"#impl-HasDisplayHandle-for-Arc%3CH%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;H&gt; HasDisplayHandle for Arc&lt;H&gt;<div class=\"where\">where\n    H: HasDisplayHandle + ?Sized,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.display_handle\" class=\"method trait-impl\"><a href=\"#method.display_handle\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">display_handle</a>(&amp;self) -&gt; Result&lt;DisplayHandle&lt;'_&gt;, HandleError&gt;</h4></section></summary><div class='docblock'>Get a handle to the display controller of the windowing system.</div></details></div></details>","HasDisplayHandle","rsiot::components::cmp_surrealdb::fn_process::Db"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-HasRawDisplayHandle-for-Arc%3CT%3E\" class=\"impl\"><a href=\"#impl-HasRawDisplayHandle-for-Arc%3CT%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T&gt; HasRawDisplayHandle for Arc&lt;T&gt;<div class=\"where\">where\n    T: HasRawDisplayHandle + ?Sized,</div></h3></section></summary><div class=\"impl-items\"><section id=\"method.raw_display_handle\" class=\"method trait-impl\"><a href=\"#method.raw_display_handle\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">raw_display_handle</a>(&amp;self) -&gt; RawDisplayHandle</h4></section></div></details>","HasRawDisplayHandle","rsiot::components::cmp_surrealdb::fn_process::Db"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-HasRawWindowHandle-for-Arc%3CT%3E\" class=\"impl\"><a href=\"#impl-HasRawWindowHandle-for-Arc%3CT%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T&gt; HasRawWindowHandle for Arc&lt;T&gt;<div class=\"where\">where\n    T: HasRawWindowHandle + ?Sized,</div></h3></section></summary><div class=\"impl-items\"><section id=\"method.raw_window_handle\" class=\"method trait-impl\"><a href=\"#method.raw_window_handle\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">raw_window_handle</a>(&amp;self) -&gt; RawWindowHandle</h4></section></div></details>","HasRawWindowHandle","rsiot::components::cmp_surrealdb::fn_process::Db"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-HasWindowHandle-for-Arc%3CH%3E\" class=\"impl\"><a href=\"#impl-HasWindowHandle-for-Arc%3CH%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;H&gt; HasWindowHandle for Arc&lt;H&gt;<div class=\"where\">where\n    H: HasWindowHandle + ?Sized,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.window_handle\" class=\"method trait-impl\"><a href=\"#method.window_handle\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">window_handle</a>(&amp;self) -&gt; Result&lt;WindowHandle&lt;'_&gt;, HandleError&gt;</h4></section></summary><div class='docblock'>Get a handle to the window.</div></details></div></details>","HasWindowHandle","rsiot::components::cmp_surrealdb::fn_process::Db"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-HasWindowHandle-for-Arc%3CH%3E\" class=\"impl\"><a href=\"#impl-HasWindowHandle-for-Arc%3CH%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;H&gt; HasWindowHandle for Arc&lt;H&gt;<div class=\"where\">where\n    H: HasWindowHandle + ?Sized,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.window_handle\" class=\"method trait-impl\"><a href=\"#method.window_handle\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">window_handle</a>(&amp;self) -&gt; Result&lt;WindowHandle&lt;'_&gt;, HandleError&gt;</h4></section></summary><div class='docblock'>Get a handle to the window.</div></details></div></details>","HasWindowHandle","rsiot::components::cmp_surrealdb::fn_process::Db"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Hash-for-Arc%3CT,+A%3E\" class=\"impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.0.0\">1.0.0</span><a href=\"#impl-Hash-for-Arc%3CT,+A%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T, A&gt; Hash for Arc&lt;T, A&gt;<div class=\"where\">where\n    T: Hash + ?Sized,\n    A: Allocator,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.hash\" class=\"method trait-impl\"><a href=\"#method.hash\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">hash</a>&lt;H&gt;(&amp;self, state: &amp;mut H)<div class=\"where\">where\n    H: Hasher,</div></h4></section></summary><div class='docblock'>Feeds this value into the given [<code>Hasher</code>]. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.hash_slice\" class=\"method trait-impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.3.0\">1.3.0</span><a href=\"#method.hash_slice\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">hash_slice</a>&lt;H&gt;(data: &amp;[Self], state: &amp;mut H)<div class=\"where\">where\n    H: Hasher,\n    Self: Sized,</div></h4></section></summary><div class='docblock'>Feeds a slice of this type into the given [<code>Hasher</code>]. <a>Read more</a></div></details></div></details>","Hash","rsiot::components::cmp_surrealdb::fn_process::Db"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-LocalSpawn-for-Arc%3CSp%3E\" class=\"impl\"><a href=\"#impl-LocalSpawn-for-Arc%3CSp%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;Sp&gt; LocalSpawn for Arc&lt;Sp&gt;<div class=\"where\">where\n    Sp: LocalSpawn + ?Sized,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.spawn_local_obj\" class=\"method trait-impl\"><a href=\"#method.spawn_local_obj\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">spawn_local_obj</a>(\n    &amp;self,\n    future: LocalFutureObj&lt;'static, ()&gt;\n) -&gt; Result&lt;(), SpawnError&gt;</h4></section></summary><div class='docblock'>Spawns a future that will be run to completion. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.status_local\" class=\"method trait-impl\"><a href=\"#method.status_local\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">status_local</a>(&amp;self) -&gt; Result&lt;(), SpawnError&gt;</h4></section></summary><div class='docblock'>Determines whether the executor is able to spawn new tasks. <a>Read more</a></div></details></div></details>","LocalSpawn","rsiot::components::cmp_surrealdb::fn_process::Db"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Log-for-Arc%3CT%3E\" class=\"impl\"><a class=\"src rightside\" href=\"https://docs.rs/log/0.4.21/src/log/lib.rs.html#1201-1203\">source</a><a href=\"#impl-Log-for-Arc%3CT%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"https://docs.rs/log/0.4.21/log/trait.Log.html\" title=\"trait log::Log\">Log</a> for Arc&lt;T&gt;<div class=\"where\">where\n    T: <a class=\"trait\" href=\"https://docs.rs/log/0.4.21/log/trait.Log.html\" title=\"trait log::Log\">Log</a> + ?Sized,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.enabled\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://docs.rs/log/0.4.21/src/log/lib.rs.html#1205\">source</a><a href=\"#method.enabled\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a href=\"https://docs.rs/log/0.4.21/log/trait.Log.html#tymethod.enabled\" class=\"fn\">enabled</a>(&amp;self, metadata: &amp;<a class=\"struct\" href=\"https://docs.rs/log/0.4.21/log/struct.Metadata.html\" title=\"struct log::Metadata\">Metadata</a>&lt;'_&gt;) -&gt; bool</h4></section></summary><div class='docblock'>Determines if a log message with the specified metadata would be\nlogged. <a href=\"https://docs.rs/log/0.4.21/log/trait.Log.html#tymethod.enabled\">Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.log\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://docs.rs/log/0.4.21/src/log/lib.rs.html#1209\">source</a><a href=\"#method.log\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a href=\"https://docs.rs/log/0.4.21/log/trait.Log.html#tymethod.log\" class=\"fn\">log</a>(&amp;self, record: &amp;<a class=\"struct\" href=\"https://docs.rs/log/0.4.21/log/struct.Record.html\" title=\"struct log::Record\">Record</a>&lt;'_&gt;)</h4></section></summary><div class='docblock'>Logs the <code>Record</code>. <a href=\"https://docs.rs/log/0.4.21/log/trait.Log.html#tymethod.log\">Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.flush\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://docs.rs/log/0.4.21/src/log/lib.rs.html#1212\">source</a><a href=\"#method.flush\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a href=\"https://docs.rs/log/0.4.21/log/trait.Log.html#tymethod.flush\" class=\"fn\">flush</a>(&amp;self)</h4></section></summary><div class='docblock'>Flushes any buffered records.</div></details></div></details>","Log","rsiot::components::cmp_surrealdb::fn_process::Db"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-MakeWriter%3C'a%3E-for-Arc%3CW%3E\" class=\"impl\"><a href=\"#impl-MakeWriter%3C'a%3E-for-Arc%3CW%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;'a, W&gt; MakeWriter&lt;'a&gt; for Arc&lt;W&gt;<div class=\"where\">where\n    &amp;'a W: Write + 'a,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle\" open><summary><section id=\"associatedtype.Writer\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Writer\" class=\"anchor\">Â§</a><h4 class=\"code-header\">type <a class=\"associatedtype\">Writer</a> = &amp;'a W</h4></section></summary><div class='docblock'>The concrete <a href=\"std::io::Write\"><code>io::Write</code></a> implementation returned by <a href=\"MakeWriter::make_writer\"><code>make_writer</code></a>.</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.make_writer\" class=\"method trait-impl\"><a href=\"#method.make_writer\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">make_writer</a>(&amp;'a self) -&gt; &lt;Arc&lt;W&gt; as MakeWriter&lt;'a&gt;&gt;::Writer <a href=\"#\" class=\"tooltip\" data-notable-ty=\"&lt;Arc&lt;W&gt; as MakeWriter&lt;&#39;a&gt;&gt;::Writer\">â“˜</a></h4></section></summary><div class='docblock'>Returns an instance of <a href=\"MakeWriter::Writer\"><code>Writer</code></a>. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.make_writer_for\" class=\"method trait-impl\"><a href=\"#method.make_writer_for\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">make_writer_for</a>(&amp;'a self, meta: &amp;Metadata&lt;'_&gt;) -&gt; Self::Writer</h4></section></summary><div class='docblock'>Returns a <a href=\"MakeWriter::Writer\"><code>Writer</code></a> for writing data from the span or event described\nby the provided <a href=\"tracing_core::Metadata\"><code>Metadata</code></a>. <a>Read more</a></div></details></div></details>","MakeWriter<'a>","rsiot::components::cmp_surrealdb::fn_process::Db"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Ord-for-Arc%3CT,+A%3E\" class=\"impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.0.0\">1.0.0</span><a href=\"#impl-Ord-for-Arc%3CT,+A%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T, A&gt; Ord for Arc&lt;T, A&gt;<div class=\"where\">where\n    T: Ord + ?Sized,\n    A: Allocator,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.cmp\" class=\"method trait-impl\"><a href=\"#method.cmp\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">cmp</a>(&amp;self, other: &amp;Arc&lt;T, A&gt;) -&gt; Ordering</h4></section></summary><div class=\"docblock\"><p>Comparison for two <code>Arc</code>s.</p>\n<p>The two are compared by calling <code>cmp()</code> on their inner values.</p>\n<h5 id=\"examples\"><a class=\"doc-anchor\" href=\"#examples\">Â§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::sync::Arc;\n<span class=\"kw\">use </span>std::cmp::Ordering;\n\n<span class=\"kw\">let </span>five = Arc::new(<span class=\"number\">5</span>);\n\n<span class=\"macro\">assert_eq!</span>(Ordering::Less, five.cmp(<span class=\"kw-2\">&amp;</span>Arc::new(<span class=\"number\">6</span>)));</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.max\" class=\"method trait-impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.21.0\">1.21.0</span><a href=\"#method.max\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">max</a>(self, other: Self) -&gt; Self<div class=\"where\">where\n    Self: Sized,</div></h4></section></summary><div class='docblock'>Compares and returns the maximum of two values. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.min\" class=\"method trait-impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.21.0\">1.21.0</span><a href=\"#method.min\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">min</a>(self, other: Self) -&gt; Self<div class=\"where\">where\n    Self: Sized,</div></h4></section></summary><div class='docblock'>Compares and returns the minimum of two values. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.clamp\" class=\"method trait-impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.50.0\">1.50.0</span><a href=\"#method.clamp\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">clamp</a>(self, min: Self, max: Self) -&gt; Self<div class=\"where\">where\n    Self: Sized + PartialOrd,</div></h4></section></summary><div class='docblock'>Restrict a value to a certain interval. <a>Read more</a></div></details></div></details>","Ord","rsiot::components::cmp_surrealdb::fn_process::Db"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-PartialEq-for-Arc%3CT,+A%3E\" class=\"impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.0.0\">1.0.0</span><a href=\"#impl-PartialEq-for-Arc%3CT,+A%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T, A&gt; PartialEq for Arc&lt;T, A&gt;<div class=\"where\">where\n    T: PartialEq + ?Sized,\n    A: Allocator,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.eq\" class=\"method trait-impl\"><a href=\"#method.eq\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">eq</a>(&amp;self, other: &amp;Arc&lt;T, A&gt;) -&gt; bool</h4></section></summary><div class=\"docblock\"><p>Equality for two <code>Arc</code>s.</p>\n<p>Two <code>Arc</code>s are equal if their inner values are equal, even if they are\nstored in different allocation.</p>\n<p>If <code>T</code> also implements <code>Eq</code> (implying reflexivity of equality),\ntwo <code>Arc</code>s that point to the same allocation are always equal.</p>\n<h5 id=\"examples\"><a class=\"doc-anchor\" href=\"#examples\">Â§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::sync::Arc;\n\n<span class=\"kw\">let </span>five = Arc::new(<span class=\"number\">5</span>);\n\n<span class=\"macro\">assert!</span>(five == Arc::new(<span class=\"number\">5</span>));</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.ne\" class=\"method trait-impl\"><a href=\"#method.ne\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">ne</a>(&amp;self, other: &amp;Arc&lt;T, A&gt;) -&gt; bool</h4></section></summary><div class=\"docblock\"><p>Inequality for two <code>Arc</code>s.</p>\n<p>Two <code>Arc</code>s are not equal if their inner values are not equal.</p>\n<p>If <code>T</code> also implements <code>Eq</code> (implying reflexivity of equality),\ntwo <code>Arc</code>s that point to the same value are always equal.</p>\n<h5 id=\"examples-1\"><a class=\"doc-anchor\" href=\"#examples-1\">Â§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::sync::Arc;\n\n<span class=\"kw\">let </span>five = Arc::new(<span class=\"number\">5</span>);\n\n<span class=\"macro\">assert!</span>(five != Arc::new(<span class=\"number\">6</span>));</code></pre></div>\n</div></details></div></details>","PartialEq","rsiot::components::cmp_surrealdb::fn_process::Db"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-PartialOrd-for-Arc%3CT,+A%3E\" class=\"impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.0.0\">1.0.0</span><a href=\"#impl-PartialOrd-for-Arc%3CT,+A%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T, A&gt; PartialOrd for Arc&lt;T, A&gt;<div class=\"where\">where\n    T: PartialOrd + ?Sized,\n    A: Allocator,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.partial_cmp\" class=\"method trait-impl\"><a href=\"#method.partial_cmp\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">partial_cmp</a>(&amp;self, other: &amp;Arc&lt;T, A&gt;) -&gt; Option&lt;Ordering&gt;</h4></section></summary><div class=\"docblock\"><p>Partial comparison for two <code>Arc</code>s.</p>\n<p>The two are compared by calling <code>partial_cmp()</code> on their inner values.</p>\n<h5 id=\"examples\"><a class=\"doc-anchor\" href=\"#examples\">Â§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::sync::Arc;\n<span class=\"kw\">use </span>std::cmp::Ordering;\n\n<span class=\"kw\">let </span>five = Arc::new(<span class=\"number\">5</span>);\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"prelude-val\">Some</span>(Ordering::Less), five.partial_cmp(<span class=\"kw-2\">&amp;</span>Arc::new(<span class=\"number\">6</span>)));</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.lt\" class=\"method trait-impl\"><a href=\"#method.lt\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">lt</a>(&amp;self, other: &amp;Arc&lt;T, A&gt;) -&gt; bool</h4></section></summary><div class=\"docblock\"><p>Less-than comparison for two <code>Arc</code>s.</p>\n<p>The two are compared by calling <code>&lt;</code> on their inner values.</p>\n<h5 id=\"examples-1\"><a class=\"doc-anchor\" href=\"#examples-1\">Â§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::sync::Arc;\n\n<span class=\"kw\">let </span>five = Arc::new(<span class=\"number\">5</span>);\n\n<span class=\"macro\">assert!</span>(five &lt; Arc::new(<span class=\"number\">6</span>));</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.le\" class=\"method trait-impl\"><a href=\"#method.le\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">le</a>(&amp;self, other: &amp;Arc&lt;T, A&gt;) -&gt; bool</h4></section></summary><div class=\"docblock\"><p>â€˜Less than or equal toâ€™ comparison for two <code>Arc</code>s.</p>\n<p>The two are compared by calling <code>&lt;=</code> on their inner values.</p>\n<h5 id=\"examples-2\"><a class=\"doc-anchor\" href=\"#examples-2\">Â§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::sync::Arc;\n\n<span class=\"kw\">let </span>five = Arc::new(<span class=\"number\">5</span>);\n\n<span class=\"macro\">assert!</span>(five &lt;= Arc::new(<span class=\"number\">5</span>));</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.gt\" class=\"method trait-impl\"><a href=\"#method.gt\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">gt</a>(&amp;self, other: &amp;Arc&lt;T, A&gt;) -&gt; bool</h4></section></summary><div class=\"docblock\"><p>Greater-than comparison for two <code>Arc</code>s.</p>\n<p>The two are compared by calling <code>&gt;</code> on their inner values.</p>\n<h5 id=\"examples-3\"><a class=\"doc-anchor\" href=\"#examples-3\">Â§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::sync::Arc;\n\n<span class=\"kw\">let </span>five = Arc::new(<span class=\"number\">5</span>);\n\n<span class=\"macro\">assert!</span>(five &gt; Arc::new(<span class=\"number\">4</span>));</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.ge\" class=\"method trait-impl\"><a href=\"#method.ge\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">ge</a>(&amp;self, other: &amp;Arc&lt;T, A&gt;) -&gt; bool</h4></section></summary><div class=\"docblock\"><p>â€˜Greater than or equal toâ€™ comparison for two <code>Arc</code>s.</p>\n<p>The two are compared by calling <code>&gt;=</code> on their inner values.</p>\n<h5 id=\"examples-4\"><a class=\"doc-anchor\" href=\"#examples-4\">Â§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::sync::Arc;\n\n<span class=\"kw\">let </span>five = Arc::new(<span class=\"number\">5</span>);\n\n<span class=\"macro\">assert!</span>(five &gt;= Arc::new(<span class=\"number\">5</span>));</code></pre></div>\n</div></details></div></details>","PartialOrd","rsiot::components::cmp_surrealdb::fn_process::Db"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Pointer-for-Arc%3CT,+A%3E\" class=\"impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.0.0\">1.0.0</span><a href=\"#impl-Pointer-for-Arc%3CT,+A%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T, A&gt; Pointer for Arc&lt;T, A&gt;<div class=\"where\">where\n    A: Allocator,\n    T: ?Sized,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.fmt\" class=\"method trait-impl\"><a href=\"#method.fmt\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">fmt</a>(&amp;self, f: &amp;mut Formatter&lt;'_&gt;) -&gt; Result&lt;(), Error&gt;</h4></section></summary><div class='docblock'>Formats the value using the given formatter.</div></details></div></details>","Pointer","rsiot::components::cmp_surrealdb::fn_process::Db"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-RequestConnection-for-Arc%3CC%3E\" class=\"impl\"><a href=\"#impl-RequestConnection-for-Arc%3CC%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;C&gt; RequestConnection for Arc&lt;C&gt;<div class=\"where\">where\n    C: RequestConnection + ?Sized,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle\" open><summary><section id=\"associatedtype.Buf\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Buf\" class=\"anchor\">Â§</a><h4 class=\"code-header\">type <a class=\"associatedtype\">Buf</a> = &lt;C as RequestConnection&gt;::Buf</h4></section></summary><div class='docblock'>Type used as buffer to store raw replies or events before\nthey are parsed.</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.send_request_with_reply\" class=\"method trait-impl\"><a href=\"#method.send_request_with_reply\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">send_request_with_reply</a>&lt;R&gt;(\n    &amp;self,\n    bufs: &amp;[IoSlice&lt;'_&gt;],\n    fds: Vec&lt;OwnedFd&gt;\n) -&gt; Result&lt;Cookie&lt;'_, Arc&lt;C&gt;, R&gt;, ConnectionError&gt;<div class=\"where\">where\n    R: TryParse,</div></h4></section></summary><div class='docblock'>Send a request with a reply to the server. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.send_trait_request_with_reply\" class=\"method trait-impl\"><a href=\"#method.send_trait_request_with_reply\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">send_trait_request_with_reply</a>&lt;R&gt;(\n    &amp;self,\n    request: R\n) -&gt; Result&lt;Cookie&lt;'_, Arc&lt;C&gt;, &lt;R as ReplyRequest&gt;::Reply&gt;, ConnectionError&gt;<div class=\"where\">where\n    R: ReplyRequest,</div></h4></section></summary><div class='docblock'>Send a request with a reply to the server. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.send_request_with_reply_with_fds\" class=\"method trait-impl\"><a href=\"#method.send_request_with_reply_with_fds\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">send_request_with_reply_with_fds</a>&lt;R&gt;(\n    &amp;self,\n    bufs: &amp;[IoSlice&lt;'_&gt;],\n    fds: Vec&lt;OwnedFd&gt;\n) -&gt; Result&lt;CookieWithFds&lt;'_, Arc&lt;C&gt;, R&gt;, ConnectionError&gt;<div class=\"where\">where\n    R: TryParseFd,</div></h4></section></summary><div class='docblock'>Send a request with a reply containing file descriptors to the server. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.send_trait_request_with_reply_with_fds\" class=\"method trait-impl\"><a href=\"#method.send_trait_request_with_reply_with_fds\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">send_trait_request_with_reply_with_fds</a>&lt;R&gt;(\n    &amp;self,\n    request: R\n) -&gt; Result&lt;CookieWithFds&lt;'_, Arc&lt;C&gt;, &lt;R as ReplyFDsRequest&gt;::Reply&gt;, ConnectionError&gt;<div class=\"where\">where\n    R: ReplyFDsRequest,</div></h4></section></summary><div class='docblock'>Send a request with a reply containing file descriptors to the server. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.send_request_without_reply\" class=\"method trait-impl\"><a href=\"#method.send_request_without_reply\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">send_request_without_reply</a>(\n    &amp;self,\n    bufs: &amp;[IoSlice&lt;'_&gt;],\n    fds: Vec&lt;OwnedFd&gt;\n) -&gt; Result&lt;VoidCookie&lt;'_, Arc&lt;C&gt;&gt;, ConnectionError&gt;</h4></section></summary><div class='docblock'>Send a request without a reply to the server. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.send_trait_request_without_reply\" class=\"method trait-impl\"><a href=\"#method.send_trait_request_without_reply\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">send_trait_request_without_reply</a>&lt;R&gt;(\n    &amp;self,\n    request: R\n) -&gt; Result&lt;VoidCookie&lt;'_, Arc&lt;C&gt;&gt;, ConnectionError&gt;<div class=\"where\">where\n    R: VoidRequest,</div></h4></section></summary><div class='docblock'>Send a request without a reply to the server. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.discard_reply\" class=\"method trait-impl\"><a href=\"#method.discard_reply\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">discard_reply</a>(&amp;self, sequence: u64, kind: RequestKind, mode: DiscardMode)</h4></section></summary><div class='docblock'>A reply to an error should be discarded. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.prefetch_extension_information\" class=\"method trait-impl\"><a href=\"#method.prefetch_extension_information\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">prefetch_extension_information</a>(\n    &amp;self,\n    extension_name: &amp;'static str\n) -&gt; Result&lt;(), ConnectionError&gt;</h4></section></summary><div class='docblock'>Prefetches information about an extension. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.extension_information\" class=\"method trait-impl\"><a href=\"#method.extension_information\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">extension_information</a>(\n    &amp;self,\n    extension_name: &amp;'static str\n) -&gt; Result&lt;Option&lt;ExtensionInformation&gt;, ConnectionError&gt;</h4></section></summary><div class='docblock'>Get information about an extension. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.wait_for_reply_or_error\" class=\"method trait-impl\"><a href=\"#method.wait_for_reply_or_error\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">wait_for_reply_or_error</a>(\n    &amp;self,\n    sequence: u64\n) -&gt; Result&lt;&lt;Arc&lt;C&gt; as RequestConnection&gt;::Buf, ReplyError&gt;</h4></section></summary><div class='docblock'>Wait for the reply to a request. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.wait_for_reply_or_raw_error\" class=\"method trait-impl\"><a href=\"#method.wait_for_reply_or_raw_error\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">wait_for_reply_or_raw_error</a>(\n    &amp;self,\n    sequence: u64\n) -&gt; Result&lt;ReplyOrError&lt;&lt;Arc&lt;C&gt; as RequestConnection&gt;::Buf&gt;, ConnectionError&gt;</h4></section></summary><div class='docblock'>Wait for the reply to a request. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.wait_for_reply\" class=\"method trait-impl\"><a href=\"#method.wait_for_reply\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">wait_for_reply</a>(\n    &amp;self,\n    sequence: u64\n) -&gt; Result&lt;Option&lt;&lt;Arc&lt;C&gt; as RequestConnection&gt;::Buf&gt;, ConnectionError&gt;</h4></section></summary><div class='docblock'>Wait for the reply to a request. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.wait_for_reply_with_fds\" class=\"method trait-impl\"><a href=\"#method.wait_for_reply_with_fds\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">wait_for_reply_with_fds</a>(\n    &amp;self,\n    sequence: u64\n) -&gt; Result&lt;(&lt;Arc&lt;C&gt; as RequestConnection&gt;::Buf, Vec&lt;OwnedFd&gt;), ReplyError&gt;</h4></section></summary><div class='docblock'>Wait for the reply to a request that has FDs. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.wait_for_reply_with_fds_raw\" class=\"method trait-impl\"><a href=\"#method.wait_for_reply_with_fds_raw\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">wait_for_reply_with_fds_raw</a>(\n    &amp;self,\n    sequence: u64\n) -&gt; Result&lt;ReplyOrError&lt;(&lt;Arc&lt;C&gt; as RequestConnection&gt;::Buf, Vec&lt;OwnedFd&gt;), &lt;Arc&lt;C&gt; as RequestConnection&gt;::Buf&gt;, ConnectionError&gt;</h4></section></summary><div class='docblock'>Wait for the reply to a request that has FDs. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.check_for_error\" class=\"method trait-impl\"><a href=\"#method.check_for_error\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">check_for_error</a>(&amp;self, sequence: u64) -&gt; Result&lt;(), ReplyError&gt;</h4></section></summary><div class='docblock'>Check whether a request that does not have a reply caused an X11 error. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.check_for_raw_error\" class=\"method trait-impl\"><a href=\"#method.check_for_raw_error\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">check_for_raw_error</a>(\n    &amp;self,\n    sequence: u64\n) -&gt; Result&lt;Option&lt;&lt;Arc&lt;C&gt; as RequestConnection&gt;::Buf&gt;, ConnectionError&gt;</h4></section></summary><div class='docblock'>Check whether a request that does not have a reply caused an X11 error. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.prefetch_maximum_request_bytes\" class=\"method trait-impl\"><a href=\"#method.prefetch_maximum_request_bytes\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">prefetch_maximum_request_bytes</a>(&amp;self)</h4></section></summary><div class='docblock'>Prefetches the maximum request length. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.maximum_request_bytes\" class=\"method trait-impl\"><a href=\"#method.maximum_request_bytes\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">maximum_request_bytes</a>(&amp;self) -&gt; usize</h4></section></summary><div class='docblock'>The maximum number of bytes that the X11 server accepts in a request.</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.parse_error\" class=\"method trait-impl\"><a href=\"#method.parse_error\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">parse_error</a>(&amp;self, error: &amp;[u8]) -&gt; Result&lt;X11Error, ParseError&gt;</h4></section></summary><div class='docblock'>Parse a generic error.</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.parse_event\" class=\"method trait-impl\"><a href=\"#method.parse_event\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">parse_event</a>(&amp;self, event: &amp;[u8]) -&gt; Result&lt;Event, ParseError&gt;</h4></section></summary><div class='docblock'>Parse a generic event.</div></details></div></details>","RequestConnection","rsiot::components::cmp_surrealdb::fn_process::Db"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Serialize-for-Arc%3CT%3E\" class=\"impl\"><a class=\"src rightside\" href=\"https://docs.rs/serde/1.0.198/src/serde/ser/impls.rs.html#537-549\">source</a><a href=\"#impl-Serialize-for-Arc%3CT%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"rsiot/message/trait.Serialize.html\" title=\"trait rsiot::message::Serialize\">Serialize</a> for Arc&lt;T&gt;<div class=\"where\">where\n    T: <a class=\"trait\" href=\"rsiot/message/trait.Serialize.html\" title=\"trait rsiot::message::Serialize\">Serialize</a> + ?Sized,</div></h3></section></summary><div class=\"docblock\"><p>This impl requires the <a href=\"https://serde.rs/feature-flags.html#-features-rc\"><code>&quot;rc&quot;</code></a> Cargo feature of Serde.</p>\n<p>Serializing a data structure containing <code>Arc</code> will serialize a copy of\nthe contents of the <code>Arc</code> each time the <code>Arc</code> is referenced within the\ndata structure. Serialization will not attempt to deduplicate these\nrepeated data.</p>\n</div><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.serialize\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://docs.rs/serde/1.0.198/src/serde/ser/impls.rs.html#537-549\">source</a><a href=\"#method.serialize\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a href=\"rsiot/message/trait.Serialize.html#tymethod.serialize\" class=\"fn\">serialize</a>&lt;S&gt;(\n    &amp;self,\n    serializer: S\n) -&gt; Result&lt;&lt;S as <a class=\"trait\" href=\"https://docs.rs/serde/1.0.198/serde/ser/trait.Serializer.html\" title=\"trait serde::ser::Serializer\">Serializer</a>&gt;::<a class=\"associatedtype\" href=\"https://docs.rs/serde/1.0.198/serde/ser/trait.Serializer.html#associatedtype.Ok\" title=\"type serde::ser::Serializer::Ok\">Ok</a>, &lt;S as <a class=\"trait\" href=\"https://docs.rs/serde/1.0.198/serde/ser/trait.Serializer.html\" title=\"trait serde::ser::Serializer\">Serializer</a>&gt;::<a class=\"associatedtype\" href=\"https://docs.rs/serde/1.0.198/serde/ser/trait.Serializer.html#associatedtype.Error\" title=\"type serde::ser::Serializer::Error\">Error</a>&gt;<div class=\"where\">where\n    S: <a class=\"trait\" href=\"https://docs.rs/serde/1.0.198/serde/ser/trait.Serializer.html\" title=\"trait serde::ser::Serializer\">Serializer</a>,</div></h4></section></summary><div class='docblock'>Serialize this value into the given Serde serializer. <a href=\"rsiot/message/trait.Serialize.html#tymethod.serialize\">Read more</a></div></details></div></details>","Serialize","rsiot::components::cmp_surrealdb::fn_process::Db"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-SerializeAs%3CArc%3CT%3E%3E-for-Arc%3CU%3E\" class=\"impl\"><a class=\"src rightside\" href=\"https://docs.rs/serde_with/3.7.0/src/serde_with/ser/impls.rs.html#189-191\">source</a><a href=\"#impl-SerializeAs%3CArc%3CT%3E%3E-for-Arc%3CU%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T, U&gt; <a class=\"trait\" href=\"https://docs.rs/serde_with/3.7.0/serde_with/ser/trait.SerializeAs.html\" title=\"trait serde_with::ser::SerializeAs\">SerializeAs</a>&lt;Arc&lt;T&gt;&gt; for Arc&lt;U&gt;<div class=\"where\">where\n    U: <a class=\"trait\" href=\"https://docs.rs/serde_with/3.7.0/serde_with/ser/trait.SerializeAs.html\" title=\"trait serde_with::ser::SerializeAs\">SerializeAs</a>&lt;T&gt;,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.serialize_as\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://docs.rs/serde_with/3.7.0/src/serde_with/ser/impls.rs.html#193-195\">source</a><a href=\"#method.serialize_as\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a href=\"https://docs.rs/serde_with/3.7.0/serde_with/ser/trait.SerializeAs.html#tymethod.serialize_as\" class=\"fn\">serialize_as</a>&lt;S&gt;(\n    source: &amp;Arc&lt;T&gt;,\n    serializer: S\n) -&gt; Result&lt;&lt;S as <a class=\"trait\" href=\"https://docs.rs/serde/1.0.198/serde/ser/trait.Serializer.html\" title=\"trait serde::ser::Serializer\">Serializer</a>&gt;::<a class=\"associatedtype\" href=\"https://docs.rs/serde/1.0.198/serde/ser/trait.Serializer.html#associatedtype.Ok\" title=\"type serde::ser::Serializer::Ok\">Ok</a>, &lt;S as <a class=\"trait\" href=\"https://docs.rs/serde/1.0.198/serde/ser/trait.Serializer.html\" title=\"trait serde::ser::Serializer\">Serializer</a>&gt;::<a class=\"associatedtype\" href=\"https://docs.rs/serde/1.0.198/serde/ser/trait.Serializer.html#associatedtype.Error\" title=\"type serde::ser::Serializer::Error\">Error</a>&gt;<div class=\"where\">where\n    S: <a class=\"trait\" href=\"https://docs.rs/serde/1.0.198/serde/ser/trait.Serializer.html\" title=\"trait serde::ser::Serializer\">Serializer</a>,</div></h4></section></summary><div class='docblock'>Serialize this value into the given Serde serializer.</div></details></div></details>","SerializeAs<Arc<T>>","rsiot::components::cmp_surrealdb::fn_process::Db"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-SourceCode-for-Arc%3CT%3E\" class=\"impl\"><a href=\"#impl-SourceCode-for-Arc%3CT%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T&gt; SourceCode for Arc&lt;T&gt;<div class=\"where\">where\n    T: SourceCode + ?Sized,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.read_span\" class=\"method trait-impl\"><a href=\"#method.read_span\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">read_span</a>&lt;'a&gt;(\n    &amp;'a self,\n    span: &amp;SourceSpan,\n    context_lines_before: usize,\n    context_lines_after: usize\n) -&gt; Result&lt;Box&lt;dyn SpanContents&lt;'a&gt; + 'a&gt;, MietteError&gt;</h4></section></summary><div class='docblock'>Read the bytes for a specific span from this SourceCode, keeping a\ncertain number of lines before and after the span as context.</div></details></div></details>","SourceCode","rsiot::components::cmp_surrealdb::fn_process::Db"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Spawn-for-Arc%3CSp%3E\" class=\"impl\"><a href=\"#impl-Spawn-for-Arc%3CSp%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;Sp&gt; Spawn for Arc&lt;Sp&gt;<div class=\"where\">where\n    Sp: Spawn + ?Sized,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.spawn_obj\" class=\"method trait-impl\"><a href=\"#method.spawn_obj\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">spawn_obj</a>(&amp;self, future: FutureObj&lt;'static, ()&gt;) -&gt; Result&lt;(), SpawnError&gt;</h4></section></summary><div class='docblock'>Spawns a future that will be run to completion. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.status\" class=\"method trait-impl\"><a href=\"#method.status\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">status</a>(&amp;self) -&gt; Result&lt;(), SpawnError&gt;</h4></section></summary><div class='docblock'>Determines whether the executor is able to spawn new tasks. <a>Read more</a></div></details></div></details>","Spawn","rsiot::components::cmp_surrealdb::fn_process::Db"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Subscriber-for-Arc%3CS%3E\" class=\"impl\"><a href=\"#impl-Subscriber-for-Arc%3CS%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;S&gt; Subscriber for Arc&lt;S&gt;<div class=\"where\">where\n    S: Subscriber + ?Sized,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.register_callsite\" class=\"method trait-impl\"><a href=\"#method.register_callsite\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">register_callsite</a>(&amp;self, metadata: &amp;'static Metadata&lt;'static&gt;) -&gt; Interest</h4></section></summary><div class='docblock'>Registers a new <a href=\"crate::callsite\">callsite</a> with this subscriber, returning whether or not\nthe subscriber is interested in being notified about the callsite. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.enabled\" class=\"method trait-impl\"><a href=\"#method.enabled\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">enabled</a>(&amp;self, metadata: &amp;Metadata&lt;'_&gt;) -&gt; bool</h4></section></summary><div class='docblock'>Returns true if a span or event with the specified <a href=\"super::metadata::Metadata\">metadata</a> would be\nrecorded. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.max_level_hint\" class=\"method trait-impl\"><a href=\"#method.max_level_hint\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">max_level_hint</a>(&amp;self) -&gt; Option&lt;LevelFilter&gt;</h4></section></summary><div class='docblock'>Returns the highest <a href=\"super::Level\">verbosity level</a> that this <code>Subscriber</code> will\nenable, or <code>None</code>, if the subscriber does not implement level-based\nfiltering or chooses not to implement this method. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.new_span\" class=\"method trait-impl\"><a href=\"#method.new_span\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">new_span</a>(&amp;self, span: &amp;Attributes&lt;'_&gt;) -&gt; Id</h4></section></summary><div class='docblock'>Visit the construction of a new span, returning a new <a href=\"super::span::Id\">span ID</a> for the\nspan being constructed. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.record\" class=\"method trait-impl\"><a href=\"#method.record\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">record</a>(&amp;self, span: &amp;Id, values: &amp;Record&lt;'_&gt;)</h4></section></summary><div class='docblock'>Record a set of values on a span. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.record_follows_from\" class=\"method trait-impl\"><a href=\"#method.record_follows_from\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">record_follows_from</a>(&amp;self, span: &amp;Id, follows: &amp;Id)</h4></section></summary><div class='docblock'>Adds an indication that <code>span</code> follows from the span with the id\n<code>follows</code>. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.event_enabled\" class=\"method trait-impl\"><a href=\"#method.event_enabled\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">event_enabled</a>(&amp;self, event: &amp;Event&lt;'_&gt;) -&gt; bool</h4></section></summary><div class='docblock'>Determine if an [<code>Event</code>] should be recorded. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.event\" class=\"method trait-impl\"><a href=\"#method.event\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">event</a>(&amp;self, event: &amp;Event&lt;'_&gt;)</h4></section></summary><div class='docblock'>Records that an <a href=\"super::event::Event\"><code>Event</code></a> has occurred. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.enter\" class=\"method trait-impl\"><a href=\"#method.enter\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">enter</a>(&amp;self, span: &amp;Id)</h4></section></summary><div class='docblock'>Records that a span has been entered. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.exit\" class=\"method trait-impl\"><a href=\"#method.exit\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">exit</a>(&amp;self, span: &amp;Id)</h4></section></summary><div class='docblock'>Records that a span has been exited. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.clone_span\" class=\"method trait-impl\"><a href=\"#method.clone_span\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">clone_span</a>(&amp;self, id: &amp;Id) -&gt; Id</h4></section></summary><div class='docblock'>Notifies the subscriber that a <a href=\"super::span::Id\">span ID</a> has been cloned. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.try_close\" class=\"method trait-impl\"><a href=\"#method.try_close\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">try_close</a>(&amp;self, id: Id) -&gt; bool</h4></section></summary><div class='docblock'>Notifies the subscriber that a <a href=\"super::span::Id\">span ID</a> has been dropped, and returns\n<code>true</code> if there are now 0 IDs that refer to that span. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.drop_span\" class=\"method trait-impl\"><a href=\"#method.drop_span\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">drop_span</a>(&amp;self, id: Id)</h4></section></summary><span class=\"item-info\"><div class=\"stab deprecated\"><span class=\"emoji\">ðŸ‘Ž</span><span>Deprecated since 0.1.2: use <code>Subscriber::try_close</code> instead</span></div></span><div class='docblock'><strong>This method is deprecated.</strong> <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.current_span\" class=\"method trait-impl\"><a href=\"#method.current_span\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">current_span</a>(&amp;self) -&gt; Current</h4></section></summary><div class='docblock'>Returns a type representing this subscriberâ€™s view of the current span. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.downcast_raw\" class=\"method trait-impl\"><a href=\"#method.downcast_raw\" class=\"anchor\">Â§</a><h4 class=\"code-header\">unsafe fn <a class=\"fn\">downcast_raw</a>(&amp;self, id: TypeId) -&gt; Option&lt;*const ()&gt;</h4></section></summary><div class='docblock'>If <code>self</code> is the same type as the provided <code>TypeId</code>, returns an untyped\n<code>*const</code> pointer to that type. Otherwise, returns <code>None</code>. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.on_register_dispatch\" class=\"method trait-impl\"><a href=\"#method.on_register_dispatch\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">on_register_dispatch</a>(&amp;self, subscriber: &amp;Dispatch)</h4></section></summary><div class='docblock'>Invoked when this subscriber becomes a [<code>Dispatch</code>]. <a>Read more</a></div></details></div></details>","Subscriber","rsiot::components::cmp_surrealdb::fn_process::Db"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Type-for-Arc%3CT%3E\" class=\"impl\"><a href=\"#impl-Type-for-Arc%3CT%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T&gt; Type for Arc&lt;T&gt;<div class=\"where\">where\n    T: Type + ?Sized,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.signature\" class=\"method trait-impl\"><a href=\"#method.signature\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">signature</a>() -&gt; Signature&lt;'static&gt;</h4></section></summary><div class='docblock'>Get the signature for the implementing type. <a>Read more</a></div></details></div></details>","Type","rsiot::components::cmp_surrealdb::fn_process::Db"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-ValueParserFactory-for-Arc%3CT%3E\" class=\"impl\"><a href=\"#impl-ValueParserFactory-for-Arc%3CT%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T&gt; ValueParserFactory for Arc&lt;T&gt;<div class=\"where\">where\n    T: ValueParserFactory + Send + Sync + Clone,\n    &lt;T as ValueParserFactory&gt;::Parser: TypedValueParser&lt;Value = T&gt;,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle\" open><summary><section id=\"associatedtype.Parser\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Parser\" class=\"anchor\">Â§</a><h4 class=\"code-header\">type <a class=\"associatedtype\">Parser</a> = MapValueParser&lt;&lt;T as ValueParserFactory&gt;::Parser, fn(_: T) -&gt; Arc&lt;T&gt;&gt;</h4></section></summary><div class='docblock'>Generated parser, usually [<code>ValueParser</code>]. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.value_parser\" class=\"method trait-impl\"><a href=\"#method.value_parser\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a class=\"fn\">value_parser</a>() -&gt; &lt;Arc&lt;T&gt; as ValueParserFactory&gt;::Parser <a href=\"#\" class=\"tooltip\" data-notable-ty=\"&lt;Arc&lt;T&gt; as ValueParserFactory&gt;::Parser\">â“˜</a></h4></section></summary><div class='docblock'>Create the specified [<code>Self::Parser</code>]</div></details></div></details>","ValueParserFactory","rsiot::components::cmp_surrealdb::fn_process::Db"],["<section id=\"impl-CoerceUnsized%3CArc%3CU,+A%3E%3E-for-Arc%3CT,+A%3E\" class=\"impl\"><a href=\"#impl-CoerceUnsized%3CArc%3CU,+A%3E%3E-for-Arc%3CT,+A%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T, U, A&gt; CoerceUnsized&lt;Arc&lt;U, A&gt;&gt; for Arc&lt;T, A&gt;<div class=\"where\">where\n    T: Unsize&lt;U&gt; + ?Sized,\n    A: Allocator,\n    U: ?Sized,</div></h3></section>","CoerceUnsized<Arc<U, A>>","rsiot::components::cmp_surrealdb::fn_process::Db"],["<section id=\"impl-DerefPure-for-Arc%3CT,+A%3E\" class=\"impl\"><a href=\"#impl-DerefPure-for-Arc%3CT,+A%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T, A&gt; DerefPure for Arc&lt;T, A&gt;<div class=\"where\">where\n    A: Allocator,\n    T: ?Sized,</div></h3></section>","DerefPure","rsiot::components::cmp_surrealdb::fn_process::Db"],["<section id=\"impl-DispatchFromDyn%3CArc%3CU%3E%3E-for-Arc%3CT%3E\" class=\"impl\"><a href=\"#impl-DispatchFromDyn%3CArc%3CU%3E%3E-for-Arc%3CT%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T, U&gt; DispatchFromDyn&lt;Arc&lt;U&gt;&gt; for Arc&lt;T&gt;<div class=\"where\">where\n    T: Unsize&lt;U&gt; + ?Sized,\n    U: ?Sized,</div></h3></section>","DispatchFromDyn<Arc<U>>","rsiot::components::cmp_surrealdb::fn_process::Db"],["<section id=\"impl-Eq-for-Arc%3CT,+A%3E\" class=\"impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.0.0\">1.0.0</span><a href=\"#impl-Eq-for-Arc%3CT,+A%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T, A&gt; Eq for Arc&lt;T, A&gt;<div class=\"where\">where\n    T: Eq + ?Sized,\n    A: Allocator,</div></h3></section>","Eq","rsiot::components::cmp_surrealdb::fn_process::Db"],["<section id=\"impl-Send-for-Arc%3CT,+A%3E\" class=\"impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.0.0\">1.0.0</span><a href=\"#impl-Send-for-Arc%3CT,+A%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T, A&gt; Send for Arc&lt;T, A&gt;<div class=\"where\">where\n    T: Sync + Send + ?Sized,\n    A: Allocator + Send,</div></h3></section>","Send","rsiot::components::cmp_surrealdb::fn_process::Db"],["<section id=\"impl-Sync-for-Arc%3CT,+A%3E\" class=\"impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.0.0\">1.0.0</span><a href=\"#impl-Sync-for-Arc%3CT,+A%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T, A&gt; Sync for Arc&lt;T, A&gt;<div class=\"where\">where\n    T: Sync + Send + ?Sized,\n    A: Allocator + Sync,</div></h3></section>","Sync","rsiot::components::cmp_surrealdb::fn_process::Db"],["<section id=\"impl-Unpin-for-Arc%3CT,+A%3E\" class=\"impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.33.0\">1.33.0</span><a href=\"#impl-Unpin-for-Arc%3CT,+A%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T, A&gt; Unpin for Arc&lt;T, A&gt;<div class=\"where\">where\n    A: Allocator,\n    T: ?Sized,</div></h3></section>","Unpin","rsiot::components::cmp_surrealdb::fn_process::Db"],["<section id=\"impl-UnwindSafe-for-Arc%3CT,+A%3E\" class=\"impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.9.0\">1.9.0</span><a href=\"#impl-UnwindSafe-for-Arc%3CT,+A%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T, A&gt; UnwindSafe for Arc&lt;T, A&gt;<div class=\"where\">where\n    T: RefUnwindSafe + ?Sized,\n    A: Allocator + UnwindSafe,</div></h3></section>","UnwindSafe","rsiot::components::cmp_surrealdb::fn_process::Db"]]
};if (window.register_type_impls) {window.register_type_impls(type_impls);} else {window.pending_type_impls = type_impls;}})()