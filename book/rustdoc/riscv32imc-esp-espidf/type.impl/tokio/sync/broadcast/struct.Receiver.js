(function() {var type_impls = {
"rsiot":[["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Receiver%3CT%3E\" class=\"impl\"><a href=\"#impl-Receiver%3CT%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T&gt; Receiver&lt;T&gt;</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.len\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">len</a>(&amp;self) -&gt; usize</h4></section></summary><div class=\"docblock\"><p>Returns the number of messages that were sent into the channel and that\nthis <a href=\"crate::sync::broadcast::Receiver\"><code>Receiver</code></a> has yet to receive.</p>\n<p>If the returned value from <code>len</code> is larger than the next largest power of 2\nof the capacity of the channel any call to <a href=\"crate::sync::broadcast::Receiver::recv\"><code>recv</code></a> will return an\n<code>Err(RecvError::Lagged)</code> and any call to <a href=\"crate::sync::broadcast::Receiver::try_recv\"><code>try_recv</code></a> will return an\n<code>Err(TryRecvError::Lagged)</code>, e.g. if the capacity of the channel is 10,\n<a href=\"crate::sync::broadcast::Receiver::recv\"><code>recv</code></a> will start to return <code>Err(RecvError::Lagged)</code> once <code>len</code> returns\nvalues larger than 16.</p>\n<h5 id=\"examples\"><a class=\"doc-anchor\" href=\"#examples\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>tokio::sync::broadcast;\n\n<span class=\"attr\">#[tokio::main]\n</span><span class=\"kw\">async fn </span>main() {\n    <span class=\"kw\">let </span>(tx, <span class=\"kw-2\">mut </span>rx1) = broadcast::channel(<span class=\"number\">16</span>);\n\n    tx.send(<span class=\"number\">10</span>).unwrap();\n    tx.send(<span class=\"number\">20</span>).unwrap();\n\n    <span class=\"macro\">assert_eq!</span>(rx1.len(), <span class=\"number\">2</span>);\n    <span class=\"macro\">assert_eq!</span>(rx1.recv().<span class=\"kw\">await</span>.unwrap(), <span class=\"number\">10</span>);\n    <span class=\"macro\">assert_eq!</span>(rx1.len(), <span class=\"number\">1</span>);\n    <span class=\"macro\">assert_eq!</span>(rx1.recv().<span class=\"kw\">await</span>.unwrap(), <span class=\"number\">20</span>);\n    <span class=\"macro\">assert_eq!</span>(rx1.len(), <span class=\"number\">0</span>);\n}</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.is_empty\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">is_empty</a>(&amp;self) -&gt; bool</h4></section></summary><div class=\"docblock\"><p>Returns true if there aren’t any messages in the channel that the [<code>Receiver</code>]\nhas yet to receive.</p>\n<h5 id=\"examples-1\"><a class=\"doc-anchor\" href=\"#examples-1\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>tokio::sync::broadcast;\n\n<span class=\"attr\">#[tokio::main]\n</span><span class=\"kw\">async fn </span>main() {\n    <span class=\"kw\">let </span>(tx, <span class=\"kw-2\">mut </span>rx1) = broadcast::channel(<span class=\"number\">16</span>);\n\n    <span class=\"macro\">assert!</span>(rx1.is_empty());\n\n    tx.send(<span class=\"number\">10</span>).unwrap();\n    tx.send(<span class=\"number\">20</span>).unwrap();\n\n    <span class=\"macro\">assert!</span>(!rx1.is_empty());\n    <span class=\"macro\">assert_eq!</span>(rx1.recv().<span class=\"kw\">await</span>.unwrap(), <span class=\"number\">10</span>);\n    <span class=\"macro\">assert_eq!</span>(rx1.recv().<span class=\"kw\">await</span>.unwrap(), <span class=\"number\">20</span>);\n    <span class=\"macro\">assert!</span>(rx1.is_empty());\n}</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.same_channel\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">same_channel</a>(&amp;self, other: &amp;Receiver&lt;T&gt;) -&gt; bool</h4></section></summary><div class=\"docblock\"><p>Returns <code>true</code> if receivers belong to the same channel.</p>\n<h5 id=\"examples-2\"><a class=\"doc-anchor\" href=\"#examples-2\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>tokio::sync::broadcast;\n\n<span class=\"attr\">#[tokio::main]\n</span><span class=\"kw\">async fn </span>main() {\n    <span class=\"kw\">let </span>(tx, rx) = broadcast::channel::&lt;()&gt;(<span class=\"number\">16</span>);\n    <span class=\"kw\">let </span>rx2 = tx.subscribe();\n\n    <span class=\"macro\">assert!</span>(rx.same_channel(<span class=\"kw-2\">&amp;</span>rx2));\n\n    <span class=\"kw\">let </span>(_tx3, rx3) = broadcast::channel::&lt;()&gt;(<span class=\"number\">16</span>);\n\n    <span class=\"macro\">assert!</span>(!rx3.same_channel(<span class=\"kw-2\">&amp;</span>rx2));\n}</code></pre></div>\n</div></details></div></details>",0,"rsiot::executor::types::CmpInput"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Receiver%3CT%3E\" class=\"impl\"><a href=\"#impl-Receiver%3CT%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T&gt; Receiver&lt;T&gt;<div class=\"where\">where\n    T: Clone,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.resubscribe\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">resubscribe</a>(&amp;self) -&gt; Receiver&lt;T&gt;</h4></section></summary><div class=\"docblock\"><p>Re-subscribes to the channel starting from the current tail element.</p>\n<p>This [<code>Receiver</code>] handle will receive a clone of all values sent\n<strong>after</strong> it has resubscribed. This will not include elements that are\nin the queue of the current receiver. Consider the following example.</p>\n<h5 id=\"examples\"><a class=\"doc-anchor\" href=\"#examples\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>tokio::sync::broadcast;\n\n<span class=\"attr\">#[tokio::main]\n</span><span class=\"kw\">async fn </span>main() {\n  <span class=\"kw\">let </span>(tx, <span class=\"kw-2\">mut </span>rx) = broadcast::channel(<span class=\"number\">2</span>);\n\n  tx.send(<span class=\"number\">1</span>).unwrap();\n  <span class=\"kw\">let </span><span class=\"kw-2\">mut </span>rx2 = rx.resubscribe();\n  tx.send(<span class=\"number\">2</span>).unwrap();\n\n  <span class=\"macro\">assert_eq!</span>(rx2.recv().<span class=\"kw\">await</span>.unwrap(), <span class=\"number\">2</span>);\n  <span class=\"macro\">assert_eq!</span>(rx.recv().<span class=\"kw\">await</span>.unwrap(), <span class=\"number\">1</span>);\n}</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.recv\" class=\"method\"><h4 class=\"code-header\">pub async fn <a class=\"fn\">recv</a>(&amp;mut self) -&gt; Result&lt;T, RecvError&gt;</h4></section></summary><div class=\"docblock\"><p>Receives the next value for this receiver.</p>\n<p>Each <a href=\"crate::sync::broadcast::Receiver\"><code>Receiver</code></a> handle will receive a clone of all values sent\n<strong>after</strong> it has subscribed.</p>\n<p><code>Err(RecvError::Closed)</code> is returned when all <code>Sender</code> halves have\ndropped, indicating that no further values can be sent on the channel.</p>\n<p>If the <a href=\"crate::sync::broadcast::Receiver\"><code>Receiver</code></a> handle falls behind, once the channel is full, newly\nsent values will overwrite old values. At this point, a call to <a href=\"crate::sync::broadcast::Receiver::recv\"><code>recv</code></a>\nwill return with <code>Err(RecvError::Lagged)</code> and the <a href=\"crate::sync::broadcast::Receiver\"><code>Receiver</code></a>’s\ninternal cursor is updated to point to the oldest value still held by\nthe channel. A subsequent call to <a href=\"crate::sync::broadcast::Receiver::recv\"><code>recv</code></a> will return this value\n<strong>unless</strong> it has been since overwritten.</p>\n<h5 id=\"cancel-safety\"><a class=\"doc-anchor\" href=\"#cancel-safety\">§</a>Cancel safety</h5>\n<p>This method is cancel safe. If <code>recv</code> is used as the event in a\n<a href=\"crate::select\"><code>tokio::select!</code></a> statement and some other branch\ncompletes first, it is guaranteed that no messages were received on this\nchannel.</p>\n<h5 id=\"examples-1\"><a class=\"doc-anchor\" href=\"#examples-1\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>tokio::sync::broadcast;\n\n<span class=\"attr\">#[tokio::main]\n</span><span class=\"kw\">async fn </span>main() {\n    <span class=\"kw\">let </span>(tx, <span class=\"kw-2\">mut </span>rx1) = broadcast::channel(<span class=\"number\">16</span>);\n    <span class=\"kw\">let </span><span class=\"kw-2\">mut </span>rx2 = tx.subscribe();\n\n    tokio::spawn(<span class=\"kw\">async move </span>{\n        <span class=\"macro\">assert_eq!</span>(rx1.recv().<span class=\"kw\">await</span>.unwrap(), <span class=\"number\">10</span>);\n        <span class=\"macro\">assert_eq!</span>(rx1.recv().<span class=\"kw\">await</span>.unwrap(), <span class=\"number\">20</span>);\n    });\n\n    tokio::spawn(<span class=\"kw\">async move </span>{\n        <span class=\"macro\">assert_eq!</span>(rx2.recv().<span class=\"kw\">await</span>.unwrap(), <span class=\"number\">10</span>);\n        <span class=\"macro\">assert_eq!</span>(rx2.recv().<span class=\"kw\">await</span>.unwrap(), <span class=\"number\">20</span>);\n    });\n\n    tx.send(<span class=\"number\">10</span>).unwrap();\n    tx.send(<span class=\"number\">20</span>).unwrap();\n}</code></pre></div>\n<p>Handling lag</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>tokio::sync::broadcast;\n\n<span class=\"attr\">#[tokio::main]\n</span><span class=\"kw\">async fn </span>main() {\n    <span class=\"kw\">let </span>(tx, <span class=\"kw-2\">mut </span>rx) = broadcast::channel(<span class=\"number\">2</span>);\n\n    tx.send(<span class=\"number\">10</span>).unwrap();\n    tx.send(<span class=\"number\">20</span>).unwrap();\n    tx.send(<span class=\"number\">30</span>).unwrap();\n\n    <span class=\"comment\">// The receiver lagged behind\n    </span><span class=\"macro\">assert!</span>(rx.recv().<span class=\"kw\">await</span>.is_err());\n\n    <span class=\"comment\">// At this point, we can abort or continue with lost messages\n\n    </span><span class=\"macro\">assert_eq!</span>(<span class=\"number\">20</span>, rx.recv().<span class=\"kw\">await</span>.unwrap());\n    <span class=\"macro\">assert_eq!</span>(<span class=\"number\">30</span>, rx.recv().<span class=\"kw\">await</span>.unwrap());\n}</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.try_recv\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">try_recv</a>(&amp;mut self) -&gt; Result&lt;T, TryRecvError&gt;</h4></section></summary><div class=\"docblock\"><p>Attempts to return a pending value on this receiver without awaiting.</p>\n<p>This is useful for a flavor of “optimistic check” before deciding to\nawait on a receiver.</p>\n<p>Compared with <a href=\"crate::sync::broadcast::Receiver::recv\"><code>recv</code></a>, this function has three failure cases instead of two\n(one for closed, one for an empty buffer, one for a lagging receiver).</p>\n<p><code>Err(TryRecvError::Closed)</code> is returned when all <code>Sender</code> halves have\ndropped, indicating that no further values can be sent on the channel.</p>\n<p>If the <a href=\"crate::sync::broadcast::Receiver\"><code>Receiver</code></a> handle falls behind, once the channel is full, newly\nsent values will overwrite old values. At this point, a call to <a href=\"crate::sync::broadcast::Receiver::recv\"><code>recv</code></a>\nwill return with <code>Err(TryRecvError::Lagged)</code> and the <a href=\"crate::sync::broadcast::Receiver\"><code>Receiver</code></a>’s\ninternal cursor is updated to point to the oldest value still held by\nthe channel. A subsequent call to <a href=\"crate::sync::broadcast::Receiver::try_recv\"><code>try_recv</code></a> will return this value\n<strong>unless</strong> it has been since overwritten. If there are no values to\nreceive, <code>Err(TryRecvError::Empty)</code> is returned.</p>\n<h5 id=\"examples-2\"><a class=\"doc-anchor\" href=\"#examples-2\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>tokio::sync::broadcast;\n\n<span class=\"attr\">#[tokio::main]\n</span><span class=\"kw\">async fn </span>main() {\n    <span class=\"kw\">let </span>(tx, <span class=\"kw-2\">mut </span>rx) = broadcast::channel(<span class=\"number\">16</span>);\n\n    <span class=\"macro\">assert!</span>(rx.try_recv().is_err());\n\n    tx.send(<span class=\"number\">10</span>).unwrap();\n\n    <span class=\"kw\">let </span>value = rx.try_recv().unwrap();\n    <span class=\"macro\">assert_eq!</span>(<span class=\"number\">10</span>, value);\n}</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.blocking_recv\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">blocking_recv</a>(&amp;mut self) -&gt; Result&lt;T, RecvError&gt;</h4></section></summary><div class=\"docblock\"><p>Blocking receive to call outside of asynchronous contexts.</p>\n<h5 id=\"panics\"><a class=\"doc-anchor\" href=\"#panics\">§</a>Panics</h5>\n<p>This function panics if called within an asynchronous execution\ncontext.</p>\n<h5 id=\"examples-3\"><a class=\"doc-anchor\" href=\"#examples-3\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::thread;\n<span class=\"kw\">use </span>tokio::sync::broadcast;\n\n<span class=\"attr\">#[tokio::main]\n</span><span class=\"kw\">async fn </span>main() {\n    <span class=\"kw\">let </span>(tx, <span class=\"kw-2\">mut </span>rx) = broadcast::channel(<span class=\"number\">16</span>);\n\n    <span class=\"kw\">let </span>sync_code = thread::spawn(<span class=\"kw\">move </span>|| {\n        <span class=\"macro\">assert_eq!</span>(rx.blocking_recv(), <span class=\"prelude-val\">Ok</span>(<span class=\"number\">10</span>));\n    });\n\n    <span class=\"kw\">let _ </span>= tx.send(<span class=\"number\">10</span>);\n    sync_code.join().unwrap();\n}</code></pre></div>\n</div></details></div></details>",0,"rsiot::executor::types::CmpInput"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Drop-for-Receiver%3CT%3E\" class=\"impl\"><a href=\"#impl-Drop-for-Receiver%3CT%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T&gt; Drop for Receiver&lt;T&gt;</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.drop\" class=\"method trait-impl\"><a href=\"#method.drop\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a class=\"fn\">drop</a>(&amp;mut self)</h4></section></summary><div class='docblock'>Executes the destructor for this type. <a>Read more</a></div></details></div></details>","Drop","rsiot::executor::types::CmpInput"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Debug-for-Receiver%3CT%3E\" class=\"impl\"><a href=\"#impl-Debug-for-Receiver%3CT%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T&gt; Debug for Receiver&lt;T&gt;</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.fmt\" class=\"method trait-impl\"><a href=\"#method.fmt\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a class=\"fn\">fmt</a>(&amp;self, fmt: &amp;mut Formatter&lt;'_&gt;) -&gt; Result&lt;(), Error&gt;</h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a>Read more</a></div></details></div></details>","Debug","rsiot::executor::types::CmpInput"],["<section id=\"impl-Send-for-Receiver%3CT%3E\" class=\"impl\"><a href=\"#impl-Send-for-Receiver%3CT%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T&gt; Send for Receiver&lt;T&gt;<div class=\"where\">where\n    T: Send,</div></h3></section>","Send","rsiot::executor::types::CmpInput"],["<section id=\"impl-Sync-for-Receiver%3CT%3E\" class=\"impl\"><a href=\"#impl-Sync-for-Receiver%3CT%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T&gt; Sync for Receiver&lt;T&gt;<div class=\"where\">where\n    T: Send,</div></h3></section>","Sync","rsiot::executor::types::CmpInput"]]
};if (window.register_type_impls) {window.register_type_impls(type_impls);} else {window.pending_type_impls = type_impls;}})()